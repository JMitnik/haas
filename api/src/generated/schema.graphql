### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


input AddDialogueInput {
  contentType: String
  customerSlug: String
  description: String
  dialogueSlug: String
  isSeed: Boolean
  publicTitle: String
  tags: TagsInputObjectType
  templateDialogueId: String
  title: String
}

"""Input type for a choice node"""
input ChoiceNodeEntryInput {
  value: String
}

type ColourSettings {
  id: ID!
  primary: String!
  primaryAlt: String
  secondary: String
}

"""Interface all pagination-based models should implement"""
interface ConnectionInterface {
  endDate: String
  limit: Int!
  offset: Int!
  pageInfo: PaginationPageInfo!
  startDate: String
}

input CTALinkInputObjectType {
  backgroundColor: String
  iconUrl: String
  id: String
  title: String
  type: LinkTypeEnumType
  url: String
}

input CTALinksInputType {
  linkTypes: [CTALinkInputObjectType!]
}

type Customer {
  dialogue(where: DialogueWhereUniqueInput): Dialogue
  dialogues(filter: DialogueFilterInputType): [Dialogue!]
  id: ID!
  name: String!
  settings: CustomerSettings
  slug: String!
  usersConnection(customerSlug: String, filter: PaginationWhereInput): UserConnection
}

input CustomerCreateOptions {
  isSeed: Boolean = false
  logo: String
  primaryColour: String!
  slug: String!
}

input CustomerEditOptions {
  logo: String
  name: String!
  primaryColour: String!
  slug: String!
}

type CustomerSettings {
  colourSettings: ColourSettings
  fontSettings: FontSettings
  id: ID!
  logoUrl: String
}

input CustomerWhereUniqueInput {
  id: ID!
}

"""Date custom scalar type"""
scalar Date

type Debug {
  debugResolver: String
}

type Dialogue {
  averageScore(input: DialogueFilterInputType): Float!
  countInteractions: Int!
  creationDate: String
  customer: Customer
  customerId: String!
  description: String!
  edges: [Edge!]!
  id: ID!
  leafs(searchTerm: String): [QuestionNode!]!
  publicTitle: String
  questions: [QuestionNode!]!
  rootQuestion: QuestionNode!
  sessionConnection(filter: PaginationWhereInput): SessionConnection
  sessions(take: Int): [Session!]!
  slug: String!
  statistics: DialogueStatistics
  tags: [Tag!]
  title: String!
  updatedAt: String
}

input DialogueFilterInputType {
  endDate: String
  searchTerm: String
  startDate: String
}

type DialogueStatistics {
  history: [lineChartDataType!]
  mostPopularPath: topPathType
  topNegativePath: [topPathType!]
  topPositivePath: [topPathType!]
}

input DialogueWhereUniqueInput {
  id: ID
  slug: String
}

type Edge {
  childNode: QuestionNode
  childNodeId: String!
  conditions: [EdgeCondition!]
  createdAt: String!
  id: ID!
  parentNode: QuestionNode
  parentNodeId: String!
  updatedAt: String!
}

type EdgeCondition {
  conditionType: String!
  edgeId: String
  id: Int!
  matchValue: String
  renderMax: Int
  renderMin: Int
}

input EdgeConditionInputType {
  conditionType: String
  id: Int
  matchValue: String
  renderMax: Int
  renderMin: Int
}

input EditUserInput {
  customerId: String
  email: String!
  firstName: String
  lastName: String
  phone: String
}

type FontSettings {
  id: ID!
}

type ImageType {
  encoding: String
  filename: String
  mimetype: String
  url: String
}

input InviteUserInput {
  customerId: String!
  email: String!
  roleId: String!
}

type InviteUserOutput {
  didAlreadyExist: Boolean!
  didInvite: Boolean!
}

type lineChartDataType {
  entryId: String
  x: String
  y: Int
}

type LinkType {
  backgroundColor: String
  iconUrl: String
  id: String!
  questionNode: QuestionNode!
  questionNodeId: String
  title: String
  type: String!
  url: String!
}

enum LinkTypeEnumType {
  API
  FACEBOOK
  INSTAGRAM
  LINKEDIN
  SOCIAL
  TWITTER
  WHATSAPP
}

"""Login credential"""
input LoginInput {
  email: String!
}

"""Information you get after you log out"""
type LoginOutput {
  expiryDate: Int!
  token: String!
  user: UserType!
}

type Mutation {
  assignTags(dialogueId: String, tags: TagsInputObjectType): Dialogue!
  copyDialogue(data: AddDialogueInput): Dialogue!
  createCTA(customerSlug: String, dialogueSlug: String, links: CTALinksInputType, title: String, type: String): QuestionNode!
  createCustomer(name: String, options: CustomerCreateOptions): Customer!
  createDialogue(data: AddDialogueInput): Dialogue!
  createPermission(data: PermissionInput): PermssionType
  createQuestion(customerSlug: String, dialogueSlug: String, edgeCondition: EdgeConditionInputType, optionEntries: OptionsInputType, overrideLeafId: String, parentQuestionId: String, title: String, type: String): QuestionNode
  createRole(data: RoleInput): RoleType!
  createSession(input: SessionInput): Session!
  createTag(customerSlug: String, name: String, type: TagTypeEnum): Tag!
  createTrigger(customerSlug: String, questionId: String, recipients: RecipientsInputType, trigger: TriggerInputType): TriggerType!
  createUser(customerSlug: String, input: UserInput): UserType!
  debugMutation: String
  deleteCTA(id: String): QuestionNode!
  deleteCustomer(where: CustomerWhereUniqueInput): Customer
  deleteDialogue(where: DialogueWhereUniqueInput): Dialogue!
  deleteQuestion(customerSlug: String, dialogueSlug: String, id: String): QuestionNode!
  deleteTag(tagId: String): Tag!
  deleteTrigger(id: String): TriggerType
  deleteUser(id: String): UserType!
  editCustomer(id: String, options: CustomerEditOptions): Customer!
  editDialogue(customerSlug: String, description: String, dialogueSlug: String, publicTitle: String, tags: TagsInputObjectType, title: String): Dialogue!
  editTrigger(questionId: String, recipients: RecipientsInputType, trigger: TriggerInputType, triggerId: String): TriggerType!
  editUser(input: EditUserInput, userId: String): UserType!

  """Invite a user to a particular customer domain, given an email and role"""
  inviteUser(input: InviteUserInput): InviteUserOutput!

  """Logs a user out by removing their refresh token"""
  logout: String!
  register(input: RegisterInput): String
  requestInvite(input: RequestInviteInput): RequestInviteOutput!
  singleUpload(file: Upload): ImageType!
  updateCTA(id: String, links: CTALinksInputType, title: String, type: String): QuestionNode!
  updateQuestion(edgeCondition: EdgeConditionInputType, edgeId: String, id: String, optionEntries: OptionsInputType, overrideLeafId: String, title: String, type: String): QuestionNode!
  updateRoles(permissions: PermissionIdsInput, roleId: String): RoleType!

  """
  Given a token, checks in the database whether token has been set and has not expired yet
  """
  verifyUserToken(token: String): VerifyUserTokenOutput!
}

type NodeEntry {
  creationDate: String!
  depth: Int
  id: ID
  relatedEdgeId: String
  relatedNode: QuestionNode
  relatedNodeId: String

  """The core scoring value associated with the node entry."""
  value: NodeEntryValue
}

"""Data type for the actual node entry"""
input NodeEntryDataInput {
  choice: ChoiceNodeEntryInput
  register: RegisterNodeEntryInput
  slider: SliderNodeEntryInput
  textbox: TextboxNodeEntryInput
}

"""Input type for node-entry metadata"""
input NodeEntryInput {
  data: NodeEntryDataInput
  depth: Int
  edgeId: String
  nodeId: String
}

type NodeEntryValue {
  choiceNodeEntry: String
  linkNodeEntry: String
  registrationNodeEntry: String
  sliderNodeEntry: Int
  textboxNodeEntry: String
}

input OptionInputType {
  id: Int
  publicValue: String
  value: String
}

input OptionsInputType {
  options: [OptionInputType!]
}

"""Information with regards to current page, and total number of pages"""
type PaginationPageInfo {
  nrPages: Int!
  pageIndex: Int!
}

"""Ways to sort a pagination object"""
enum PaginationSortByEnum {
  createdAt
  email
  firstName
  id
  lastName
  medium
  name
  paths
  role
  score
  type
  user
  when
}

"""Sorting of pagination (type and whether it ascends)"""
input PaginationSortInput {
  by: PaginationSortByEnum!
  desc: Boolean = true
}

input PaginationWhereInput {
  endDate: String
  limit: Int
  offset: Int
  orderBy: [PaginationSortInput!]
  pageIndex: Int
  search: String
  searchTerm: String
  startDate: String
}

input PermissionIdsInput {
  ids: [String!]
}

input PermissionInput {
  customerId: String
  description: String
  name: String
}

type PermssionType {
  customer: Customer
  description: String
  id: ID!
  name: String!
}

type Query {
  customer(id: ID, slug: String): Customer
  customers: [Customer!]!
  dialogue(where: DialogueWhereUniqueInput): Dialogue
  dialogues(filter: DialogueFilterInputType): [Dialogue!]!
  edge(id: String): Edge
  lineChartData(dialogueId: String, limit: Int, numberOfDaysBack: Int, offset: Int): [lineChartDataType!]!
  me: UserType!
  questionNode(where: QuestionNodeWhereUniqueInput): QuestionNode
  questionNodes: [QuestionNode!]!
  refreshAccessToken: RefreshAccessTokenOutput!
  roleConnection(customerId: String, filter: PaginationWhereInput): RoleConnection!
  roles(customerSlug: String): [RoleType!]
  session(where: SessionWhereUniqueInput): Session
  sessions(where: SessionWhereUniqueInput): [Session!]!
  tags(customerSlug: String, dialogueId: String): [Tag!]!
  trigger(triggerId: String): TriggerType
  triggerConnection(customerSlug: String, filter: PaginationWhereInput): TriggerConnectionType
  triggers(customerSlug: String, dialogueId: String, filter: PaginationWhereInput, userId: String): [TriggerType!]!
  user(userId: String): UserType
  UserOfCustomer(input: UserOfCustomerInput): UserCustomer
  users(customerSlug: String): [UserType!]!
}

type QuestionNode {
  children: [Edge!]!
  creationDate: String
  id: ID!
  isLeaf: Boolean!
  isRoot: Boolean!
  links: [LinkType!]!
  options: [QuestionOption!]!
  overrideLeaf: QuestionNode
  overrideLeafId: String
  questionDialogue: Dialogue
  questionDialogueId: String
  title: String!
  type: QuestionNodeTypeEnum!
  updatedAt: String
}

"""The different types a node can assume"""
enum QuestionNodeTypeEnum {
  CHOICE
  GENERIC
  LINK
  REGISTRATION
  SLIDER
  TEXTBOX
}

input QuestionNodeWhereInputType {
  id: ID
  isRoot: Boolean
}

input QuestionNodeWhereUniqueInput {
  id: String!
}

type QuestionOption {
  id: Int!
  publicValue: String
  questionId: String
  value: String!
}

input RecipientsInputType {
  ids: [String!]
}

type RefreshAccessTokenOutput {
  accessToken: String!
}

"""Registration credentials"""
input RegisterInput {
  customerId: String!
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  roleId: String
}

"""Input type for a register node"""
input RegisterNodeEntryInput {
  value: String
}

input RequestInviteInput {
  email: String!
}

type RequestInviteOutput {
  didInvite: Boolean!
}

type RoleConnection implements ConnectionInterface {
  endDate: String
  limit: Int!
  offset: Int!
  pageInfo: PaginationPageInfo!
  roles: [RoleType!]!
  startDate: String
}

input RoleDataInput {
  description: String
  name: String
}

input RoleInput {
  customerId: String
  description: String
  name: String
  permissions: [SystemPermission!]
}

type RoleType {
  customerId: String
  id: ID!
  name: String!
  nrPermissions: Int
  permissions: [SystemPermission!]
  roleId: String
}

type Session {
  createdAt: String!
  dialogueId: String!
  id: ID!
  nodeEntries: [NodeEntry!]!
  paths: Int!
  score: Float!
}

type SessionConnection implements ConnectionInterface {
  endDate: String
  limit: Int!
  offset: Int!
  pageInfo: PaginationPageInfo!
  sessions: [Session!]!
  startDate: String
}

"""Input for session"""
input SessionInput {
  dialogueId: String!
  entries: [NodeEntryInput!]
}

input SessionWhereUniqueInput {
  dialogueId: ID
  id: ID
}

"""Input type for a slider node"""
input SliderNodeEntryInput {
  value: Int
}

enum SystemPermission {
  CAN_ACCESS_ADMIN_PANEL
  CAN_ADD_USERS
  CAN_BUILD_DIALOGUE
  CAN_CREATE_TRIGGERS
  CAN_DELETE_DIALOGUE
  CAN_DELETE_TRIGGERS
  CAN_DELETE_USERS
  CAN_DELETE_WORKSPACE
  CAN_EDIT_DIALOGUE
  CAN_EDIT_USERS
  CAN_EDIT_WORKSPACE
  CAN_VIEW_DIALOGUE
  CAN_VIEW_DIALOGUE_ANALYTICS
  CAN_VIEW_USERS
}

type Tag {
  customerId: String!
  id: ID!
  name: String!
  type: TagTypeEnum!
}

input TagsInputObjectType {
  entries: [String!]
}

enum TagTypeEnum {
  AGENT
  DEFAULT
  LOCATION
}

"""Input type for a textbox node"""
input TextboxNodeEntryInput {
  value: String
}

type topPathType {
  answer: String
  basicSentiment: String
  quantity: Int
}

enum TriggerConditionEnum {
  HIGH_THRESHOLD
  INNER_RANGE
  LOW_THRESHOLD
  OUTER_RANGE
  TEXT_MATCH
}

input TriggerConditionInputType {
  id: Int
  maxValue: Int
  minValue: Int
  textValue: String
  type: TriggerConditionEnum
}

type TriggerConditionType {
  id: Int!
  maxValue: Int
  minValue: Int
  textValue: String
  triggerId: String!
  type: TriggerConditionEnum!
}

type TriggerConnectionType implements ConnectionInterface {
  endDate: String
  limit: Int!
  offset: Int!
  pageInfo: PaginationPageInfo!
  startDate: String
  triggers: [TriggerType!]!
}

input TriggerInputType {
  conditions: [TriggerConditionInputType!]
  medium: TriggerMediumEnum
  name: String
  type: TriggerTypeEnum
}

enum TriggerMediumEnum {
  BOTH
  EMAIL
  PHONE
}

type TriggerType {
  conditions: [TriggerConditionType!]!
  id: String!
  medium: TriggerMediumEnum!
  name: String!
  recipients: [UserType!]!
  relatedNode: QuestionNode
  relatedNodeId: String
  type: TriggerTypeEnum!
}

enum TriggerTypeEnum {
  QUESTION
  SCHEDULED
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type UserConnection {
  pageIndex: Int
  totalPages: Int
  userCustomers: [UserCustomer!]!
}

type UserCustomer {
  customer: Customer!
  role: RoleType!
  user: UserType!
}

input UserInput {
  customerId: String
  email: String!
  firstName: String
  lastName: String
  password: String
  phone: String
  roleId: String
}

input UserOfCustomerInput {
  customerId: String
  customerSlug: String
  userId: String
}

type UserType {
  customers: [Customer!]!
  email: String!
  firstName: String
  globalPermissions: [SystemPermission!]
  id: ID!
  lastName: String
  phone: String
  role: RoleType
  roleId: String
  userCustomers: [UserCustomer!]!
}

type VerifyUserTokenOutput {
  accessToken: String!
  accessTokenExpiry: Int!
  userData: UserType!
}
