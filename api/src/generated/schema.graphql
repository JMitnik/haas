### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


input AdjustedImageInput {
  bucket: String
  id: String
  key: String
  reset: Boolean
}

"""Append new data to an uploaded session"""
input AppendToInteractionInput {
  data: NodeEntryDataInput
  edgeId: String
  nodeId: String
  sessionId: ID
}

type AutodeckConnectionType implements ConnectionInterface {
  endDate: String
  jobs: [CreateWorkspaceJobType!]!
  limit: Int!
  offset: Int!
  pageInfo: PaginationPageInfo!
  startDate: String
}

type AWSImageType {
  encoding: String
  filename: String
  mimetype: String
  url: String
}

"""Campaign"""
type CampaignType {
  deliveryConnection(filter: DeliveryConnectionFilter): DeliveryConnectionType
  id: ID!
  label: String!
  variants: [CampaignVariantType!]
}

type CampaignVariantCustomVariableType {
  id: ID!
  key: String!
}

enum CampaignVariantEnum {
  EMAIL
  QUEUE
  SMS
}

"""Variant of campaign"""
type CampaignVariantType {
  body: String!
  campaign: CampaignType
  customVariables: [CampaignVariantCustomVariableType!]
  deliveryConnection: DeliveryConnectionType
  dialogue: Dialogue
  from: String
  id: ID!
  label: String!
  type: CampaignVariantEnum!
  weight: Int!
  workspace: Customer
}

"""Input type for a choice node"""
input ChoiceNodeEntryInput {
  value: String
}

enum CloudReferenceType {
  AWS
  Azure
  GCP
  IBM
}

type ColourSettings {
  id: ID!
  primary: String!
  primaryAlt: String
  secondary: String
}

"""Interface all pagination-based models should implement"""
interface ConnectionInterface {
  endDate: String
  limit: Int!
  offset: Int!
  pageInfo: PaginationPageInfo!
  startDate: String
}

input CreateBatchDeliveriesInputType {
  batchScheduledAt: String
  campaignId: ID
  uploadedCsv: Upload
  workspaceId: String
}

type CreateBatchDeliveriesOutputType {
  failedDeliveries: [FailedDeliveryModel!]!
  nrDeliveries: Int!
}

input CreateCampaignCustomVariable {
  key: String
}

input CreateCampaignInputType {
  label: String
  variants: [CreateCampaignVariantInputType!]
  workspaceId: ID!
}

input CreateCampaignVariantInputType {
  body: String
  customVariables: [CreateCampaignCustomVariable!]
  dialogueId: ID!
  from: String
  label: String
  subject: String
  type: CampaignVariantEnum!
  weight: Float
  workspaceId: ID!
}

input CreateCTAInputType {
  customerSlug: String
  dialogueSlug: String
  form: FormNodeInputType
  links: CTALinksInputType
  share: ShareNodeInputType
  title: String
  type: String
}

input CreateDialogueInputType {
  contentType: String
  customerSlug: String
  description: String
  dialogueSlug: String
  isSeed: Boolean
  language: LanguageEnumType
  publicTitle: String
  tags: TagsInputObjectType
  templateDialogueId: String
  title: String
}

input createJobProcessLocationInput {
  name: String
  path: String
  type: JobProcessLocationType
}

input CreateQuestionNodeInputType {
  customerId: ID
  dialogueSlug: String
  edgeCondition: EdgeConditionInputType
  extraContent: String
  happyText: String
  optionEntries: OptionsInputType
  overrideLeafId: ID
  parentQuestionId: ID
  title: String
  type: String
  unhappyText: String
}

input CreateTriggerInputType {
  customerSlug: String
  recipients: RecipientsInputType
  trigger: TriggerInputType
}

"""Creates a workspace"""
input CreateWorkspaceInput {
  isSeed: Boolean = false
  logo: String
  logoOpacity: Int
  name: String!
  primaryColour: String!
  slug: String!
  willGenerateFakeData: Boolean = false
}

type CreateWorkspaceJobType {
  createdAt: String!
  errorMessage: String
  id: String!
  message: String
  name: String!
  processLocation: JobProcessLocation!
  referenceId: String
  referenceType: CloudReferenceType!
  requiresColorExtraction: Boolean!
  requiresRembg: Boolean!
  requiresScreenshot: Boolean!
  resourcesUrl: String
  status: JobStatusType!
  updatedAt: String
}

input CTALinkInputObjectType {
  backgroundColor: String
  iconUrl: String
  id: String
  title: String
  type: LinkTypeEnumType
  url: String
}

input CTALinksInputType {
  linkTypes: [CTALinkInputObjectType!]
}

input CTAShareInputObjectType {
  id: String
  title: String
  tooltip: String
  url: String
}

type Customer {
  campaign(campaignId: String): CampaignType
  campaigns: [CampaignType!]!
  dialogue(where: DialogueWhereUniqueInput): Dialogue
  dialogues(filter: DialogueFilterInputType): [Dialogue!]
  id: ID!
  name: String!
  roles: [RoleType!]
  settings: CustomerSettings
  slug: String!
  userCustomer(userId: String): UserCustomer
  users: [UserType!]
  usersConnection(customerSlug: String, filter: PaginationWhereInput): UserConnection
}

type CustomerSettings {
  colourSettings: ColourSettings
  fontSettings: FontSettings
  id: ID!
  logoOpacity: Int
  logoUrl: String
}

input CustomerWhereUniqueInput {
  id: ID!
}

input CustomFieldInputType {
  key: String
  value: String
}

type CustomFieldType {
  id: String!
  jobProcessLocationId: String!
  key: String!
  value: String
}

"""Date custom scalar type"""
scalar Date

input DeleteDialogueInputType {
  customerSlug: String
  id: ID
}

"""Delete Node Input type"""
input DeleteNodeInputType {
  customerId: ID
  dialogueSlug: String
  id: String
}

input DeleteUserInput {
  customerId: ID
  userId: ID
}

type DeleteUserOutput {
  deletedUser: Boolean!
}

input DeliveryConnectionFilter {
  campaignId: String
  campaignVariantId: ID
  paginationFilter: PaginationWhereInput
  status: DeliveryStatusEnum
}

type DeliveryConnectionType implements ConnectionInterface {
  deliveries: [DeliveryType!]!
  endDate: String
  limit: Int!
  nrFinished: Int!
  nrOpened: Int!
  nrSent: Int!
  nrTotal: Int!
  offset: Int!
  pageInfo: PaginationPageInfo!
  startDate: String
}

type DeliveryEventType {
  createdAt: String!
  failureMessage: String
  id: ID!
  status: DeliveryStatusEnum!
}

enum DeliveryStatusEnum {
  DELIVERED
  DEPLOYED
  FAILED
  FINISHED
  OPENED
  SCHEDULED
  SENT
}

"""Delivery"""
type DeliveryType {
  campaignVariant: CampaignVariantType
  currentStatus: DeliveryStatusEnum!
  deliveryRecipientEmail: String
  deliveryRecipientFirstName: String
  deliveryRecipientLastName: String
  deliveryRecipientPhone: String
  events: [DeliveryEventType!]!
  id: ID!
  scheduledAt: String
  updatedAt: String
}

type Dialogue {
  averageScore(input: DialogueFilterInputType): Float!
  creationDate: String
  customer: Customer
  customerId: String!
  description: String!
  edges: [Edge!]!
  id: ID!
  isWithoutGenData: Boolean!
  language: LanguageEnumType!
  leafs(searchTerm: String): [QuestionNode!]!
  postLeafNode: DialogueFinisherObjectType
  publicTitle: String
  questions: [QuestionNode!]!
  rootQuestion: QuestionNode!
  sessionConnection(filter: PaginationWhereInput): SessionConnection
  sessions(take: Int): [Session!]!
  slug: String!
  statistics(input: DialogueFilterInputType): DialogueStatistics
  tags: [Tag!]
  title: String!
  updatedAt: String
  wasGeneratedWithGenData: Boolean!
}

input DialogueFilterInputType {
  endDate: String
  searchTerm: String
  startDate: String
}

type DialogueFinisherObjectType {
  header: String!
  id: ID!
  subtext: String!
}

type DialogueStatistics {
  history: [lineChartDataType!]
  mostPopularPath: topPathType
  nrInteractions: Int!
  topNegativePath: [topPathType!]
  topPositivePath: [topPathType!]
}

input DialogueWhereUniqueInput {
  id: ID
  slug: String
}

type Edge {
  childNode: QuestionNode
  childNodeId: String!
  conditions: [EdgeCondition!]
  createdAt: String!
  id: ID!
  parentNode: QuestionNode
  parentNodeId: String!
  updatedAt: String!
}

type EdgeCondition {
  conditionType: String!
  edgeId: String
  id: Int!
  matchValue: String
  renderMax: Int
  renderMin: Int
}

input EdgeConditionInputType {
  conditionType: String
  id: Int
  matchValue: String
  renderMax: Int
  renderMin: Int
}

input EditUserInput {
  customerId: String
  email: String!
  firstName: String
  lastName: String
  phone: String
  roleId: String
}

"""Edit a workspace"""
input EditWorkspaceInput {
  customerSlug: String!
  id: ID!
  logo: String
  logoOpacity: Int
  name: String!
  primaryColour: String!
  slug: String!
}

type FailedDeliveryModel {
  error: String!
  record: String!
}

type FontSettings {
  id: ID!
}

"""FormNodeEntryInput"""
input FormNodeEntryFieldInput {
  email: String
  longText: String
  number: Int
  phoneNumber: String
  relatedFieldId: ID
  shortText: String
  url: String
}

"""FormNodeEntryInput"""
input FormNodeEntryInput {
  values: [FormNodeEntryFieldInput!]
}

type FormNodeEntryType {
  id: Int!
  values: [FormNodeEntryValueType!]!
}

type FormNodeEntryValueType {
  email: String
  longText: String
  number: Int
  phoneNumber: String
  relatedField: FormNodeField!
  shortText: String
  url: String
}

type FormNodeField {
  id: ID!
  isRequired: Boolean!
  label: String!
  placeholder: String
  position: Int!
  type: FormNodeFieldTypeEnum!
}

input FormNodeFieldInput {
  id: ID
  isRequired: Boolean = false
  label: String
  placeholder: String
  position: Int
  type: FormNodeFieldTypeEnum
}

"""The types a field can assume"""
enum FormNodeFieldTypeEnum {
  email
  longText
  number
  phoneNumber
  shortText
  url
}

input FormNodeInputType {
  fields: [FormNodeFieldInput!]
  helperText: String
  id: String
}

type FormNodeType {
  fields: [FormNodeField!]!
  helperText: String
  id: String
}

"""Generate savales documents"""
input GenerateAutodeckInput {
  answer1: String
  answer2: String
  answer3: String
  answer4: String
  companyName: String
  customFields: [CustomFieldInputType!]
  emailContent: String
  firstName: String
  id: String!
  isGenerateWorkspace: Boolean
  jobLocationId: String
  logo: String
  name: String
  newCustomFields: [CustomFieldInputType!]
  primaryColour: String
  requiresColorExtraction: Boolean!
  requiresRembgLambda: Boolean!
  requiresWebsiteScreenshot: Boolean!
  reward: String
  slug: String
  sorryAboutX: String
  standardFields: [CustomFieldInputType!]
  textMessage: String
  usesAdjustedLogo: Boolean!
  website: String
  youLoveX: String
}

input GetCampaignsInput {
  customerSlug: String
}

type ImageType {
  encoding: String
  filename: String
  mimetype: String
  url: String
}

input InviteUserInput {
  customerId: String!
  email: String!
  roleId: String!
}

type InviteUserOutput {
  didAlreadyExist: Boolean!
  didInvite: Boolean!
}

type JobObjectType {
  createdAt: String!
  createWorkspaceJob: CreateWorkspaceJobType
  createWorkspaceJobId: String!
  id: String!
  updatedAt: String!
}

type JobProcessLocation {
  customFields: [CustomFieldType!]
  id: String!
  name: String!
  path: String!
  type: JobProcessLocationType!
  xMaterialDimension: Int!
  yMaterialDimension: Int!
}

type JobProcessLocations {
  jobProcessLocations: [JobProcessLocation!]!
}

enum JobProcessLocationType {
  BROCHURE
  ONE_PAGER
  PITCHDECK
}

enum JobStatusType {
  COMPLETED
  COMPRESSING_SALES_MATERIAL
  FAILED
  IN_PHOTOSHOP_QUEUE
  PENDING
  PHOTOSHOP_PROCESSING
  PRE_PROCESSING
  PRE_PROCESSING_LOGO
  PRE_PROCESSING_WEBSITE_SCREENSHOT
  PROCESSING
  READY_FOR_PROCESSING
  STITCHING_SLIDES
  TRANSFORMING_PSDS_TO_PNGS
  WRAPPING_UP
}

enum LanguageEnumType {
  DUTCH
  ENGLISH
  GERMAN
}

type lineChartDataType {
  entryId: String
  x: String
  y: Int
}

type LinkType {
  backgroundColor: String
  iconUrl: String
  id: String!
  questionNode: QuestionNode!
  questionNodeId: String
  title: String
  type: String!
  url: String!
}

enum LinkTypeEnumType {
  API
  FACEBOOK
  INSTAGRAM
  LINKEDIN
  SOCIAL
  TWITTER
  WHATSAPP
}

"""Login credential"""
input LoginInput {
  email: String!
}

"""Information you get after you log out"""
type LoginOutput {
  expiryDate: Int!
  token: String!
  user: UserType!
}

type Mutation {
  appendToInteraction(input: AppendToInteractionInput): Session!
  assignTags(dialogueId: String, tags: TagsInputObjectType): Dialogue!
  confirmCreateWorkspaceJob(input: GenerateAutodeckInput): CreateWorkspaceJobType
  copyDialogue(input: CreateDialogueInputType): Dialogue!
  createBatchDeliveries(input: CreateBatchDeliveriesInputType): CreateBatchDeliveriesOutputType!
  createCampaign(input: CreateCampaignInputType): CampaignType!

  """Create Call to Actions"""
  createCTA(input: CreateCTAInputType): QuestionNode!
  createDialogue(input: CreateDialogueInputType): Dialogue!
  createJobProcessLocation(input: createJobProcessLocationInput): JobProcessLocation!
  createPermission(data: PermissionInput): PermssionType
  createQuestion(input: CreateQuestionNodeInputType): QuestionNode
  createRole(data: RoleInput): RoleType!
  createSession(input: SessionInput): Session!
  createTag(customerSlug: String, name: String, type: TagTypeEnum): Tag!
  createTrigger(input: CreateTriggerInputType): TriggerType!
  createWorkspace(input: CreateWorkspaceInput): Customer!
  deleteCTA(input: DeleteNodeInputType): QuestionNode!
  deleteCustomer(where: CustomerWhereUniqueInput): Customer
  deleteDialogue(input: DeleteDialogueInputType): Dialogue!
  deleteQuestion(input: DeleteNodeInputType): QuestionNode!
  deleteTag(tagId: String): Tag!
  deleteTrigger(customerSlug: String, id: String): TriggerType
  deleteUser(input: DeleteUserInput): DeleteUserOutput!
  duplicateQuestion(questionId: String): QuestionNode
  editDialogue(customerSlug: String, description: String, dialogueFinisherHeading: String, dialogueFinisherSubheading: String, dialogueSlug: String, isWithoutGenData: Boolean, language: LanguageEnumType, publicTitle: String, tags: TagsInputObjectType, title: String): Dialogue!
  editTrigger(customerSlug: String, recipients: RecipientsInputType, trigger: TriggerInputType, triggerId: String): TriggerType!
  editUser(input: EditUserInput, userId: String): UserType!
  editWorkspace(input: EditWorkspaceInput): Customer!
  generateAutodeck(input: GenerateAutodeckInput): CreateWorkspaceJobType

  """Invite a user to a particular customer domain, given an email and role"""
  inviteUser(input: InviteUserInput): InviteUserOutput!

  """Logs a user out by removing their refresh token"""
  logout: String!
  register(input: RegisterInput): String
  removePixelRange(input: RemovePixelRangeInput): AWSImageType
  requestInvite(input: RequestInviteInput): RequestInviteOutput!
  retryAutodeckJob(jobId: String): CreateWorkspaceJobType
  singleUpload(file: Upload): ImageType!
  updateCreateWorkspaceJob(errorMessage: String, id: String, referenceId: String, resourceUrl: String, status: JobStatusType): CreateWorkspaceJobType
  updateCTA(input: UpdateCTAInputType): QuestionNode!
  updateDeliveryStatus(deliveryId: String, status: DeliveryStatusEnum): String!
  updateQuestion(input: UpdateQuestionNodeInputType): QuestionNode!
  updateRoles(permissions: PermissionIdsInput, roleId: String): RoleType!
  uploadJobImage(disapproved: Boolean, file: Upload, jobId: String, type: UploadImageEnumType): AWSImageType

  """
  Given a token, checks in the database whether token has been set and has not expired yet
  """
  verifyUserToken(token: String): VerifyUserTokenOutput!
  whitifyImage(input: AdjustedImageInput): AWSImageType
}

type NodeEntry {
  creationDate: String!
  depth: Int
  id: ID
  relatedEdgeId: String
  relatedNode: QuestionNode
  relatedNodeId: String

  """The core scoring value associated with the node entry."""
  value: NodeEntryValue
}

"""Data type for the actual node entry"""
input NodeEntryDataInput {
  choice: ChoiceNodeEntryInput
  form: FormNodeEntryInput
  register: RegisterNodeEntryInput
  slider: SliderNodeEntryInput
  textbox: TextboxNodeEntryInput
  video: VideoNodeEntryInput
}

"""Input type for node-entry metadata"""
input NodeEntryInput {
  data: NodeEntryDataInput
  depth: Int
  edgeId: String
  nodeId: String
}

type NodeEntryValue {
  choiceNodeEntry: String
  formNodeEntry: FormNodeEntryType
  linkNodeEntry: String
  registrationNodeEntry: String
  sliderNodeEntry: Int
  textboxNodeEntry: String
  videoNodeEntry: String
}

input OptionInputType {
  id: Int
  overrideLeafId: String
  position: Int!
  publicValue: String
  value: String
}

input OptionsInputType {
  options: [OptionInputType!]
}

"""Information with regards to current page, and total number of pages"""
type PaginationPageInfo {
  nrPages: Int!
  pageIndex: Int!
}

"""Fields that can be used for free text search on tables"""
enum PaginationSearchEnum {
  email
  firstName
  lastName
  name
  publicTitle
  title
}

"""Ways to sort a pagination object"""
enum PaginationSortByEnum {
  createdAt
  email
  firstName
  id
  lastName
  medium
  name
  paths
  role
  scheduledAt
  score
  type
  updatedAt
  user
  when
}

"""Sorting of pagination (type and whether it ascends)"""
input PaginationSortInput {
  by: PaginationSortByEnum!
  desc: Boolean = true
}

input PaginationWhereInput {
  endDate: String
  limit: Int
  offset: Int
  orderBy: [PaginationSortInput!]
  pageIndex: Int
  search: String
  searchTerm: String
  startDate: String
}

input PermissionIdsInput {
  ids: [String!]
}

input PermissionInput {
  customerId: String
  description: String
  name: String
}

type PermssionType {
  customer: Customer
  description: String
  id: ID!
  name: String!
}

type PreviewDataType {
  colors: [String!]!
  rembgLogoUrl: String!
  websiteScreenshotUrl: String!
}

type Query {
  customer(id: ID, slug: String): Customer
  customers: [Customer!]!
  delivery(deliveryId: String): DeliveryType
  dialogue(where: DialogueWhereUniqueInput): Dialogue
  dialogues(filter: DialogueFilterInputType): [Dialogue!]!
  edge(id: String): Edge
  getAdjustedLogo(input: AdjustedImageInput): AWSImageType
  getAutodeckJobs(filter: PaginationWhereInput): AutodeckConnectionType!
  getJob(id: String): CreateWorkspaceJobType
  getJobProcessLocations: JobProcessLocations!
  getPreviewData(id: String): PreviewDataType
  me: UserType!
  refreshAccessToken: RefreshAccessTokenOutput!
  roleConnection(customerId: String, filter: PaginationWhereInput): RoleConnection!
  session(where: SessionWhereUniqueInput): Session
  sessions(where: SessionWhereUniqueInput): [Session!]!
  tags(customerSlug: String, dialogueId: String): [Tag!]!
  trigger(triggerId: String): TriggerType
  triggerConnection(customerSlug: String, filter: PaginationWhereInput): TriggerConnectionType
  triggers(customerSlug: String, dialogueId: String, filter: PaginationWhereInput, userId: String): [TriggerType!]!
  user(userId: String): UserType
  UserOfCustomer(input: UserOfCustomerInput): UserCustomer
  users(customerSlug: String): [UserType!]!
}

type QuestionNode {
  children: [Edge!]!
  creationDate: String
  extraContent: String

  """FormNode resolver"""
  form: FormNodeType
  id: ID!
  isLeaf: Boolean!
  isRoot: Boolean!
  links: [LinkType!]!
  options: [QuestionOption!]!
  overrideLeaf: QuestionNode
  overrideLeafId: String
  questionDialogue: Dialogue
  questionDialogueId: String
  share: ShareNodeType

  """Slidernode resolver"""
  sliderNode: SliderNodeType
  title: String!
  type: QuestionNodeTypeEnum!
  updatedAt: String
}

"""The different types a node can assume"""
enum QuestionNodeTypeEnum {
  CHOICE
  FORM
  GENERIC
  LINK
  REGISTRATION
  SHARE
  SLIDER
  TEXTBOX
  VIDEO_EMBEDDED
}

input QuestionNodeWhereInputType {
  id: ID
  isRoot: Boolean
}

input QuestionNodeWhereUniqueInput {
  id: String!
}

type QuestionOption {
  id: Int!
  overrideLeaf: QuestionNode
  position: Int
  publicValue: String
  questionId: String
  value: String!
}

input RecipientsInputType {
  ids: [String!]
}

type RefreshAccessTokenOutput {
  accessToken: String!
}

"""Registration credentials"""
input RegisterInput {
  customerId: String!
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  roleId: String
}

"""Input type for a register node"""
input RegisterNodeEntryInput {
  value: String
}

input RemovePixelRangeInput {
  blue: Int
  bucket: String
  green: Int
  key: String
  range: Int
  red: Int
}

input RequestInviteInput {
  email: String!
}

type RequestInviteOutput {
  didInvite: Boolean!
  userExists: Boolean!
}

type RoleConnection implements ConnectionInterface {
  endDate: String
  limit: Int!
  offset: Int!
  pageInfo: PaginationPageInfo!
  roles: [RoleType!]!
  startDate: String
}

input RoleDataInput {
  description: String
  name: String
}

input RoleInput {
  customerId: String
  description: String
  name: String
  permissions: [SystemPermission!]
}

type RoleType {
  customerId: String
  id: ID!
  name: String!
  nrPermissions: Int
  permissions: [SystemPermission!]
  roleId: String
}

type Session {
  browser: String!
  createdAt: Date!
  delivery: DeliveryType
  deliveryId: String
  device: String
  dialogueId: String!
  id: ID!
  nodeEntries: [NodeEntry!]!
  originUrl: String
  paths: Int!
  score: Float!
  totalTimeInSec: Int
}

type SessionConnection implements ConnectionInterface {
  endDate: String
  limit: Int!
  offset: Int!
  pageInfo: PaginationPageInfo!
  sessions: [Session!]!
  startDate: String
}

"""Input for session"""
input SessionInput {
  deliveryId: String
  device: String
  dialogueId: String!
  entries: [NodeEntryInput!]
  originUrl: String
  totalTimeInSec: Int
}

input SessionWhereUniqueInput {
  dialogueId: ID
  id: ID
}

input ShareNodeInputType {
  id: String
  title: String
  tooltip: String
  url: String
}

type ShareNodeType {
  createdAt: String
  id: String!
  title: String!
  tooltip: String
  updatedAt: String
  url: String!
}

input SlideNodeMarkerInput {
  id: ID
  label: String!
  range: SliderNodeRangeInputType
  subLabel: String!
}

"""Input type for a slider node"""
input SliderNodeEntryInput {
  value: Int
}

input SliderNodeInputType {
  id: ID
  markers: [SlideNodeMarkerInput!]
}

type SliderNodeMarkerType {
  id: ID!
  label: String!
  range: SliderNodeRangeType
  subLabel: String!
}

input SliderNodeRangeInputType {
  end: Float
  start: Float
}

type SliderNodeRangeType {
  end: Float
  id: ID!
  start: Float
}

type SliderNodeType {
  happyText: String
  id: ID
  markers: [SliderNodeMarkerType!]
  unhappyText: String
}

"""Details regarding interaction with social node"""
input SocialNodeEntryInput {
  visitedLink: String
}

enum SystemPermission {
  CAN_ACCESS_ADMIN_PANEL
  CAN_ADD_USERS
  CAN_BUILD_DIALOGUE
  CAN_CREATE_CAMPAIGNS
  CAN_CREATE_DELIVERIES
  CAN_CREATE_TRIGGERS
  CAN_DELETE_DIALOGUE
  CAN_DELETE_TRIGGERS
  CAN_DELETE_USERS
  CAN_DELETE_WORKSPACE
  CAN_EDIT_DIALOGUE
  CAN_EDIT_USERS
  CAN_EDIT_WORKSPACE
  CAN_VIEW_CAMPAIGNS
  CAN_VIEW_DIALOGUE
  CAN_VIEW_DIALOGUE_ANALYTICS
  CAN_VIEW_USERS
}

type Tag {
  customerId: String!
  id: ID!
  name: String!
  type: TagTypeEnum!
}

input TagsInputObjectType {
  entries: [String!]
}

enum TagTypeEnum {
  AGENT
  DEFAULT
  LOCATION
}

"""Input type for a textbox node"""
input TextboxNodeEntryInput {
  value: String
}

type topPathType {
  answer: String
  basicSentiment: String
  quantity: Int
}

enum TriggerConditionEnum {
  HIGH_THRESHOLD
  INNER_RANGE
  LOW_THRESHOLD
  OUTER_RANGE
  TEXT_MATCH
}

input TriggerConditionInputType {
  id: Int
  maxValue: Int
  minValue: Int
  questionId: String
  textValue: String
  type: TriggerConditionEnum
}

type TriggerConditionType {
  id: Int!
  maxValue: Int
  minValue: Int
  question: QuestionNode
  textValue: String
  triggerId: String!
  type: TriggerConditionEnum!
}

type TriggerConnectionType implements ConnectionInterface {
  endDate: String
  limit: Int!
  offset: Int!
  pageInfo: PaginationPageInfo!
  startDate: String
  triggers: [TriggerType!]!
}

input TriggerInputType {
  conditions: [TriggerConditionInputType!]
  medium: TriggerMediumEnum
  name: String
  type: TriggerTypeEnum
}

enum TriggerMediumEnum {
  BOTH
  EMAIL
  PHONE
}

type TriggerType {
  conditions: [TriggerConditionType!]!
  id: String!
  medium: TriggerMediumEnum!
  name: String!
  recipients: [UserType!]!
  relatedDialogue: Dialogue
  relatedNodeId: String
  type: TriggerTypeEnum!
}

enum TriggerTypeEnum {
  QUESTION
  SCHEDULED
}

input UpdateCTAInputType {
  customerId: ID
  form: FormNodeInputType
  id: String
  links: CTALinksInputType
  share: ShareNodeInputType
  title: String
  type: QuestionNodeTypeEnum
}

input UpdateQuestionNodeInputType {
  customerId: ID
  edgeCondition: EdgeConditionInputType
  edgeId: ID
  extraContent: String
  happyText: String
  id: ID!
  optionEntries: OptionsInputType
  overrideLeafId: ID
  sliderNode: SliderNodeInputType
  title: String
  type: String
  unhappyText: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

enum UploadImageEnumType {
  LOGO
  WEBSITE_SCREENSHOT
}

type UserConnection implements ConnectionInterface {
  endDate: String
  limit: Int!
  offset: Int!
  pageInfo: PaginationPageInfo!
  startDate: String
  userCustomers: [UserCustomer!]!
}

type UserCustomer {
  customer: Customer!
  role: RoleType!
  user: UserType!
}

input UserInput {
  customerId: String
  email: String!
  firstName: String
  lastName: String
  password: String
  phone: String
  roleId: String
}

input UserOfCustomerInput {
  customerId: String
  customerSlug: String
  userId: String
}

type UserType {
  customers: [Customer!]!
  email: String!
  firstName: String
  globalPermissions: [SystemPermission!]
  id: ID!
  lastName: String
  phone: String
  role: RoleType
  roleId: String
  userCustomers: [UserCustomer!]!
}

type VerifyUserTokenOutput {
  accessToken: String!
  accessTokenExpiry: Int!
  userData: UserType!
}

"""Input type for a video node"""
input VideoNodeEntryInput {
  value: String
}
