### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


input AddDialogueInput {
  customerSlug: String
  description: String
  dialogueSlug: String
  isSeed: Boolean
  publicTitle: String
  tags: TagsInputObjectType
  title: String
}

"""Input type for a choice node"""
input ChoiceNodeEntryInput {
  value: String
}

type ColourSettings {
  id: ID!
  primary: String!
  primaryAlt: String
  secondary: String
}

"""Interface all pagination-based models should implement"""
interface ConnectionInterface {
  endDate: String
  limit: Int!
  offset: Int!
  pageInfo: PaginationPageInfo!
  startDate: String
}

type Customer {
  dialogue(where: DialogueWhereUniqueInput): Dialogue
  dialogues(filter: DialogueFilterInputType): [Dialogue!]
  id: ID!
  name: String!
  settings: CustomerSettings
  slug: String!
}

input CustomerCreateOptions {
  isSeed: Boolean = false
  logo: String
  primaryColour: String!
  slug: String!
}

input CustomerEditOptions {
  logo: String
  name: String!
  primaryColour: String!
  slug: String!
}

type CustomerSettings {
  colourSettings: ColourSettings
  fontSettings: FontSettings
  id: ID!
  logoUrl: String
}

input CustomerWhereUniqueInput {
  id: ID!
}

type Dialogue {
  averageScore: Float!
  countInteractions: Int
  creationDate: String
  customer: Customer
  customerId: String!
  description: String!
  edges: [Edge!]!
  id: ID!
  leafs: [QuestionNode!]!
  publicTitle: String
  questions(where: QuestionNodeWhereInput): [QuestionNode!]!
  rootQuestion: QuestionNode!
  sessionConnection(filter: PaginationWhereInput): SessionConnection
  sessions(take: Int): [Session!]!
  slug: String!
  statistics: DialogueStatistics
  tags: [Tag!]
  title: String!
  updatedAt: String
}

input DialogueFilterInputType {
  searchTerm: String
}

type DialogueStatistics {
  history: [lineChartDataType!]
  topNegativePath: [topPathType!]
  topPositivePath: [topPathType!]
}

input DialogueWhereUniqueInput {
  id: ID
  slug: String
}

type Edge {
  childNode: QuestionNode
  childNodeId: String!
  conditions: [EdgeCondition!]
  createdAt: String!
  id: ID!
  parentNode: QuestionNode
  parentNodeId: String!
  updatedAt: String!
}

input EdgeChildInput {
  childNode: EdgeNodeInput
  conditions: [QuestionConditionInput!]
  id: ID
  parentNode: EdgeNodeInput
}

type EdgeCondition {
  conditionType: String!
  edgeId: String
  id: Int!
  matchValue: String
  renderMax: Int
  renderMin: Int
}

input EdgeNodeInput {
  id: ID
  title: String
}

type FontSettings {
  id: ID!
}

type ImageType {
  encoding: String
  filename: String
  mimetype: String
  url: String
}

input LeafNodeInput {
  id: ID
  title: String
  type: String
}

type lineChartDataType {
  entryId: String
  x: String
  y: Int
}

type Mutation {
  assignTags(dialogueId: String, tags: TagsInputObjectType): Dialogue!
  createCustomer(name: String, options: CustomerCreateOptions): Customer!
  createDialogue(data: AddDialogueInput): Dialogue!
  createPermission(data: PermissionInput): PermssionType
  createRole(data: RoleInput): RoleType!
  createSession(data: SessionInput): Session!
  createTag(customerSlug: String, name: String, type: TagTypeEnum): Tag!
  createTrigger(customerSlug: String, questionId: String, recipients: RecipientsInputType, trigger: TriggerInputType): TriggerType!
  createUser(customerSlug: String, input: UserInput): UserType!
  deleteCustomer(where: CustomerWhereUniqueInput): Customer
  deleteDialogue(where: DialogueWhereUniqueInput): Dialogue!
  deleteTag(tagId: String): Tag!
  deleteTrigger(id: String): TriggerType
  deleteUser(id: String): UserType!
  editCustomer(id: String, options: CustomerEditOptions): Customer!
  editDialogue(description: String, dialogueId: String, publicTitle: String, tags: TagsInputObjectType, title: String): Dialogue!
  editTrigger(questionId: String, recipients: RecipientsInputType, trigger: TriggerInputType, triggerId: String): TriggerType!
  editUser(id: String, input: UserInput): UserType!
  singleUpload(file: Upload): ImageType!
  updateRoles(permissions: PermissionIdsInput, roleId: String): RoleType!
  updateTopicBuilder(customerSlug: String, dialogueSlug: String, topicData: TopicDataEntry): String!
}

type NodeEntry {
  creationDate: String!
  depth: Int
  id: ID
  relatedEdgeId: String
  relatedNode: QuestionNode
  relatedNodeId: String

  """The core scoring value associated with the node entry."""
  value: NodeEntryValue
}

"""Input type for node-entry metadata"""
input NodeEntryInput {
  choice: ChoiceNodeEntryInput
  depth: Int
  edgeId: String
  nodeId: String
  register: RegisterNodeEntryInput
  slider: SliderNodeEntryInput
  textbox: TextboxNodeEntryInput
}

type NodeEntryValue {
  choice: String
  id: ID!
  register: String
  slider: Int
  textbox: String
}

input OptionInput {
  id: Int
  publicValue: String
  value: String
}

"""Information with regards to current page, and total number of pages"""
type PaginationPageInfo {
  nrPages: Int!
  pageIndex: Int!
}

"""Ways to sort a pagination object"""
enum PaginationSortByEnum {
  createdAt
  email
  firstName
  id
  lastName
  medium
  name
  role
  score
  type
}

"""Sorting of pagination (type and whether it ascends)"""
input PaginationSortInput {
  by: PaginationSortByEnum!
  desc: Boolean = true
}

input PaginationWhereInput {
  endDate: String
  limit: Int
  offset: Int
  orderBy: [PaginationSortInput!]
  pageIndex: Int
  search: String
  searchTerm: String
  startDate: String
}

input PermissionIdsInput {
  ids: [String!]
}

input PermissionInput {
  customerId: String
  description: String
  name: String
}

type PermssionType {
  customer: Customer
  description: String
  id: ID!
  name: String!
}

type Query {
  customer(id: ID, slug: String): Customer
  customers: [Customer!]!
  dialogue(where: DialogueWhereUniqueInput): Dialogue
  dialogues(filter: DialogueFilterInputType): [Dialogue!]!
  edge(id: String): Edge
  lineChartData(dialogueId: String, limit: Int, numberOfDaysBack: Int, offset: Int): [lineChartDataType!]!
  questionNode(where: QuestionNodeWhereUniqueInput): QuestionNode
  questionNodes: [QuestionNode!]!
  roleConnection(customerId: String, filter: PaginationWhereInput): RoleConnection!
  roles(customerSlug: String): [RoleType!]
  session(where: SessionWhereUniqueInput): Session
  sessions(where: SessionWhereUniqueInput): [Session!]!
  tags(customerSlug: String, dialogueId: String): [Tag!]!
  trigger(triggerId: String): TriggerType
  triggerConnection(customerSlug: String, filter: PaginationWhereInput): TriggerConnectionType
  triggers(customerSlug: String, dialogueId: String, filter: PaginationWhereInput, userId: String): [TriggerType!]!
  user(userId: String): UserType
  users(customerSlug: String): [UserType!]!
  userTable(customerSlug: String, filter: PaginationWhereInput): UserTable
}

input QuestionConditionInput {
  conditionType: String
  id: Int
  matchValue: String
  renderMax: Int
  renderMin: Int
}

input QuestionInput {
  children: [EdgeChildInput!]
  id: ID
  isLeaf: Boolean
  isRoot: Boolean
  options: [OptionInput!]
  overrideLeaf: LeafNodeInput
  title: String
  type: String
}

type QuestionNode {
  children: [Edge!]!
  creationDate: String
  id: ID!
  isLeaf: Boolean!
  isRoot: Boolean!
  options: [QuestionOption!]!
  overrideLeaf: QuestionNode
  overrideLeafId: String
  questionDialogue: Dialogue
  questionDialogueId: String
  title: String!
  type: String!
}

input QuestionNodeWhereInput {
  id: ID
  isRoot: Boolean
}

input QuestionNodeWhereUniqueInput {
  id: String!
}

type QuestionOption {
  id: Int!
  publicValue: String
  questionId: String
  value: String!
}

input RecipientsInputType {
  ids: [String!]
}

"""Input type for a register node"""
input RegisterNodeEntryInput {
  value: String
}

type RoleConnection implements ConnectionInterface {
  endDate: String
  limit: Int!
  offset: Int!
  pageInfo: PaginationPageInfo!
  permissions: [PermssionType!]!
  roles: [RoleType!]!
  startDate: String
}

input RoleDataInput {
  description: String
  name: String
}

input RoleInput {
  customerId: String
  description: String
  name: String
}

type RoleType {
  customer: Customer
  customerId: String
  id: ID!
  name: String!
  nrPermissions: Int
  permissions: [PermssionType!]
  roleId: String
}

type Session {
  createdAt: String!
  dialogueId: String!
  id: ID!
  nodeEntries: [NodeEntry!]!
  paths: Int!
  score: Float!
}

type SessionConnection implements ConnectionInterface {
  endDate: String
  limit: Int!
  offset: Int!
  pageInfo: PaginationPageInfo!
  sessions: [Session!]!
  startDate: String
}

"""Input for session"""
input SessionInput {
  dialogueId: String!
  entries: [NodeEntryInput!]
}

input SessionWhereUniqueInput {
  dialogueId: ID
  id: ID
}

"""Input type for a slider node"""
input SliderNodeEntryInput {
  value: Int
}

type Tag {
  customerId: String!
  id: ID!
  name: String!
  type: TagTypeEnum!
}

input TagsInputObjectType {
  entries: [String!]
}

enum TagTypeEnum {
  AGENT
  DEFAULT
  LOCATION
}

"""Input type for a textbox node"""
input TextboxNodeEntryInput {
  value: String
}

input TopicDataEntry {
  id: ID
  questions: [QuestionInput!]
}

type topPathType {
  answer: String
  quantity: Int
}

enum TriggerConditionEnum {
  HIGH_THRESHOLD
  INNER_RANGE
  LOW_THRESHOLD
  OUTER_RANGE
  TEXT_MATCH
}

input TriggerConditionInputType {
  id: Int
  maxValue: Int
  minValue: Int
  textValue: String
  type: TriggerConditionEnum
}

type TriggerConditionType {
  id: Int!
  maxValue: Int
  minValue: Int
  textValue: String
  type: TriggerConditionEnum!
}

type TriggerConnectionType implements ConnectionInterface {
  endDate: String
  limit: Int!
  offset: Int!
  pageInfo: PaginationPageInfo!
  startDate: String
  triggers: [TriggerType!]!
}

input TriggerInputType {
  conditions: [TriggerConditionInputType!]
  medium: TriggerMediumEnum
  name: String
  type: TriggerTypeEnum
}

enum TriggerMediumEnum {
  BOTH
  EMAIL
  PHONE
}

type TriggerType {
  conditions: [TriggerConditionType!]!
  id: String!
  medium: TriggerMediumEnum!
  name: String!
  recipients: [UserType!]!
  relatedNode: QuestionNode
  relatedNodeId: String
  type: TriggerTypeEnum!
}

enum TriggerTypeEnum {
  QUESTION
  SCHEDULED
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

input UserInput {
  customerId: String
  email: String
  firstName: String
  lastName: String
  password: String
  phone: String
  roleId: String
}

type UserTable {
  pageIndex: Int
  totalPages: Int
  users: [UserType!]!
}

type UserType {
  email: String!
  firstName: String
  id: ID!
  lastName: String
  phone: String
  role: RoleType
  roleId: String
}
