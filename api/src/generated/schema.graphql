### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AWSImageType {
  encoding: String
  filename: String
  mimetype: String
  url: String
}

type ActionRequest {
  assignee: UserType
  assigneeId: String
  createdAt: Date
  dialogue: Dialogue
  dialogueId: String
  id: ID
  isVerified: Boolean!
  issue: IssueModel
  issueId: String
  requestEmail: String
  session: Session
  status: ActionRequestState!
  updatedAt: Date
}

type ActionRequestConnection implements ConnectionInterface {
  actionRequests: [ActionRequest]
  pageInfo: PaginationPageInfo
  totalPages: Int
}

input ActionRequestConnectionFilterInput {
  assigneeId: String
  dialogueId: String
  endDate: DateString
  isVerified: Boolean
  offset: Int!
  orderBy: ActionRequestConnectionOrderByInput
  perPage: Int! = 10
  requestEmail: String
  search: String
  startDate: DateString
  status: ActionRequestState
  topic: String
}

"""Sorting of ActionableConnection"""
input ActionRequestConnectionOrderByInput {
  by: ActionRequestConnectionOrderType!
  desc: Boolean = true
}

"""Fields to order ActionableConnection by."""
enum ActionRequestConnectionOrderType {
  createdAt
}

input ActionRequestFilterInput {
  assigneeId: String
  endDate: DateString
  startDate: DateString
  status: ActionRequestState
  withFollowUpAction: Boolean
}

enum ActionRequestState {
  COMPLETED
  DROPPED
  PENDING
  STALE
}

"""Basic statistics for actionRequests of an issue"""
type ActionableStatistics {
  """Average value of summarizable statistic"""
  average: Float!

  """Number of responses"""
  responseCount: Int!

  """Number of urgent actionRequests """
  urgentCount: Int!
}

input AdjustedImageInput {
  bucket: String
  id: String
  key: String
  reset: Boolean
}

"""Append new data to an uploaded session"""
input AppendToInteractionInput {
  data: NodeEntryDataInput
  edgeId: String
  nodeId: String
  sessionId: ID
}

input AssignUserToActionRequestInput {
  actionRequestId: String!
  assigneeId: String
  workspaceId: String!
}

input AssignUserToDialogueInput {
  dialogueId: String!
  state: Boolean!
  userId: String!
  workspaceId: String!
}

input AssignUserToDialoguesInput {
  assignedDialogueIds: [String!]
  userId: String!
  workspaceId: String!
}

type AssignedDialogues {
  assignedDialogues: [Dialogue!]
  privateWorkspaceDialogues: [Dialogue!]
}

input AuthenticateLambdaInput {
  authenticateEmail: String
  workspaceEmail: String
}

type AutodeckConnectionType implements DeprecatedConnectionInterface {
  cursor: String
  endDate: String
  jobs: [CreateWorkspaceJobType]
  limit: Int
  offset: Int
  pageInfo: DeprecatedPaginationPageInfo
  startDate: String
}

"""AutomationActionChannel"""
type AutomationActionChannel {
  createdAt: Date
  id: ID
  payload: JSONObject
  type: AutomationActionChannelType
  updatedAt: Date
}

input AutomationActionChannelInput {
  id: ID
}

enum AutomationActionChannelType {
  EMAIL
  SLACK
  SMS
}

input AutomationActionInput {
  apiKey: String
  channels: [AutomationActionChannelInput]
  endpoint: String
  id: ID
  payload: JSONObject
  type: AutomationActionType
}

"""AutomationAction"""
type AutomationActionModel {
  channels: [AutomationActionChannel]
  createdAt: Date
  id: ID
  payload: JSONObject
  type: AutomationActionType
  updatedAt: Date
}

enum AutomationActionType {
  API_CALL
  CUSTOM_REPORT
  MONTH_REPORT
  SEND_DIALOGUE_LINK
  SEND_EMAIL
  SEND_SMS
  WEBHOOK
  WEEK_REPORT
  YEAR_REPORT
}

input AutomationConditionBuilderInput {
  childConditionBuilder: AutomationConditionBuilderInput
  conditions: [CreateAutomationCondition]
  id: ID
  type: AutomationConditionBuilderType
}

"""AutomationConditionBuilder"""
type AutomationConditionBuilderModel {
  childConditionBuilderId: String
  conditions: [AutomationConditionModel]
  id: ID
  type: AutomationConditionBuilderType
}

enum AutomationConditionBuilderType {
  AND
  OR
}

"""AutomationCondition"""
type AutomationConditionModel {
  createdAt: Date
  dialogue: Dialogue
  dialogueScope: DialogueConditionScopeModel
  id: ID
  operands: [AutomationConditionOperandModel]
  operator: AutomationConditionOperatorType
  question: QuestionNode
  questionScope: QuestionConditionScopeModel
  scope: AutomationConditionScopeType
  updatedAt: Date
  workspaceScope: WorkspaceConditionScopeModel
}

"""AutomationConditionOperand"""
type AutomationConditionOperandModel {
  createdAt: Date
  dateTimeValue: String
  id: ID
  numberValue: Int
  textValue: String
  type: OperandType
  updatedAt: Date
}

enum AutomationConditionOperatorType {
  EVERY_N_TH_TIME
  GREATER_OR_EQUAL_THAN
  GREATER_THAN
  INNER_RANGE
  IS_EQUAL
  IS_FALSE
  IS_NOT_EQUAL
  IS_TRUE
  OUTER_RANGE
  SMALLER_OR_EQUAL_THAN
  SMALLER_THAN
}

enum AutomationConditionScopeType {
  DIALOGUE
  QUESTION
  WORKSPACE
}

type AutomationConnection implements ConnectionInterface {
  automations: [AutomationModel]
  pageInfo: PaginationPageInfo
  totalPages: Int
}

input AutomationConnectionFilterInput {
  label: String
  offset: Int
  orderBy: AutomationConnectionOrderByInput
  perPage: Int = 10
  search: String
  type: AutomationType
}

"""Sorting of UserConnection"""
input AutomationConnectionOrderByInput {
  by: AutomationConnectionOrderType!
  desc: Boolean = true
}

"""Fields to order UserConnection by."""
enum AutomationConnectionOrderType {
  createdAt
  type
  updatedAt
}

input AutomationEventInput {
  dialogueId: String
  eventType: AutomationEventType
  id: ID
  questionId: String
}

"""AutomationEvent"""
type AutomationEventModel {
  createdAt: Date
  dialogue: Dialogue
  endDate: String
  id: ID
  periodType: RecurringPeriodType
  question: QuestionNode
  startDate: String
  type: AutomationEventType
  updatedAt: Date
}

enum AutomationEventType {
  API_CALL
  NEW_INTERACTION_DIALOGUE
  NEW_INTERACTION_QUESTION
  RECURRING
}

"""Automation"""
type AutomationModel {
  automationScheduled: AutomationScheduledModel
  automationTrigger: AutomationTriggerModel
  createdAt: Date
  description: String
  id: ID
  isActive: Boolean
  label: String
  type: AutomationType
  updatedAt: Date
  workspace: Customer
}

input AutomationScheduleInput {
  dayOfMonth: String!
  dayOfWeek: String!
  dialogueId: String
  hours: String!
  id: ID
  minutes: String!
  month: String!
  type: RecurringPeriodType!
}

"""AutomationScheduled"""
type AutomationScheduledModel {
  actions: [AutomationActionModel]
  activeDialogue: Dialogue
  createdAt: Date
  dayOfMonth: String
  dayOfWeek: String
  dayRange: [DayRange]
  dialogueId: String
  frequency: String
  hours: String
  id: ID
  minutes: String
  month: String
  time: String
  type: RecurringPeriodType
  updatedAt: Date
}

"""AutomationTrigger"""
type AutomationTriggerModel {
  actions: [AutomationActionModel]
  activeDialogue: Dialogue
  conditionBuilder: AutomationConditionBuilderModel
  createdAt: Date
  event: AutomationEventModel
  id: ID
  updatedAt: Date
}

enum AutomationType {
  CAMPAIGN
  SCHEDULED
  TRIGGER
}

"""Basic statistics for a general statistics"""
type BasicStatistics {
  """Average value of summarizable statistic"""
  average: Float!

  """Number of responses"""
  responseCount: Int!
}

input CTALinkInputObjectType {
  backgroundColor: String
  buttonText: String
  header: String
  iconUrl: String
  id: String
  imageUrl: String
  subHeader: String
  title: String
  type: LinkTypeEnumType
  url: String
}

input CTALinksInputType {
  linkTypes: [CTALinkInputObjectType]
}

input CTAShareInputObjectType {
  id: String
  title: String
  tooltip: String
  url: String
}

"""Campaign"""
type CampaignType {
  deliveryConnection(filter: DeliveryConnectionFilterInput): DeliveryConnectionType
  id: ID
  label: String
  variants: [CampaignVariantType]
}

type CampaignVariantCustomVariableType {
  id: ID
  key: String
}

enum CampaignVariantEnum {
  EMAIL
  QUEUE
  SMS
}

"""Variant of campaign"""
type CampaignVariantType {
  body: String
  campaign: CampaignType
  customVariables: [CampaignVariantCustomVariableType]
  deliveryConnection: DeliveryConnectionType
  dialogue: Dialogue
  from: String
  id: ID!
  label: String!
  type: CampaignVariantEnum
  weight: Int
  workspace: Customer
}

"""Input type for a choice node"""
input ChoiceNodeEntryInput {
  value: String
}

enum CloudReferenceType {
  AWS
  Azure
  GCP
  IBM
}

type ColourSettings {
  id: Int
  primary: String
  primaryAlt: String
  secondary: String
}

input ConditionDialogueScopeInput {
  aggregate: ConditionPropertyAggregateInput
  aspect: DialogueAspectType
  id: ID
}

type ConditionPropertyAggregate {
  createdAt: String
  endDate: String
  id: ID
  latest: Int
  startDate: String
  type: ConditionPropertyAggregateType
}

input ConditionPropertyAggregateInput {
  endDate: String
  id: ID
  latest: Int
  startDate: String
  type: ConditionPropertyAggregateType
}

enum ConditionPropertyAggregateType {
  AVG
  COUNT
  MAX
  MIN
}

input ConditionQuestionScopeInput {
  aggregate: ConditionPropertyAggregateInput
  aspect: QuestionAspectType
  id: ID
}

input ConditionScopeInput {
  dialogueScope: ConditionDialogueScopeInput
  id: ID
  questionScope: ConditionQuestionScopeInput
  type: AutomationConditionScopeType
  workspaceScope: ConditionWorkspaceScopeInput
}

input ConditionWorkspaceScopeInput {
  aggregate: ConditionPropertyAggregateInput
  aspect: WorkspaceAspectType
  id: ID
}

"""Interface all pagination-based models should implement"""
interface ConnectionInterface {
  pageInfo: PaginationPageInfo
  totalPages: Int
}

input CreateAutomationCondition {
  dialogueId: String
  id: ID
  operands: [CreateAutomationOperandInput]
  operator: AutomationConditionOperatorType
  questionId: String
  scope: ConditionScopeInput
  workspaceId: String
}

input CreateAutomationInput {
  actions: [AutomationActionInput]
  automationType: AutomationType
  description: String
  event: AutomationEventInput
  id: ID
  label: String
  schedule: AutomationScheduleInput
  workspaceId: String
}

input CreateAutomationOperandInput {
  dateTimeValue: String
  id: ID
  numberValue: Int
  operandType: OperandType
  textValue: String
}

input CreateBatchDeliveriesInputType {
  batchScheduledAt: String
  campaignId: ID
  uploadedCsv: Upload
  workspaceId: String
}

type CreateBatchDeliveriesOutputType {
  failedDeliveries: [FailedDeliveryModel]
  nrDeliveries: Int
}

input CreateCTAInputType {
  customerSlug: String
  dialogueSlug: String
  form: FormNodeInputType
  links: CTALinksInputType

  """Linked question-node id"""
  questionId: String
  share: ShareNodeInputType
  title: String
  type: String
}

input CreateCampaignCustomVariable {
  key: String
}

input CreateCampaignInputType {
  label: String
  variants: [CreateCampaignVariantInputType]
  workspaceId: ID!
}

input CreateCampaignVariantInputType {
  body: String
  customVariables: [CreateCampaignCustomVariable]
  dialogueId: ID!
  from: String
  label: String
  subject: String
  type: CampaignVariantEnum!
  weight: Float
  workspaceId: ID!
}

input CreateDialogueInputType {
  contentType: String
  customerSlug: String
  description: String
  dialogueSlug: String
  isSeed: Boolean
  language: LanguageEnumType
  publicTitle: String
  tags: TagsInputObjectType
  templateDialogueId: String
  title: String
}

input CreateQuestionNodeInputType {
  customerId: ID
  dialogueSlug: String
  edgeCondition: EdgeConditionInputType
  extraContent: String
  happyText: String
  optionEntries: OptionsInputType
  overrideLeafId: ID
  parentQuestionId: ID
  title: String
  type: String
  unhappyText: String
}

"""Creates a topic (with subTopics) based on input"""
input CreateTopicInput {
  name: String!
  subTopics: [CreateTopicInput]
  type: TopicEnumType = SYSTEM
}

input CreateTriggerInputType {
  customerSlug: String
  recipients: RecipientsInputType
  trigger: TriggerInputType
}

"""Creates a workspace"""
input CreateWorkspaceInput {
  isDemo: Boolean = false
  isSeed: Boolean = false
  logo: String
  logoOpacity: Int
  name: String!
  primaryColour: String!
  slug: String!
  willGenerateFakeData: Boolean = false
}

type CreateWorkspaceJobType {
  createdAt: String
  errorMessage: String
  id: String
  message: String
  name: String
  processLocation: JobProcessLocation
  referenceId: String
  referenceType: CloudReferenceType
  requiresColorExtraction: Boolean
  requiresRembg: Boolean
  requiresScreenshot: Boolean
  resourcesUrl: String
  status: JobStatusType
  updatedAt: String
}

input CustomFieldInputType {
  key: String
  value: String
}

type CustomFieldType {
  id: String
  jobProcessLocationId: String
  key: String
  value: String
}

type Customer {
  actionRequestConnection(input: ActionRequestConnectionFilterInput): ActionRequestConnection
  automationConnection(filter: AutomationConnectionFilterInput): AutomationConnection
  automations: [AutomationModel]
  campaign(campaignId: String): CampaignType
  campaigns: [CampaignType]
  dialogue(where: DialogueWhereUniqueInput): Dialogue
  dialogueConnection(filter: DialogueConnectionFilterInput): DialogueConnection
  dialogues(filter: DialogueFilterInputType): [Dialogue]
  id: ID
  isDemo: Boolean
  issueConnection(filter: IssueConnectionFilterInput): IssueConnection
  issueDialogues(filter: IssueFilterInput): [Issue]
  issueTopics(input: IssueFilterInput): [Issue]
  name: String!
  nestedDialogueStatisticsSummary(input: DialogueStatisticsSummaryFilterInput): [DialogueStatisticsSummaryModel] @deprecated(reason: "Deprecated, see statistics")
  nestedHealthScore(input: HealthScoreInput): HealthScore @deprecated(reason: "Deprectaed, see statistics")
  nestedMostChanged(input: DialogueStatisticsSummaryFilterInput): MostChangedPath
  nestedMostPopular(input: DialogueStatisticsSummaryFilterInput): MostPopularPath
  nestedMostTrendingTopic(input: DialogueStatisticsSummaryFilterInput): MostTrendingTopic
  organization: Organization
  roles: [RoleType]
  sessionConnection(filter: SessionConnectionFilterInput): SessionConnection
  settings: CustomerSettings
  slug: String!

  """Workspace statistics"""
  statistics: WorkspaceStatistics
  userCustomer(userId: String): UserCustomer
  users: [UserType]
  usersConnection(customerSlug: String, filter: UserConnectionFilterInput): UserConnection
}

type CustomerSettings {
  colourSettings: ColourSettings
  colourSettingsId: Int
  fontSettings: FontSettings
  fontSettingsId: Int
  id: Int
  logoOpacity: Int
  logoUrl: String
}

input CustomerWhereUniqueInput {
  id: ID!
}

"""Date custom scalar type"""
scalar Date

"""
A histogram contains a list of entries sorted typically by date, along with their frequency.
"""
type DateHistogram {
  id: ID
  items: [DateHistogramItem!]!
}

"""A histogram item contains a date"""
type DateHistogramItem {
  date: Date
  frequency: Int!
  id: ID
}

"""

    A date-string follows format "dd-MM-yyyy HH:mm", "dd-MM-yyyy" or ISO format, and is resolved to a relevant Date object.
  
"""
scalar DateString

type DayRange {
  index: Int
  label: String
}

input DeleteAutomationInput {
  automationId: String!
  workspaceId: String!
}

input DeleteDialogueInputType {
  customerSlug: String
  id: ID
}

"""Delete Node Input type"""
input DeleteNodeInputType {
  customerId: ID
  dialogueSlug: String
  id: String
}

input DeleteUserInput {
  customerId: ID
  userId: ID
}

type DeleteUserOutput {
  deletedUser: Boolean
}

input DeliveryConnectionFilterInput {
  campaignVariantId: String
  endDate: String
  offset: Int
  orderBy: DeliveryConnectionOrderByInput
  perPage: Int = 10
  recipientEmail: String
  recipientFirstName: String
  recipientLastName: String
  recipientPhoneNumber: String
  search: String
  startDate: String
  status: DeliveryStatusEnum
}

"""Fields to order DeliveryConnection by."""
enum DeliveryConnectionOrder {
  createdAt
}

"""Sorting of DeliveryConnection"""
input DeliveryConnectionOrderByInput {
  by: DeliveryConnectionOrder!
  desc: Boolean = true
}

type DeliveryConnectionType implements ConnectionInterface {
  deliveries: [DeliveryType!]!
  pageInfo: PaginationPageInfo
  totalPages: Int
}

type DeliveryEventType {
  createdAt: Date
  failureMessage: String
  id: ID
  status: DeliveryStatusEnum
}

enum DeliveryStatusEnum {
  DELIVERED
  DEPLOYED
  FAILED
  FINISHED
  OPENED
  SCHEDULED
  SENT
}

"""Delivery"""
type DeliveryType {
  campaignVariant: CampaignVariantType
  createdAt: Date
  currentStatus: DeliveryStatusEnum
  deliveryRecipientEmail: String
  deliveryRecipientFirstName: String
  deliveryRecipientLastName: String
  deliveryRecipientPhone: String
  events: [DeliveryEventType]
  id: ID!
  scheduledAt: Date
  updatedAt: Date
}

"""Interface all pagination-based models should implement"""
interface DeprecatedConnectionInterface {
  cursor: String
  endDate: String
  limit: Int
  offset: Int
  pageInfo: DeprecatedPaginationPageInfo
  startDate: String
}

"""Information with regards to current page, and total number of pages"""
type DeprecatedPaginationPageInfo {
  cursor: String
  nrPages: Int
  pageIndex: Int
}

"""Deselects all question options as topic within workspace"""
input DeselectTopicInput {
  topic: String!
  workspaceId: ID!
}

type Dialogue {
  assignees: [UserType]
  averageScore(input: DialogueFilterInputType): Float
  campaignVariants: [CampaignVariantType!]
  creationDate: Date
  customer: Customer
  customerId: String
  description: String!
  dialogueStatisticsSummary(input: DialogueStatisticsSummaryFilterInput): DialogueStatisticsSummaryModel
  edges: [Edge]
  healthScore(input: HealthScoreInput): HealthScore
  id: String!
  isPrivate: Boolean
  isWithoutGenData: Boolean
  issues(filter: IssueFilterInput): Issue
  language: LanguageEnumType
  leafs(searchTerm: String): [QuestionNode!]
  mostChangedPath(input: DialogueStatisticsSummaryFilterInput): MostChangedPath
  mostPopularPath(input: DialogueStatisticsSummaryFilterInput): MostPopularPath
  mostTrendingTopic(input: DialogueStatisticsSummaryFilterInput): MostTrendingTopic
  pathedSessionsConnection(input: PathedSessionsInput): PathedSessionsType
  postLeafNode: DialogueFinisherObjectType
  postLeafNodeId: String
  publicTitle: String
  questions: [QuestionNode!]
  rootQuestion: QuestionNode
  sessionConnection(filter: SessionConnectionFilterInput): SessionConnection
  sessions(take: Int): [Session]
  slug: String!
  statistics(input: DialogueStatisticsSummaryFilterInput): DialogueStatistics
  tags: [Tag]
  template: String
  title: String!
  topic(input: TopicInputType): TopicType
  updatedAt: Date
  wasGeneratedWithGenData: Boolean
}

enum DialogueAspectType {
  GENERAL_SCORE
  LATEST_SCORE
  NR_INTERACTIONS
  NR_VISITORS
}

"""DialogueConditionScope"""
type DialogueConditionScopeModel {
  aggregate: ConditionPropertyAggregate
  aspect: DialogueAspectType
  createdAt: Date
  id: ID
  updatedAt: Date
}

type DialogueConnection implements ConnectionInterface {
  dialogues: [Dialogue]
  pageInfo: PaginationPageInfo
  totalPages: Int
}

input DialogueConnectionFilterInput {
  endDate: String
  offset: Int
  orderBy: DialogueConnectionOrderByInput
  perPage: Int = 10
  searchTerm: String
  startDate: String
}

"""Fields to order UserConnection by."""
enum DialogueConnectionOrder {
  createdAt
}

"""Sorting of DialogueConnection"""
input DialogueConnectionOrderByInput {
  by: DialogueConnectionOrder!
  desc: Boolean = true
}

input DialogueFilterInputType {
  endDateTime: String
  searchTerm: String
  startDateTime: String
}

type DialogueFinisherObjectType {
  header: String
  id: ID
  subtext: String
}

enum DialogueImpactScoreType {
  AVERAGE
}

type DialogueStatistics {
  history: [lineChartDataType]
  mostPopularPath: topPathType
  nrInteractions: Int
  topNegativePath: [topPathType]
  topPositivePath: [topPathType]
}

input DialogueStatisticsSummaryFilterInput {
  cutoff: Int
  endDateTime: String
  impactType: DialogueImpactScoreType!
  refresh: Boolean
  startDateTime: String!
  topicsFilter: TopicFilterInput
}

"""DialogueStatisticsSummary"""
type DialogueStatisticsSummaryModel {
  dialogue: Dialogue
  dialogueId: String
  endDateTime: Date
  id: ID
  impactScore: Float
  nrVotes: Int
  startDateTime: Date
  title: String
  updatedAt: Date
}

enum DialogueTemplateType {
  BUSINESS_ENG
  BUSINESS_NL
  DEFAULT
  MASS_SEED
  SPORT_ENG
  SPORT_NL
  STUDENT_ENG
  STUDENT_NL
  TEACHER_ENG
  TEACHER_NL
}

input DialogueWhereUniqueInput {
  id: ID
  slug: String
}

type Edge {
  childNode: QuestionNode
  childNodeId: String
  conditions: [EdgeCondition!]
  createdAt: Date
  id: ID
  parentNode: QuestionNode
  parentNodeId: String
  updatedAt: Date
}

type EdgeCondition {
  conditionType: String
  edgeId: String
  id: Int
  matchValue: String
  renderMax: Int
  renderMin: Int
}

input EdgeConditionInputType {
  conditionType: String
  id: Int
  matchValue: String
  renderMax: Int
  renderMin: Int
}

input EditUserInput {
  customerId: String
  email: String!
  firstName: String
  lastName: String
  phone: String
  roleId: String
}

"""Edit a workspace"""
input EditWorkspaceInput {
  customerSlug: String!
  id: ID!
  logo: String
  logoOpacity: Int
  name: String!
  primaryColour: String!
  slug: String!
}

input EnableAutomationInput {
  automationId: String!
  state: Boolean!
  workspaceId: String!
}

type FailedDeliveryModel {
  error: String
  record: String
}

input FindRoleInput {
  roleId: String
  userId: String
}

type FontSettings {
  id: Int
}

"""FormNodeEntryInput"""
input FormNodeEntryFieldInput {
  contacts: String
  email: String
  longText: String
  number: Int
  phoneNumber: String
  relatedFieldId: ID
  shortText: String
  url: String
}

"""FormNodeEntryInput"""
input FormNodeEntryInput {
  values: [FormNodeEntryFieldInput]
}

type FormNodeEntryType {
  id: Int
  values: [FormNodeEntryValueType]
}

type FormNodeEntryValueType {
  contacts: String
  email: String
  longText: String
  number: Int
  phoneNumber: String
  relatedField: FormNodeField
  shortText: String
  url: String
}

type FormNodeField {
  """
  
          List of possible contact points for a form-node.
        
  """
  contacts: [UserType]
  id: ID
  isRequired: Boolean
  label: String
  placeholder: String
  position: Int
  type: FormNodeFieldTypeEnum!
}

input FormNodeFieldInput {
  id: ID
  isRequired: Boolean = false
  label: String
  placeholder: String
  position: Int
  type: FormNodeFieldTypeEnum
  userIds: [String]
}

"""The types a field can assume"""
enum FormNodeFieldTypeEnum {
  contacts
  email
  longText
  number
  phoneNumber
  shortText
  url
}

input FormNodeInputType {
  fields: [FormNodeFieldInput!]
  helperText: String
  id: String
  preFormNode: PreFormNodeInput
  steps: [FormNodeStepInput!]
}

type FormNodeStep {
  fields: [FormNodeField!]
  header: String
  helper: String
  id: String!
  position: Int!
  subHelper: String
  type: FormNodeStepType!
}

input FormNodeStepInput {
  fields: [FormNodeFieldInput!]
  header: String!
  helper: String!
  id: ID
  position: Int!
  subHelper: String!
  type: FormNodeStepType!
}

enum FormNodeStepType {
  GENERIC_FIELDS
}

type FormNodeType {
  fields: [FormNodeField!]
  helperText: String
  id: String
  preForm: PreFormNodeType
  steps: [FormNodeStep!]
}

"""Generate savales documents"""
input GenerateAutodeckInput {
  answer1: String
  answer2: String
  answer3: String
  answer4: String
  companyName: String
  customFields: [CustomFieldInputType]
  emailContent: String
  firstName: String
  id: String!
  isGenerateWorkspace: Boolean
  jobLocationId: String
  logo: String
  name: String
  newCustomFields: [CustomFieldInputType]
  primaryColour: String
  requiresColorExtraction: Boolean!
  requiresRembgLambda: Boolean!
  requiresWebsiteScreenshot: Boolean!
  reward: String
  slug: String
  sorryAboutX: String
  standardFields: [CustomFieldInputType]
  textMessage: String
  usesAdjustedLogo: Boolean!
  website: String
  youLoveX: String
}

input GenerateWorkspaceCSVInputType {
  generateDemoData: Boolean = false
  isDemo: Boolean! = false
  makeDialoguesPrivate: Boolean = false
  managerCsv: Upload
  type: String! = "DEFAULT"
  uploadedCsv: Upload
  workspaceSlug: String!
  workspaceTitle: String!
}

input GetAutomationInput {
  id: String
}

input GetAutomationsByWorkspaceInput {
  workspaceId: String
}

input GetCampaignsInput {
  customerSlug: String
}

input GetIssueResolverInput {
  issueId: String
  topicId: String
  workspaceId: String
}

input HandleUserStateInWorkspaceInput {
  isActive: Boolean
  userId: String
  workspaceId: String
}

type HealthScore {
  average: Float!
  negativeResponseCount: Int!
  nrVotes: Int!
  score: Float!
}

input HealthScoreInput {
  endDateTime: String
  startDateTime: String!
  threshold: Float = 70
  topicFilter: TopicFilterInput
}

type ImageType {
  encoding: String
  filename: String
  mimetype: String
  url: String
}

type IndepthQuestionStatisticsSummary {
  impactScore: Float
  nrVotes: Int
  option: String
}

input InviteUserInput {
  customerId: String!
  email: String!
  roleId: String!
}

type InviteUserOutput {
  didAlreadyExist: Boolean
  didInvite: Boolean
}

"""

    An issue is a problem that has been identified.

    Typically, an issue is a combination of a particulat topic and a specific dialogue.
  
"""
type Issue {
  """Number of actions required"""
  actionRequiredCount: Int!
  basicStats: BasicStatistics!
  createdAt: Date
  dialogue: Dialogue
  dialogueId: String!
  followUpAction: SessionActionType
  history: DateHistogram!
  id: ID
  rankScore: Float
  status: StatusType!
  topic: String
  updatedAt: Date
}

type IssueConnection implements ConnectionInterface {
  issues: [IssueModel]
  pageInfo: PaginationPageInfo
  totalPages: Int
}

input IssueConnectionFilterInput {
  endDate: DateString
  label: String
  offset: Int!
  orderBy: IssueConnectionOrderByInput
  perPage: Int! = 10
  search: String
  startDate: DateString
  topicStrings: [String!]
}

"""Sorting of IssueConnection"""
input IssueConnectionOrderByInput {
  by: IssueConnectionOrderType!
  desc: Boolean = true
}

"""Fields to order IssueConnection by."""
enum IssueConnectionOrderType {
  issue
}

"""Filter input for Issues"""
input IssueFilterInput {
  dialogueStrings: [String!]
  endDate: String
  startDate: String
  topicStrings: [String!]
}

type IssueModel {
  actionRequestConnection(input: ActionRequestConnectionFilterInput): ActionRequestConnection
  actionRequests(input: ActionRequestFilterInput): [ActionRequest]!
  basicStats: ActionableStatistics
  createdAt: Date
  id: ID

  """Number of different teams issue exists for"""
  teamCount: Int!
  topic: Topic!
  topicId: String!
  updatedAt: Date
  workspaceId: String!
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type JobObjectType {
  createWorkspaceJob: CreateWorkspaceJobType
  createWorkspaceJobId: String
  createdAt: String
  id: String
  updatedAt: String
}

type JobProcessLocation {
  customFields: [CustomFieldType]
  id: String
  name: String
  path: String
  type: JobProcessLocationType
  xMaterialDimension: Int
  yMaterialDimension: Int
}

enum JobProcessLocationType {
  BROCHURE
  ONE_PAGER
  PITCHDECK
}

type JobProcessLocations {
  jobProcessLocations: [JobProcessLocation]
}

enum JobStatusType {
  COMPLETED
  COMPRESSING_SALES_MATERIAL
  FAILED
  IN_PHOTOSHOP_QUEUE
  PENDING
  PHOTOSHOP_PROCESSING
  PRE_PROCESSING
  PRE_PROCESSING_LOGO
  PRE_PROCESSING_WEBSITE_SCREENSHOT
  PROCESSING
  READY_FOR_PROCESSING
  STITCHING_SLIDES
  TRANSFORMING_PSDS_TO_PNGS
  WRAPPING_UP
}

enum LanguageEnumType {
  DUTCH
  ENGLISH
  GERMAN
}

type LinkType {
  backgroundColor: String
  buttonText: String
  header: String
  iconUrl: String
  id: String!
  imageUrl: String
  questionNode: QuestionNode
  questionNodeId: String
  subHeader: String
  title: String
  type: String!
  url: String!
}

enum LinkTypeEnumType {
  API
  FACEBOOK
  INSTAGRAM
  LINKEDIN
  SINGLE
  SOCIAL
  TWITTER
  WHATSAPP
}

"""Login credential"""
input LoginInput {
  email: String!
}

"""Information you get after you log out"""
type LoginOutput {
  expiryDate: Int
  token: String
  user: UserType
}

input MassSeedInput {
  customerId: String!
  maxGroups: Int!
  maxSessions: Int!
  maxTeams: Int!
}

type MostChangedPath {
  group: String
  topNegativeChanged: [TopicDelta]
  topPositiveChanged: [TopicDelta]
}

type MostPopularPath {
  group: String
  path: [PathTopic]
}

type MostTrendingTopic {
  group: String
  impactScore: Float
  nrVotes: Int
  path: [String]
}

type Mutation {
  appendToInteraction(input: AppendToInteractionInput): Session
  assignTags(dialogueId: String, tags: TagsInputObjectType): Dialogue
  assignUserToActionRequest(input: AssignUserToActionRequestInput!): ActionRequest
  assignUserToDialogue(input: AssignUserToDialogueInput): UserType
  assignUserToDialogues(input: AssignUserToDialoguesInput): UserType
  authenticateLambda(input: AuthenticateLambdaInput): String
  confirmCreateWorkspaceJob(input: GenerateAutodeckInput): CreateWorkspaceJobType
  copyDialogue(input: CreateDialogueInputType): Dialogue

  """Creates a new automation."""
  createAutomation(input: CreateAutomationInput): AutomationModel
  createAutomationToken(email: String): String
  createBatchDeliveries(input: CreateBatchDeliveriesInputType): CreateBatchDeliveriesOutputType

  """Create Call to Actions"""
  createCTA(input: CreateCTAInputType): QuestionNode
  createCampaign(input: CreateCampaignInputType): CampaignType
  createDialogue(input: CreateDialogueInputType): Dialogue
  createJobProcessLocation(input: createJobProcessLocationInput): JobProcessLocation
  createPermission(data: PermissionInput): PermssionType
  createQuestion(input: CreateQuestionNodeInputType): QuestionNode
  createRole(data: RoleInput): RoleType
  createSession(input: SessionInput): Session
  createTag(customerSlug: String, name: String, type: TagTypeEnum): Tag

  """Creates a list of topics and its subtopics."""
  createTopic(input: [CreateTopicInput!]): Boolean
  createTrigger(input: CreateTriggerInputType): TriggerType
  createWorkspace(input: CreateWorkspaceInput): Customer
  deleteAutomation(input: DeleteAutomationInput): AutomationModel
  deleteCTA(input: DeleteNodeInputType): QuestionNode
  deleteCustomer(where: CustomerWhereUniqueInput): Customer
  deleteDialogue(input: DeleteDialogueInputType): Dialogue
  deleteQuestion(input: DeleteNodeInputType): QuestionNode
  deleteTag(tagId: String): Tag
  deleteTrigger(customerSlug: String, id: String): TriggerType
  deleteUser(input: DeleteUserInput): DeleteUserOutput

  """
  
      Deselcting a topic implies that all question-options related to the topic string are disregarded as topic.
    
  """
  deselectTopic(input: DeselectTopicInput): Boolean
  duplicateQuestion(questionId: String): QuestionNode
  editDialogue(customerSlug: String, description: String, dialogueFinisherHeading: String, dialogueFinisherSubheading: String, dialogueSlug: String, isWithoutGenData: Boolean, language: LanguageEnumType, publicTitle: String, tags: TagsInputObjectType, title: String): Dialogue
  editTrigger(customerSlug: String, recipients: RecipientsInputType, trigger: TriggerInputType, triggerId: String): TriggerType
  editUser(input: EditUserInput, userId: String): UserType
  editWorkspace(input: EditWorkspaceInput): Customer
  enableAutomation(input: EnableAutomationInput): AutomationModel
  generateAutodeck(input: GenerateAutodeckInput): CreateWorkspaceJobType
  generateWorkspaceFromCSV(input: GenerateWorkspaceCSVInputType): Customer
  handleUserStateInWorkspace(input: HandleUserStateInWorkspaceInput): UserCustomer

  """Invite a user to a particular customer domain, given an email and role"""
  inviteUser(input: InviteUserInput): InviteUserOutput

  """Logs a user out by removing their refresh token"""
  logout: String
  massSeed(input: MassSeedInput): Customer
  register(input: RegisterInput): String
  removePixelRange(input: RemovePixelRangeInput): AWSImageType
  requestInvite(input: RequestInviteInput): RequestInviteOutput
  resetWorkspaceData(workspaceId: String): Boolean
  retryAutodeckJob(jobId: String): CreateWorkspaceJobType
  revokeTopic(input: RevokeTopicInput): Topic
  sandbox(input: SandboxInput): String
  sendAutomationDialogueLink(input: SendAutomationDialogueLinkInput): Boolean
  sendAutomationReport(input: SendAutomationReportInput): Boolean
  setActionRequestStatus(input: SetActionRequestStatusInput!): ActionRequest
  setDialoguePrivacy(input: SetDialoguePrivacyInput): Dialogue
  singleUpload(file: Upload!): ImageType
  updateAutomation(input: CreateAutomationInput): AutomationModel
  updateCTA(input: UpdateCTAInputType): QuestionNode
  updateCreateWorkspaceJob(errorMessage: String, id: String, referenceId: String, resourceUrl: String, status: JobStatusType): CreateWorkspaceJobType
  updateDeliveryStatus(deliveryId: String, status: DeliveryStatusEnum): String
  updatePermissions(input: UpdatePermissionsInput): RoleType
  updateQuestion(input: UpdateQuestionNodeInputType): QuestionNode
  updateRoles(permissions: PermissionIdsInput, roleId: String): RoleType
  uploadJobImage(disapproved: Boolean, file: Upload, jobId: String, type: UploadImageEnumType): AWSImageType
  uploadUpsellImage(input: UploadSellImageInputType): ImageType
  verifyActionRequest(input: VerifyActionRequestInput!): ActionRequest

  """
  Given a token, checks in the database whether token has been set and has not expired yet
  """
  verifyUserToken(token: String): VerifyUserTokenOutput
  whitifyImage(input: AdjustedImageInput): AWSImageType
}

type NodeEntry {
  creationDate: Date
  depth: Int
  id: ID
  relatedEdgeId: String
  relatedNode: QuestionNode
  relatedNodeId: String

  """The core scoring value associated with the node entry."""
  value: NodeEntryValue
}

"""Data type for the actual node entry"""
input NodeEntryDataInput {
  choice: ChoiceNodeEntryInput
  form: FormNodeEntryInput
  register: RegisterNodeEntryInput
  slider: SliderNodeEntryInput
  textbox: TextboxNodeEntryInput
  video: VideoNodeEntryInput
}

"""Input type for node-entry metadata"""
input NodeEntryInput {
  data: NodeEntryDataInput
  depth: Int
  edgeId: String
  nodeId: String
}

type NodeEntryValue {
  choiceNodeEntry: String
  formNodeEntry: FormNodeEntryType
  linkNodeEntry: String
  registrationNodeEntry: String
  sliderNodeEntry: Int
  textboxNodeEntry: String
  videoNodeEntry: String
}

enum OperandType {
  DATE_TIME
  INT
  STRING
}

input OptionInputType {
  id: Int
  isTopic: Boolean
  overrideLeafId: String
  position: Int!
  publicValue: String
  value: String
}

input OptionsInputType {
  options: [OptionInputType]
}

"""

    An Organization defines the underlying members structure of a workspace, corresponding to an org-chart.
  
"""
type Organization {
  id: ID
  layers: [OrganizationLayer]
}

"""A layer of an organization"""
type OrganizationLayer {
  depth: Int
  id: ID
  type: OrganizationLayerType
}

"""Type of an organizational layer"""
enum OrganizationLayerType {
  DIALOGUE
  GROUP
  INTERACTION
}

"""Information with regards to current page."""
type PaginationPageInfo {
  hasNextPage: Boolean
  hasPrevPage: Boolean
  nextPageOffset: Int
  pageIndex: Int
  prevPageOffset: Int
}

"""Fields that can be used for free text search on tables"""
enum PaginationSearchEnum {
  email
  firstName
  lastName
  name
  publicTitle
  title
}

"""Ways to sort a pagination object"""
enum PaginationSortByEnum {
  createdAt
  email
  firstName
  id
  lastName
  medium
  name
  paths
  role
  scheduledAt
  score
  type
  updatedAt
  user
  when
}

"""Sorting of pagination (type and whether it ascends)"""
input PaginationSortInput {
  by: PaginationSortByEnum!
  desc: Boolean = true
}

input PaginationWhereInput {
  cursor: String
  endDate: String
  limit: Int
  offset: Int
  orderBy: [PaginationSortInput]
  pageIndex: Int
  search: String
  searchTerm: String
  startDate: String
}

"""A path is the traversal of topics in a dialogue."""
type Path {
  id: ID
  topicStrings: [String]
}

type PathTopic {
  depth: Int
  impactScore: Float
  nrVotes: Int
  topic: String
}

input PathedSessionsInput {
  endDateTime: String
  issueOnly: Boolean
  path: [String!]
  refresh: Boolean = false
  startDateTime: String!
}

type PathedSessionsType {
  endDateTime: String
  path: [String]
  pathedSessions: [Session!]
  startDateTime: String
}

input PermissionIdsInput {
  ids: [String]
}

input PermissionInput {
  customerId: String
  description: String
  name: String
}

type PermssionType {
  customer: Customer
  description: String
  id: ID
  name: String
}

input PreFormNodeInput {
  finishText: String!
  header: String!
  helper: String!
  nextText: String!
}

type PreFormNodeType {
  finishText: String!
  header: String!
  helper: String!
  id: String!
  nextText: String!
}

type PreviewDataType {
  colors: [String]
  rembgLogoUrl: String
  websiteScreenshotUrl: String
}

type PublicDialogueConnection implements ConnectionInterface {
  dialogues: [PublicDialogueInfo]
  pageInfo: PaginationPageInfo
  totalPages: Int
}

type PublicDialogueInfo {
  description: String
  slug: String
  title: String
  url: String
}

type Query {
  UserOfCustomer(input: UserOfCustomerInput): UserCustomer
  automation(where: GetAutomationInput): AutomationModel
  automations(where: GetAutomationsByWorkspaceInput): [AutomationModel]
  customer(id: ID, slug: String): Customer
  customers: [Customer]
  delivery(deliveryId: String): DeliveryType
  dialogue(where: DialogueWhereUniqueInput): Dialogue
  dialogueLinks(filter: DialogueConnectionFilterInput, workspaceId: String): PublicDialogueConnection
  dialogues(filter: DialogueFilterInputType): [Dialogue]
  edge(id: String): Edge
  getAdjustedLogo(input: AdjustedImageInput): AWSImageType
  getAutodeckJobs(filter: PaginationWhereInput): AutodeckConnectionType
  getJob(id: String): CreateWorkspaceJobType
  getJobProcessLocations: JobProcessLocations
  getPreviewData(id: String): PreviewDataType
  issue(actionableFilter: ActionRequestFilterInput, input: GetIssueResolverInput): IssueModel
  me: UserType
  question(where: QuestionWhereUniqueInput): QuestionNode
  refreshAccessToken: RefreshAccessTokenOutput
  role(input: FindRoleInput): RoleType
  roleConnection(customerId: String, filter: PaginationWhereInput): RoleConnection

  """A session is one entire user-interaction"""
  session(id: String): Session
  sessions(where: SessionWhereUniqueInput): [Session]
  tags(customerSlug: String, dialogueId: String): [Tag]
  trigger(triggerId: String): TriggerType
  triggerConnection(customerSlug: String, filter: PaginationWhereInput): TriggerConnectionType
  triggers(customerSlug: String, dialogueId: String, filter: PaginationWhereInput, userId: String): [TriggerType]
  user(userId: String): UserType
  users(customerSlug: String): [UserType]
}

enum QuestionAspectType {
  ANSWER_SPEED
  NODE_VALUE
}

"""QuestionConditionScope"""
type QuestionConditionScopeModel {
  aggregate: ConditionPropertyAggregate
  aspect: QuestionAspectType
  createdAt: Date
  id: ID
}

enum QuestionImpactScoreType {
  PERCENTAGE
}

type QuestionNode {
  children: [Edge!]
  creationDate: Date
  extraContent: String

  """FormNode resolver"""
  form: FormNodeType
  id: ID!
  indepthQuestionStatisticsSummary(input: QuestionStatisticsSummaryFilterInput): [IndepthQuestionStatisticsSummary]
  isLeaf: Boolean!
  isRoot: Boolean
  links: [LinkType!]!
  options: [QuestionOption]
  overrideLeaf: QuestionNode
  overrideLeafId: String
  questionDialogue: Dialogue
  questionDialogueId: String
  questionStatisticsSummary(input: QuestionStatisticsSummaryFilterInput): QuestionStatisticsSummary
  share: ShareNodeType

  """Slidernode resolver"""
  sliderNode: SliderNodeType
  title: String!
  type: QuestionNodeTypeEnum
  updatedAt: String
  videoEmbeddedNodeId: String
}

"""The different types a node can assume"""
enum QuestionNodeTypeEnum {
  CHOICE
  FORM
  GENERIC
  LINK
  REGISTRATION
  SHARE
  SLIDER
  TEXTBOX
  VIDEO_EMBEDDED
}

input QuestionNodeWhereInputType {
  id: ID
  isRoot: Boolean
}

input QuestionNodeWhereUniqueInput {
  id: String!
}

type QuestionOption {
  id: Int
  isTopic: Boolean
  overrideLeaf: QuestionNode
  overrideLeafId: String
  position: Int
  publicValue: String
  questionId: String
  value: String
}

type QuestionStatisticsSummary {
  dialogueId: String
  endDateTime: Date
  id: ID
  startDateTime: Date
  updatedAt: Date
}

input QuestionStatisticsSummaryFilterInput {
  endDateTime: String
  impactTreshold: Int
  impactType: QuestionImpactScoreType!
  refresh: Boolean
  startDateTime: String!
}

input QuestionWhereUniqueInput {
  id: ID!
}

input RecipientsInputType {
  ids: [String]
}

enum RecurringPeriodType {
  CUSTOM
  END_OF_DAY
  END_OF_WEEK
  EVERY_DAY
  EVERY_MONTH
  EVERY_WEEK
  EVERY_YEAR
  START_OF_DAY
  START_OF_WEEK
}

type RefreshAccessTokenOutput {
  accessToken: String
}

"""Registration credentials"""
input RegisterInput {
  customerId: String!
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  roleId: String
}

"""Input type for a register node"""
input RegisterNodeEntryInput {
  value: String
}

input RemovePixelRangeInput {
  blue: Int
  bucket: String
  green: Int
  key: String
  range: Int
  red: Int
}

input RequestInviteInput {
  email: String!
}

type RequestInviteOutput {
  didInvite: Boolean
  loginToken: String
  userExists: Boolean
}

"""Revokes a sub topic from a topic based on input"""
input RevokeTopicInput {
  subTopic: String!
  topic: String!
}

type RoleConnection implements DeprecatedConnectionInterface {
  cursor: String
  endDate: String
  limit: Int
  offset: Int
  pageInfo: DeprecatedPaginationPageInfo
  roles: [RoleType]
  startDate: String
}

input RoleDataInput {
  description: String
  name: String
}

input RoleInput {
  customerId: String
  description: String
  name: String
  permissions: [SystemPermission]
}

type RoleType {
  allPermissions: [SystemPermission]
  customerId: String
  id: ID
  name: String
  nrPermissions: Int
  permissions: [SystemPermission]
  roleId: String
}

input SandboxInput {
  name: String
  onlyGet: Boolean
  value: Int
}

input SendAutomationDialogueLinkInput {
  automationActionId: String!
  workspaceSlug: String!
}

input SendAutomationReportInput {
  automationActionId: String!
  reportUrl: String!
  workspaceSlug: String!
}

type Session {
  browser: String
  createdAt: Date
  delivery: DeliveryType
  deliveryId: String
  device: String
  dialogue: Dialogue
  dialogueId: String
  followUpAction: FormNodeEntryType
  id: ID!
  mainScore: Float
  nodeEntries: [NodeEntry!]
  originUrl: String
  paths: Int
  score: Float!
  totalTimeInSec: Int
}

"""Actions expected after session"""
enum SessionActionType {
  CONTACT
}

type SessionConnection implements ConnectionInterface {
  pageInfo: PaginationPageInfo
  sessions: [Session!]!
  totalPages: Int
}

input SessionConnectionFilterInput {
  campaignVariantId: String
  deliveryType: SessionDeliveryType
  dialogueIds: [String!]
  endDate: DateString
  offset: Int
  orderBy: SessionConnectionOrderByInput
  perPage: Int = 10
  scoreRange: SessionScoreRangeFilter
  search: String
  startDate: DateString
  withFollowUpAction: Boolean
}

"""Fields to order SessionConnection by."""
enum SessionConnectionOrder {
  createdAt
  dialogueId
}

"""Sorting of sessionConnection"""
input SessionConnectionOrderByInput {
  by: SessionConnectionOrder!
  desc: Boolean = true
}

"""Delivery type of session to filter by."""
enum SessionDeliveryType {
  campaigns
  noCampaigns
}

"""Input for session"""
input SessionInput {
  createdAt: String
  deliveryId: String
  device: String
  dialogueId: String!
  entries: [NodeEntryInput]
  originUrl: String
  totalTimeInSec: Int
}

"""Scores to filter sessions by."""
input SessionScoreRangeFilter {
  max: Int
  min: Int
}

input SessionWhereUniqueInput {
  dialogueId: ID
  id: ID
}

input SetActionRequestStatusInput {
  actionRequestId: String!
  status: ActionRequestState!
  workspaceId: String!
}

input SetDialoguePrivacyInput {
  customerId: String!
  dialogueSlug: String!
  state: Boolean!
}

input ShareNodeInputType {
  id: String
  title: String
  tooltip: String
  url: String
}

type ShareNodeType {
  createdAt: String
  id: String
  title: String
  tooltip: String
  updatedAt: String
  url: String
}

input SlideNodeMarkerInput {
  id: ID
  label: String!
  range: SliderNodeRangeInputType
  subLabel: String!
}

"""Input type for a slider node"""
input SliderNodeEntryInput {
  value: Int
}

input SliderNodeInputType {
  id: ID
  markers: [SlideNodeMarkerInput!]
}

type SliderNodeMarkerType {
  id: ID
  label: String
  range: SliderNodeRangeType
  subLabel: String
}

input SliderNodeRangeInputType {
  end: Float
  start: Float
}

type SliderNodeRangeType {
  end: Float
  id: ID
  start: Float
}

type SliderNodeType {
  happyText: String
  id: ID
  markers: [SliderNodeMarkerType!]
  unhappyText: String
}

"""Details regarding interaction with social node"""
input SocialNodeEntryInput {
  visitedLink: String
}

"""A status is a label that indicates the current state of a process."""
enum StatusType {
  CLOSED
  IN_PROGRESS
  OPEN
}

enum SystemPermission {
  CAN_ACCESS_ADMIN_PANEL
  CAN_ACCESS_ALL_ACTION_REQUESTS
  CAN_ACCESS_REPORT_PAGE
  CAN_ADD_USERS
  CAN_ASSIGN_USERS_TO_DIALOGUE
  CAN_BUILD_DIALOGUE
  CAN_CREATE_AUTOMATIONS
  CAN_CREATE_CAMPAIGNS
  CAN_CREATE_DELIVERIES
  CAN_CREATE_TRIGGERS
  CAN_DELETE_DIALOGUE
  CAN_DELETE_TRIGGERS
  CAN_DELETE_USERS
  CAN_DELETE_WORKSPACE
  CAN_DOWNLOAD_REPORTS
  CAN_EDIT_DIALOGUE
  CAN_EDIT_USERS
  CAN_EDIT_WORKSPACE
  CAN_GENERATE_WORKSPACE_FROM_CSV
  CAN_RESET_WORKSPACE_DATA
  CAN_UPDATE_AUTOMATIONS
  CAN_VIEW_ACTION_REQUESTS
  CAN_VIEW_AUTOMATIONS
  CAN_VIEW_CAMPAIGNS
  CAN_VIEW_DIALOGUE
  CAN_VIEW_DIALOGUE_ANALYTICS
  CAN_VIEW_USERS
}

type Tag {
  customerId: String
  id: ID
  name: String
  type: TagTypeEnum
}

enum TagTypeEnum {
  AGENT
  DEFAULT
  LOCATION
}

input TagsInputObjectType {
  entries: [String]
}

"""Input type for a textbox node"""
input TextboxNodeEntryInput {
  value: String
}

"""Model for topic"""
type Topic {
  id: ID!
  name: String!
  parentTopics: [Topic]
  subTopics: [Topic]
  type: String!

  """A list of question options to which this topic is assigned to."""
  usedByOptions: [QuestionOption]
  workspace: Customer
}

type TopicDelta {
  averageCurrent: Float
  averagePrevious: Float
  delta: Float
  group: String
  nrVotes: Int
  percentageChanged: Float
  topic: String
}

"""All the different types a topic can be."""
enum TopicEnumType {
  SYSTEM
  WORKSPACE
}

"""Generic filter object for filtering topics"""
input TopicFilterInput {
  dialogueStrings: [String!]
  relatedSessionScoreLowerThreshold: Float
  topicStrings: [String!]
}

input TopicInputType {
  endDateTime: String
  impactScoreType: DialogueImpactScoreType!
  isRoot: Boolean = false
  refresh: Boolean
  startDateTime: String!
  value: String!
}

type TopicNodeEntryValue {
  id: Int
  mainScore: Int
  nodeEntryId: String
  value: String
}

type TopicType {
  basicStats: BasicStatistics
  impactScore: Float
  name: String!
  nrVotes: Int
  subTopics: [TopicType]
}

enum TriggerConditionEnum {
  HIGH_THRESHOLD
  INNER_RANGE
  LOW_THRESHOLD
  OUTER_RANGE
  TEXT_MATCH
}

input TriggerConditionInputType {
  id: Int
  maxValue: Int
  minValue: Int
  questionId: String
  textValue: String
  type: TriggerConditionEnum
}

type TriggerConditionType {
  id: Int
  maxValue: Int
  minValue: Int
  question: QuestionNode
  textValue: String
  triggerId: String
  type: TriggerConditionEnum
}

type TriggerConnectionType implements DeprecatedConnectionInterface {
  cursor: String
  endDate: String
  limit: Int
  offset: Int
  pageInfo: DeprecatedPaginationPageInfo
  startDate: String
  triggers: [TriggerType]
}

input TriggerInputType {
  conditions: [TriggerConditionInputType]
  medium: TriggerMediumEnum
  name: String
  type: TriggerTypeEnum
}

enum TriggerMediumEnum {
  BOTH
  EMAIL
  PHONE
}

type TriggerType {
  conditions: [TriggerConditionType]
  id: String
  medium: TriggerMediumEnum
  name: String
  recipients: [UserType]
  relatedDialogue: Dialogue
  relatedNodeId: String
  type: TriggerTypeEnum
}

enum TriggerTypeEnum {
  QUESTION
  SCHEDULED
}

input UpdateCTAInputType {
  customerId: ID
  customerSlug: String!
  form: FormNodeInputType
  id: String
  links: CTALinksInputType
  share: ShareNodeInputType
  title: String
  type: QuestionNodeTypeEnum
}

input UpdatePermissionsInput {
  permissions: [SystemPermission]
  roleId: String
}

input UpdateQuestionNodeInputType {
  customerId: ID
  edgeCondition: EdgeConditionInputType
  edgeId: ID
  extraContent: String
  happyText: String
  id: ID!
  optionEntries: OptionsInputType
  overrideLeafId: ID
  sliderNode: SliderNodeInputType
  title: String
  type: String
  unhappyText: String
  updateSameTemplate: Boolean = false
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

enum UploadImageEnumType {
  LOGO
  WEBSITE_SCREENSHOT
}

input UploadSellImageInputType {
  file: Upload
  workspaceId: String
}

"""

    An urgent path is a path which was considered urgent. It currently follows a simple heuristic:
    1. Get all sessions of the workspace.
    2. Find sessions with a score below 4. If there is no such session, then no urgency is reported.
    3. Find the topic that has the most negative responses.
  
"""
type UrgentPath {
  basicStats: BasicStatistics
  dialogue: Dialogue
  dialogueId: String!
  id: ID
  path: Path
}

type UserConnection implements ConnectionInterface {
  pageInfo: PaginationPageInfo
  totalPages: Int
  userCustomers: [UserCustomer]
}

input UserConnectionFilterInput {
  email: String
  endDate: String
  firstName: String
  lastName: String
  offset: Int
  orderBy: UserConnectionOrderByInput
  perPage: Int = 10
  role: String
  search: String
  startDate: String
}

"""Fields to order UserConnection by."""
enum UserConnectionOrder {
  createdAt
  email
  firstName
  isActive
  lastActivity
  lastName
  role
}

"""Sorting of UserConnection"""
input UserConnectionOrderByInput {
  by: UserConnectionOrder!
  desc: Boolean = true
}

type UserCustomer {
  createdAt: Date!
  customer: Customer
  isActive: Boolean
  role: RoleType
  user: UserType
}

input UserInput {
  customerId: String
  email: String!
  firstName: String
  lastName: String
  password: String
  phone: String
  roleId: String
}

input UserOfCustomerInput {
  customerId: String
  customerSlug: String
  userId: String
  workspaceId: String
}

type UserType {
  assignedDialogues(input: UserOfCustomerInput): AssignedDialogues
  customers: [Customer]
  email: String
  firstName: String
  globalPermissions: [SystemPermission]
  id: ID!
  lastActivity: Date
  lastLoggedIn: Date
  lastName: String
  phone: String
  role: RoleType
  roleId: String
  userCustomers: [UserCustomer]
}

input VerifyActionRequestInput {
  actionRequestId: String!
  workspaceId: String!
}

type VerifyUserTokenOutput {
  accessToken: String
  accessTokenExpiry: Int
  userData: UserType
}

"""Input type for a video node"""
input VideoNodeEntryInput {
  value: String
}

enum WorkspaceAspectType {
  GENERAL_SCORE
  NR_INTERACTIONS
  NR_VISITORS
}

"""WorkspaceConditionScope"""
type WorkspaceConditionScopeModel {
  aggregate: ConditionPropertyAggregate
  aspect: WorkspaceAspectType
  createdAt: Date
  id: ID
  updatedAt: Date
}

type WorkspaceStatistics {
  """
  Basic statistics of a workspace (e.g. number of responses, average general score, etc)
  """
  basicStats(input: DialogueStatisticsSummaryFilterInput): BasicStatistics

  """Gets the health score of the workspace"""
  health(input: HealthScoreInput): HealthScore
  id: ID

  """Histogram of issues over time."""
  issueHistogram(input: DialogueStatisticsSummaryFilterInput): DateHistogram

  """
  
          Get the path (sequence of topics) with the most changed impact score.
        
  """
  mostChangedPath(input: DialogueStatisticsSummaryFilterInput): MostChangedPath
  mostPopularPath(input: DialogueStatisticsSummaryFilterInput): MostPopularPath
  mostTrendingTopic(input: DialogueStatisticsSummaryFilterInput): MostTrendingTopic

  """
  Topics of a workspace ranked by either impact score or number of responses
  """
  rankedTopics(input: DialogueStatisticsSummaryFilterInput): [TopicType]

  """Histogram of responses over time."""
  responseHistogram(input: DialogueStatisticsSummaryFilterInput): DateHistogram
  workspaceStatisticsSummary(input: DialogueStatisticsSummaryFilterInput): [DialogueStatisticsSummaryModel!]!
}

input createJobProcessLocationInput {
  name: String
  path: String
  type: JobProcessLocationType
}

type lineChartDataType {
  entryId: String
  x: String
  y: Int
}

type topPathType {
  answer: String
  basicSentiment: String
  quantity: Int
}
