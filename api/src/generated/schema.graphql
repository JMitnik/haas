### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


input AdjustedImageInput {
  bucket: String
  id: String
  key: String
  reset: Boolean
}

"""Append new data to an uploaded session"""
input AppendToInteractionInput {
  data: NodeEntryDataInput
  edgeId: String
  nodeId: String
  sessionId: ID
}

input AuthenticateLambdaInput {
  authenticateEmail: String
  workspaceEmail: String
}

type AutodeckConnectionType implements DeprecatedConnectionInterface {
  cursor: String
  endDate: String
  jobs: [CreateWorkspaceJobType!]!
  limit: Int!
  offset: Int
  pageInfo: DeprecatedPaginationPageInfo!
  startDate: String
}

input AutomationActionInput {
  apiKey: String
  endpoint: String
  id: ID
  payload: JSONObject
  type: AutomationActionType
}

"""AutomationAction"""
type AutomationActionModel {
  createdAt: Date!
  id: ID!
  type: AutomationActionType!
  updatedAt: Date!
}

enum AutomationActionType {
  API_CALL
  GENERATE_REPORT
  SEND_EMAIL
  SEND_SMS
  WEBHOOK
}

input AutomationConditionBuilderInput {
  childConditionBuilder: AutomationConditionBuilderInput
  conditions: [CreateAutomationCondition!]
  id: ID
  type: AutomationConditionBuilderType
}

"""AutomationConditionBuilder"""
type AutomationConditionBuilderModel {
  childConditionBuilder: AutomationConditionBuilderModel
  childConditionBuilderId: String
  conditions: [AutomationConditionModel!]!
  id: ID!
  type: AutomationConditionBuilderType!
}

enum AutomationConditionBuilderType {
  AND
  OR
}

"""AutomationCondition"""
type AutomationConditionModel {
  createdAt: Date!
  dialogue: Dialogue
  dialogueScope: DialogueConditionScopeModel
  id: ID!
  operands: [AutomationConditionOperandModel!]!
  operator: AutomationConditionOperatorType!
  question: QuestionNode
  questionScope: QuestionConditionScopeModel
  scope: AutomationConditionScopeType!
  updatedAt: Date!
  workspaceScope: WorkspaceConditionScopeModel
}

"""AutomationConditionOperand"""
type AutomationConditionOperandModel {
  createdAt: Date!
  dateTimeValue: String
  id: ID!
  numberValue: Int
  textValue: String
  type: OperandType!
  updatedAt: Date!
}

enum AutomationConditionOperatorType {
  EVERY_N_TH_TIME
  GREATER_OR_EQUAL_THAN
  GREATER_THAN
  INNER_RANGE
  IS_EQUAL
  IS_FALSE
  IS_NOT_EQUAL
  IS_TRUE
  OUTER_RANGE
  SMALLER_OR_EQUAL_THAN
  SMALLER_THAN
}

enum AutomationConditionScopeType {
  DIALOGUE
  QUESTION
  WORKSPACE
}

type AutomationConnection implements ConnectionInterface {
  automations: [AutomationModel!]!
  pageInfo: PaginationPageInfo!
  totalPages: Int
}

input AutomationConnectionFilterInput {
  label: String
  offset: Int
  orderBy: AutomationConnectionOrderByInput
  perPage: Int = 10
  search: String
  type: AutomationType
}

"""Sorting of UserConnection"""
input AutomationConnectionOrderByInput {
  by: AutomationConnectionOrderType!
  desc: Boolean = true
}

"""Fields to order UserConnection by."""
enum AutomationConnectionOrderType {
  type
  updatedAt
}

input AutomationEventInput {
  dialogueId: String
  eventType: AutomationEventType
  id: ID
  questionId: String
}

"""AutomationEvent"""
type AutomationEventModel {
  createdAt: Date!
  dialogue: Dialogue
  endDate: String
  id: ID!
  periodType: RecurringPeriodType
  question: QuestionNode
  startDate: String
  type: AutomationEventType!
  updatedAt: Date!
}

enum AutomationEventType {
  API_CALL
  NEW_INTERACTION_DIALOGUE
  NEW_INTERACTION_QUESTION
  RECURRING
}

"""Automation"""
type AutomationModel {
  automationTrigger: AutomationTriggerModel
  createdAt: Date!
  description: String
  id: ID!
  isActive: Boolean!
  label: String!
  type: AutomationType!
  updatedAt: Date!
  workspace: Customer
}

"""AutomationTrigger"""
type AutomationTriggerModel {
  actions: [AutomationActionModel!]!
  conditionBuilder: AutomationConditionBuilderModel
  createdAt: Date!
  event: AutomationEventModel!
  id: ID!
  updatedAt: Date!
}

enum AutomationType {
  CAMPAIGN
  TRIGGER
}

type AWSImageType {
  encoding: String
  filename: String
  mimetype: String
  url: String
}

"""Campaign"""
type CampaignType {
  deliveryConnection(filter: DeliveryConnectionFilterInput): DeliveryConnectionType
  id: ID!
  label: String!
  variants: [CampaignVariantType!]
}

type CampaignVariantCustomVariableType {
  id: ID!
  key: String!
}

enum CampaignVariantEnum {
  EMAIL
  QUEUE
  SMS
}

"""Variant of campaign"""
type CampaignVariantType {
  body: String!
  campaign: CampaignType
  customVariables: [CampaignVariantCustomVariableType!]
  deliveryConnection: DeliveryConnectionType
  dialogue: Dialogue
  from: String
  id: ID!
  label: String!
  type: CampaignVariantEnum!
  weight: Int!
  workspace: Customer
}

"""Input type for a choice node"""
input ChoiceNodeEntryInput {
  value: String
}

enum CloudReferenceType {
  AWS
  Azure
  GCP
  IBM
}

type ColourSettings {
  id: ID!
  primary: String!
  primaryAlt: String
  secondary: String
}

input ConditionDialogueScopeInput {
  aggregate: ConditionPropertyAggregateInput
  aspect: DialogueAspectType
  id: ID
}

type ConditionPropertyAggregate {
  createdAt: String!
  endDate: String
  id: ID!
  latest: Int
  startDate: String
  type: ConditionPropertyAggregateType!
}

input ConditionPropertyAggregateInput {
  endDate: String
  id: ID
  latest: Int
  startDate: String
  type: ConditionPropertyAggregateType
}

enum ConditionPropertyAggregateType {
  AVG
  COUNT
  MAX
  MIN
}

input ConditionQuestionScopeInput {
  aggregate: ConditionPropertyAggregateInput
  aspect: QuestionAspectType
  id: ID
}

input ConditionScopeInput {
  dialogueScope: ConditionDialogueScopeInput
  id: ID
  questionScope: ConditionQuestionScopeInput
  type: AutomationConditionScopeType
  workspaceScope: ConditionWorkspaceScopeInput
}

input ConditionWorkspaceScopeInput {
  aggregate: ConditionPropertyAggregateInput
  aspect: WorkspaceAspectType
  id: ID
}

"""Interface all pagination-based models should implement"""
interface ConnectionInterface {
  pageInfo: PaginationPageInfo!
  totalPages: Int
}

input CreateAutomationCondition {
  dialogueId: String
  id: ID
  operands: [CreateAutomationOperandInput!]
  operator: AutomationConditionOperatorType
  questionId: String
  scope: ConditionScopeInput
  workspaceId: String
}

input CreateAutomationInput {
  actions: [AutomationActionInput!]
  automationType: AutomationType
  conditionBuilder: AutomationConditionBuilderInput
  description: String
  event: AutomationEventInput
  id: ID
  label: String
  workspaceId: String
}

input CreateAutomationOperandInput {
  dateTimeValue: String
  id: ID
  numberValue: Int
  operandType: OperandType
  textValue: String
}

input CreateBatchDeliveriesInputType {
  batchScheduledAt: String
  campaignId: ID
  uploadedCsv: Upload
  workspaceId: String
}

type CreateBatchDeliveriesOutputType {
  failedDeliveries: [FailedDeliveryModel!]!
  nrDeliveries: Int!
}

input CreateCampaignCustomVariable {
  key: String
}

input CreateCampaignInputType {
  label: String
  variants: [CreateCampaignVariantInputType!]
  workspaceId: ID!
}

input CreateCampaignVariantInputType {
  body: String
  customVariables: [CreateCampaignCustomVariable!]
  dialogueId: ID!
  from: String
  label: String
  subject: String
  type: CampaignVariantEnum!
  weight: Float
  workspaceId: ID!
}

input CreateCTAInputType {
  customerSlug: String
  dialogueSlug: String
  form: FormNodeInputType
  links: CTALinksInputType

  """Linked question-node id"""
  questionId: String
  share: ShareNodeInputType
  title: String
  type: String
}

input CreateDialogueInputType {
  contentType: String
  customerSlug: String
  description: String
  dialogueSlug: String
  isSeed: Boolean
  language: LanguageEnumType
  publicTitle: String
  tags: TagsInputObjectType
  templateDialogueId: String
  title: String
}

input createJobProcessLocationInput {
  name: String
  path: String
  type: JobProcessLocationType
}

input CreateQuestionNodeInputType {
  customerId: ID
  dialogueSlug: String
  edgeCondition: EdgeConditionInputType
  extraContent: String
  happyText: String
  optionEntries: OptionsInputType
  overrideLeafId: ID
  parentQuestionId: ID
  title: String
  type: String
  unhappyText: String
}

input CreateTriggerInputType {
  customerSlug: String
  recipients: RecipientsInputType
  trigger: TriggerInputType
}

"""Creates a workspace"""
input CreateWorkspaceInput {
  isSeed: Boolean = false
  logo: String
  logoOpacity: Int
  name: String!
  primaryColour: String!
  slug: String!
  willGenerateFakeData: Boolean = false
}

type CreateWorkspaceJobType {
  createdAt: String!
  errorMessage: String
  id: String!
  message: String
  name: String!
  processLocation: JobProcessLocation!
  referenceId: String
  referenceType: CloudReferenceType!
  requiresColorExtraction: Boolean!
  requiresRembg: Boolean!
  requiresScreenshot: Boolean!
  resourcesUrl: String
  status: JobStatusType!
  updatedAt: String
}

input CTALinkInputObjectType {
  backgroundColor: String
  buttonText: String
  header: String
  iconUrl: String
  id: String
  imageUrl: String
  subHeader: String
  title: String
  type: LinkTypeEnumType
  url: String
}

input CTALinksInputType {
  linkTypes: [CTALinkInputObjectType!]
}

input CTAShareInputObjectType {
  id: String
  title: String
  tooltip: String
  url: String
}

type Customer {
  automationConnection(filter: AutomationConnectionFilterInput): AutomationConnection
  automations: [AutomationModel!]
  campaign(campaignId: String): CampaignType
  campaigns: [CampaignType!]!
  dialogue(where: DialogueWhereUniqueInput): Dialogue
  dialogues(filter: DialogueFilterInputType): [Dialogue!]
  id: ID!
  name: String!
  roles: [RoleType!]
  settings: CustomerSettings
  slug: String!
  userCustomer(userId: String): UserCustomer
  users: [UserType!]
  usersConnection(customerSlug: String, filter: UserConnectionFilterInput): UserConnection
}

type CustomerSettings {
  colourSettings: ColourSettings
  fontSettings: FontSettings
  id: ID!
  logoOpacity: Int
  logoUrl: String
}

input CustomerWhereUniqueInput {
  id: ID!
}

input CustomFieldInputType {
  key: String
  value: String
}

type CustomFieldType {
  id: String!
  jobProcessLocationId: String!
  key: String!
  value: String
}

"""Date custom scalar type"""
scalar Date

input DeleteDialogueInputType {
  customerSlug: String
  id: ID
}

"""Delete Node Input type"""
input DeleteNodeInputType {
  customerId: ID
  dialogueSlug: String
  id: String
}

input DeleteUserInput {
  customerId: ID
  userId: ID
}

type DeleteUserOutput {
  deletedUser: Boolean!
}

input DeliveryConnectionFilterInput {
  campaignVariantId: String
  endDate: String
  offset: Int
  orderBy: DeliveryConnectionOrderByInput
  perPage: Int = 10
  recipientEmail: String
  recipientFirstName: String
  recipientLastName: String
  recipientPhoneNumber: String
  search: String
  startDate: String
  status: DeliveryStatusEnum
}

"""Fields to order DeliveryConnection by."""
enum DeliveryConnectionOrder {
  createdAt
}

"""Sorting of DeliveryConnection"""
input DeliveryConnectionOrderByInput {
  by: DeliveryConnectionOrder!
  desc: Boolean = true
}

type DeliveryConnectionType implements ConnectionInterface {
  deliveries: [DeliveryType!]!
  pageInfo: PaginationPageInfo!
  totalPages: Int
}

type DeliveryEventType {
  createdAt: Date!
  failureMessage: String
  id: ID!
  status: DeliveryStatusEnum!
}

enum DeliveryStatusEnum {
  DELIVERED
  DEPLOYED
  FAILED
  FINISHED
  OPENED
  SCHEDULED
  SENT
}

"""Delivery"""
type DeliveryType {
  campaignVariant: CampaignVariantType
  createdAt: Date
  currentStatus: DeliveryStatusEnum!
  deliveryRecipientEmail: String
  deliveryRecipientFirstName: String
  deliveryRecipientLastName: String
  deliveryRecipientPhone: String
  events: [DeliveryEventType!]
  id: ID!
  scheduledAt: Date
  updatedAt: Date
}

"""Interface all pagination-based models should implement"""
interface DeprecatedConnectionInterface {
  cursor: String
  endDate: String
  limit: Int!
  offset: Int
  pageInfo: DeprecatedPaginationPageInfo!
  startDate: String
}

"""Information with regards to current page, and total number of pages"""
type DeprecatedPaginationPageInfo {
  cursor: String
  nrPages: Int!
  pageIndex: Int!
}

type Dialogue {
  averageScore(input: DialogueFilterInputType): Float!
  campaignVariants: [CampaignVariantType!]!
  creationDate: String
  customer: Customer
  customerId: String!
  description: String!
  dialogueStatisticsSummary(input: DialogueStatisticsSummaryFilterInput): DialogueStatisticsSummaryModel
  edges: [Edge!]!
  id: ID!
  isWithoutGenData: Boolean!
  language: LanguageEnumType!
  leafs(searchTerm: String): [QuestionNode!]!
  pathedSessions(input: PathedSessionsInput): PathedSessionsType
  postLeafNode: DialogueFinisherObjectType
  publicTitle: String
  questions: [QuestionNode!]!
  rootQuestion: QuestionNode!
  sessionConnection(filter: SessionConnectionFilterInput): SessionConnection
  sessions(take: Int): [Session!]!
  slug: String!
  statistics(input: DialogueFilterInputType): DialogueStatistics
  tags: [Tag!]
  title: String!
  topic(input: TopicInputType): TopicType!
  updatedAt: String
  wasGeneratedWithGenData: Boolean!
}

enum DialogueAspectType {
  GENERAL_SCORE
  LATEST_SCORE
  NR_INTERACTIONS
  NR_VISITORS
}

"""DialogueConditionScope"""
type DialogueConditionScopeModel {
  aggregate: ConditionPropertyAggregate
  aspect: DialogueAspectType!
  createdAt: Date!
  id: ID!
  updatedAt: Date!
}

input DialogueFilterInputType {
  endDate: String
  searchTerm: String
  startDate: String
}

type DialogueFinisherObjectType {
  header: String!
  id: ID!
  subtext: String!
}

enum DialogueImpactScoreType {
  AVERAGE
}

type DialogueStatistics {
  history: [lineChartDataType!]
  mostPopularPath: topPathType
  nrInteractions: Int!
  topNegativePath: [topPathType!]
  topPositivePath: [topPathType!]
}

input DialogueStatisticsSummaryFilterInput {
  endDateTime: String
  impactType: DialogueImpactScoreType!
  refresh: Boolean
  startDateTime: String!
}

"""DialogueStatisticsSummary"""
type DialogueStatisticsSummaryModel {
  dialogue: Dialogue
  dialogueId: String!
  endDateTime: Date
  id: ID!
  impactScore: Float
  nrVotes: Int
  startDateTime: Date
  updatedAt: Date
}

input DialogueWhereUniqueInput {
  id: ID
  slug: String
}

type Edge {
  childNode: QuestionNode
  childNodeId: String!
  conditions: [EdgeCondition!]
  createdAt: String!
  id: ID!
  parentNode: QuestionNode
  parentNodeId: String!
  updatedAt: String!
}

type EdgeCondition {
  conditionType: String!
  edgeId: String
  id: Int!
  matchValue: String
  renderMax: Int
  renderMin: Int
}

input EdgeConditionInputType {
  conditionType: String
  id: Int
  matchValue: String
  renderMax: Int
  renderMin: Int
}

input EditUserInput {
  customerId: String
  email: String!
  firstName: String
  lastName: String
  phone: String
  roleId: String
}

"""Edit a workspace"""
input EditWorkspaceInput {
  customerSlug: String!
  id: ID!
  logo: String
  logoOpacity: Int
  name: String!
  primaryColour: String!
  slug: String!
}

type FailedDeliveryModel {
  error: String!
  record: String!
}

input FindRoleInput {
  roleId: String
  userId: String
}

type FontSettings {
  id: ID!
}

"""FormNodeEntryInput"""
input FormNodeEntryFieldInput {
  email: String
  longText: String
  number: Int
  phoneNumber: String
  relatedFieldId: ID
  shortText: String
  url: String
}

"""FormNodeEntryInput"""
input FormNodeEntryInput {
  values: [FormNodeEntryFieldInput!]
}

type FormNodeEntryType {
  id: Int!
  values: [FormNodeEntryValueType!]!
}

type FormNodeEntryValueType {
  email: String
  longText: String
  number: Int
  phoneNumber: String
  relatedField: FormNodeField!
  shortText: String
  url: String
}

type FormNodeField {
  id: ID!
  isRequired: Boolean!
  label: String!
  placeholder: String
  position: Int!
  type: FormNodeFieldTypeEnum!
}

input FormNodeFieldInput {
  id: ID
  isRequired: Boolean = false
  label: String
  placeholder: String
  position: Int
  type: FormNodeFieldTypeEnum
}

"""The types a field can assume"""
enum FormNodeFieldTypeEnum {
  email
  longText
  number
  phoneNumber
  shortText
  url
}

input FormNodeInputType {
  fields: [FormNodeFieldInput!]
  helperText: String
  id: String
}

type FormNodeType {
  fields: [FormNodeField!]!
  helperText: String
  id: String
}

"""Generate savales documents"""
input GenerateAutodeckInput {
  answer1: String
  answer2: String
  answer3: String
  answer4: String
  companyName: String
  customFields: [CustomFieldInputType!]
  emailContent: String
  firstName: String
  id: String!
  isGenerateWorkspace: Boolean
  jobLocationId: String
  logo: String
  name: String
  newCustomFields: [CustomFieldInputType!]
  primaryColour: String
  requiresColorExtraction: Boolean!
  requiresRembgLambda: Boolean!
  requiresWebsiteScreenshot: Boolean!
  reward: String
  slug: String
  sorryAboutX: String
  standardFields: [CustomFieldInputType!]
  textMessage: String
  usesAdjustedLogo: Boolean!
  website: String
  youLoveX: String
}

input GetAutomationInput {
  id: String
}

input GetAutomationsByWorkspaceInput {
  workspaceId: String
}

input GetCampaignsInput {
  customerSlug: String
}

input HandleUserStateInWorkspaceInput {
  isActive: Boolean
  userId: String
  workspaceId: String
}

type ImageType {
  encoding: String
  filename: String
  mimetype: String
  url: String
}

type IndepthQuestionStatisticsSummary {
  impactScore: Float
  nrVotes: Int
  option: String
}

input InviteUserInput {
  customerId: String!
  email: String!
  roleId: String!
}

type InviteUserOutput {
  didAlreadyExist: Boolean!
  didInvite: Boolean!
}

type JobObjectType {
  createdAt: String!
  createWorkspaceJob: CreateWorkspaceJobType
  createWorkspaceJobId: String!
  id: String!
  updatedAt: String!
}

type JobProcessLocation {
  customFields: [CustomFieldType!]
  id: String!
  name: String!
  path: String!
  type: JobProcessLocationType!
  xMaterialDimension: Int!
  yMaterialDimension: Int!
}

type JobProcessLocations {
  jobProcessLocations: [JobProcessLocation!]!
}

enum JobProcessLocationType {
  BROCHURE
  ONE_PAGER
  PITCHDECK
}

enum JobStatusType {
  COMPLETED
  COMPRESSING_SALES_MATERIAL
  FAILED
  IN_PHOTOSHOP_QUEUE
  PENDING
  PHOTOSHOP_PROCESSING
  PRE_PROCESSING
  PRE_PROCESSING_LOGO
  PRE_PROCESSING_WEBSITE_SCREENSHOT
  PROCESSING
  READY_FOR_PROCESSING
  STITCHING_SLIDES
  TRANSFORMING_PSDS_TO_PNGS
  WRAPPING_UP
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

enum LanguageEnumType {
  DUTCH
  ENGLISH
  GERMAN
}

type lineChartDataType {
  entryId: String
  x: String
  y: Int
}

type LinkType {
  backgroundColor: String
  buttonText: String
  header: String
  iconUrl: String
  id: String!
  imageUrl: String
  questionNode: QuestionNode!
  questionNodeId: String
  subHeader: String
  title: String
  type: String!
  url: String!
}

enum LinkTypeEnumType {
  API
  FACEBOOK
  INSTAGRAM
  LINKEDIN
  SINGLE
  SOCIAL
  TWITTER
  WHATSAPP
}

"""Login credential"""
input LoginInput {
  email: String!
}

"""Information you get after you log out"""
type LoginOutput {
  expiryDate: Int!
  token: String!
  user: UserType!
}

input MassSeedInput {
  customerId: String!
  maxGroups: Int!
  maxSessions: Int!
  maxTeams: Int!
}

type Mutation {
  appendToInteraction(input: AppendToInteractionInput): Session!
  assignTags(dialogueId: String, tags: TagsInputObjectType): Dialogue!
  authenticateLambda(input: AuthenticateLambdaInput): String
  confirmCreateWorkspaceJob(input: GenerateAutodeckInput): CreateWorkspaceJobType
  copyDialogue(input: CreateDialogueInputType): Dialogue!

  """Creates a new automation."""
  createAutomation(input: CreateAutomationInput): AutomationModel!
  createAutomationToken(email: String): String
  createBatchDeliveries(input: CreateBatchDeliveriesInputType): CreateBatchDeliveriesOutputType!
  createCampaign(input: CreateCampaignInputType): CampaignType!

  """Create Call to Actions"""
  createCTA(input: CreateCTAInputType): QuestionNode!
  createDialogue(input: CreateDialogueInputType): Dialogue!
  createJobProcessLocation(input: createJobProcessLocationInput): JobProcessLocation!
  createPermission(data: PermissionInput): PermssionType
  createQuestion(input: CreateQuestionNodeInputType): QuestionNode
  createRole(data: RoleInput): RoleType!
  createSession(input: SessionInput): Session!
  createTag(customerSlug: String, name: String, type: TagTypeEnum): Tag!
  createTrigger(input: CreateTriggerInputType): TriggerType!
  createWorkspace(input: CreateWorkspaceInput): Customer!
  deleteCTA(input: DeleteNodeInputType): QuestionNode!
  deleteCustomer(where: CustomerWhereUniqueInput): Customer
  deleteDialogue(input: DeleteDialogueInputType): Dialogue!
  deleteQuestion(input: DeleteNodeInputType): QuestionNode!
  deleteTag(tagId: String): Tag!
  deleteTrigger(customerSlug: String, id: String): TriggerType
  deleteUser(input: DeleteUserInput): DeleteUserOutput!
  duplicateQuestion(questionId: String): QuestionNode
  editDialogue(customerSlug: String, description: String, dialogueFinisherHeading: String, dialogueFinisherSubheading: String, dialogueSlug: String, isWithoutGenData: Boolean, language: LanguageEnumType, publicTitle: String, tags: TagsInputObjectType, title: String): Dialogue!
  editTrigger(customerSlug: String, recipients: RecipientsInputType, trigger: TriggerInputType, triggerId: String): TriggerType!
  editUser(input: EditUserInput, userId: String): UserType!
  editWorkspace(input: EditWorkspaceInput): Customer!
  generateAutodeck(input: GenerateAutodeckInput): CreateWorkspaceJobType
  handleUserStateInWorkspace(input: HandleUserStateInWorkspaceInput): UserCustomer!

  """Invite a user to a particular customer domain, given an email and role"""
  inviteUser(input: InviteUserInput): InviteUserOutput!

  """Logs a user out by removing their refresh token"""
  logout: String!
  massSeed(input: MassSeedInput): Customer
  register(input: RegisterInput): String
  removePixelRange(input: RemovePixelRangeInput): AWSImageType
  requestInvite(input: RequestInviteInput): RequestInviteOutput!
  retryAutodeckJob(jobId: String): CreateWorkspaceJobType
  singleUpload(file: Upload): ImageType!
  updateAutomation(input: CreateAutomationInput): AutomationModel!
  updateCreateWorkspaceJob(errorMessage: String, id: String, referenceId: String, resourceUrl: String, status: JobStatusType): CreateWorkspaceJobType
  updateCTA(input: UpdateCTAInputType): QuestionNode!
  updateDeliveryStatus(deliveryId: String, status: DeliveryStatusEnum): String!
  updatePermissions(input: UpdatePermissionsInput): RoleType
  updateQuestion(input: UpdateQuestionNodeInputType): QuestionNode!
  updateRoles(permissions: PermissionIdsInput, roleId: String): RoleType!
  uploadJobImage(disapproved: Boolean, file: Upload, jobId: String, type: UploadImageEnumType): AWSImageType
  uploadUpsellImage(input: UploadSellImageInputType): ImageType

  """
  Given a token, checks in the database whether token has been set and has not expired yet
  """
  verifyUserToken(token: String): VerifyUserTokenOutput!
  whitifyImage(input: AdjustedImageInput): AWSImageType
}

type NodeEntry {
  creationDate: String!
  depth: Int
  id: ID
  relatedEdgeId: String
  relatedNode: QuestionNode
  relatedNodeId: String

  """The core scoring value associated with the node entry."""
  value: NodeEntryValue
}

"""Data type for the actual node entry"""
input NodeEntryDataInput {
  choice: ChoiceNodeEntryInput
  form: FormNodeEntryInput
  register: RegisterNodeEntryInput
  slider: SliderNodeEntryInput
  textbox: TextboxNodeEntryInput
  video: VideoNodeEntryInput
}

"""Input type for node-entry metadata"""
input NodeEntryInput {
  data: NodeEntryDataInput
  depth: Int
  edgeId: String
  nodeId: String
}

type NodeEntryValue {
  choiceNodeEntry: String
  formNodeEntry: FormNodeEntryType
  linkNodeEntry: String
  registrationNodeEntry: String
  sliderNodeEntry: Int
  textboxNodeEntry: String
  videoNodeEntry: String
}

enum OperandType {
  DATE_TIME
  INT
  STRING
}

input OptionInputType {
  id: Int
  overrideLeafId: String
  position: Int!
  publicValue: String
  value: String
}

input OptionsInputType {
  options: [OptionInputType!]
}

"""Information with regards to current page."""
type PaginationPageInfo {
  hasNextPage: Boolean!
  hasPrevPage: Boolean!
  nextPageOffset: Int!
  pageIndex: Int!
  prevPageOffset: Int!
}

"""Fields that can be used for free text search on tables"""
enum PaginationSearchEnum {
  email
  firstName
  lastName
  name
  publicTitle
  title
}

"""Ways to sort a pagination object"""
enum PaginationSortByEnum {
  createdAt
  email
  firstName
  id
  lastName
  medium
  name
  paths
  role
  scheduledAt
  score
  type
  updatedAt
  user
  when
}

"""Sorting of pagination (type and whether it ascends)"""
input PaginationSortInput {
  by: PaginationSortByEnum!
  desc: Boolean = true
}

input PaginationWhereInput {
  cursor: String
  endDate: String
  limit: Int
  offset: Int
  orderBy: [PaginationSortInput!]
  pageIndex: Int
  search: String
  searchTerm: String
  startDate: String
}

input PathedSessionsInput {
  endDateTime: String
  path: [String!]!
  refresh: Boolean = false
  startDateTime: String!
}

type PathedSessionsType {
  endDateTime: String!
  id: String!
  path: [String!]!
  pathedSessions: [Session!]!
  startDateTime: String!
  updatedAt: String!
}

input PermissionIdsInput {
  ids: [String!]
}

input PermissionInput {
  customerId: String
  description: String
  name: String
}

type PermssionType {
  customer: Customer
  description: String
  id: ID!
  name: String!
}

type PreviewDataType {
  colors: [String!]!
  rembgLogoUrl: String!
  websiteScreenshotUrl: String!
}

type Query {
  automation(where: GetAutomationInput): AutomationModel
  automations(where: GetAutomationsByWorkspaceInput): [AutomationModel!]!
  customer(id: ID, slug: String): Customer
  customers: [Customer!]!
  delivery(deliveryId: String): DeliveryType
  dialogue(where: DialogueWhereUniqueInput): Dialogue
  dialogues(filter: DialogueFilterInputType): [Dialogue!]!
  edge(id: String): Edge
  getAdjustedLogo(input: AdjustedImageInput): AWSImageType
  getAutodeckJobs(filter: PaginationWhereInput): AutodeckConnectionType!
  getJob(id: String): CreateWorkspaceJobType
  getJobProcessLocations: JobProcessLocations!
  getPreviewData(id: String): PreviewDataType
  me: UserType!
  question(where: QuestionWhereUniqueInput): QuestionNode
  refreshAccessToken: RefreshAccessTokenOutput!
  role(input: FindRoleInput): RoleType
  roleConnection(customerId: String, filter: PaginationWhereInput): RoleConnection!

  """A session is one entire user-interaction"""
  session(id: String): Session
  sessions(where: SessionWhereUniqueInput): [Session!]!
  tags(customerSlug: String, dialogueId: String): [Tag!]!
  trigger(triggerId: String): TriggerType
  triggerConnection(customerSlug: String, filter: PaginationWhereInput): TriggerConnectionType
  triggers(customerSlug: String, dialogueId: String, filter: PaginationWhereInput, userId: String): [TriggerType!]!
  user(userId: String): UserType
  UserOfCustomer(input: UserOfCustomerInput): UserCustomer
  users(customerSlug: String): [UserType!]!
}

enum QuestionAspectType {
  ANSWER_SPEED
  NODE_VALUE
}

"""QuestionConditionScope"""
type QuestionConditionScopeModel {
  aggregate: ConditionPropertyAggregate
  aspect: QuestionAspectType!
  createdAt: Date!
  id: ID!
}

enum QuestionImpactScoreType {
  PERCENTAGE
}

type QuestionNode {
  children: [Edge!]!
  creationDate: String
  extraContent: String

  """FormNode resolver"""
  form: FormNodeType
  id: ID!
  indepthQuestionStatisticsSummary(input: QuestionStatisticsSummaryFilterInput): [IndepthQuestionStatisticsSummary!]
  isLeaf: Boolean!
  isRoot: Boolean!
  links: [LinkType!]!
  options: [QuestionOption!]!
  overrideLeaf: QuestionNode
  overrideLeafId: String
  questionDialogue: Dialogue
  questionDialogueId: String
  questionStatisticsSummary(input: QuestionStatisticsSummaryFilterInput): QuestionStatisticsSummary
  share: ShareNodeType

  """Slidernode resolver"""
  sliderNode: SliderNodeType
  title: String!
  type: QuestionNodeTypeEnum!
  updatedAt: String
}

"""The different types a node can assume"""
enum QuestionNodeTypeEnum {
  CHOICE
  FORM
  GENERIC
  LINK
  REGISTRATION
  SHARE
  SLIDER
  TEXTBOX
  VIDEO_EMBEDDED
}

input QuestionNodeWhereInputType {
  id: ID
  isRoot: Boolean
}

input QuestionNodeWhereUniqueInput {
  id: String!
}

type QuestionOption {
  id: Int!
  overrideLeaf: QuestionNode
  position: Int
  publicValue: String
  questionId: String
  value: String!
}

type QuestionStatisticsSummary {
  dialogueId: String
  endDateTime: Date
  id: ID
  startDateTime: Date
  updatedAt: Date
}

input QuestionStatisticsSummaryFilterInput {
  endDateTime: String
  impactTreshold: Int
  impactType: QuestionImpactScoreType!
  refresh: Boolean
  startDateTime: String!
}

input QuestionWhereUniqueInput {
  id: ID!
}

input RecipientsInputType {
  ids: [String!]
}

enum RecurringPeriodType {
  END_OF_DAY
  END_OF_WEEK
  EVERY_DAY
  EVERY_WEEK
  START_OF_DAY
  START_OF_WEEK
}

type RefreshAccessTokenOutput {
  accessToken: String!
}

"""Registration credentials"""
input RegisterInput {
  customerId: String!
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  roleId: String
}

"""Input type for a register node"""
input RegisterNodeEntryInput {
  value: String
}

input RemovePixelRangeInput {
  blue: Int
  bucket: String
  green: Int
  key: String
  range: Int
  red: Int
}

input RequestInviteInput {
  email: String!
}

type RequestInviteOutput {
  didInvite: Boolean!
  userExists: Boolean!
}

type RoleConnection implements DeprecatedConnectionInterface {
  cursor: String
  endDate: String
  limit: Int!
  offset: Int
  pageInfo: DeprecatedPaginationPageInfo!
  roles: [RoleType!]!
  startDate: String
}

input RoleDataInput {
  description: String
  name: String
}

input RoleInput {
  customerId: String
  description: String
  name: String
  permissions: [SystemPermission!]
}

type RoleType {
  allPermissions: [SystemPermission!]!
  customerId: String
  id: ID!
  name: String!
  nrPermissions: Int
  permissions: [SystemPermission!]
  roleId: String
}

type Session {
  browser: String!
  createdAt: Date!
  delivery: DeliveryType
  deliveryId: String
  device: String
  dialogueId: String!
  id: ID!
  mainScore: Float!
  nodeEntries: [NodeEntry!]!
  originUrl: String
  paths: Int!
  score: Float!
  totalTimeInSec: Int
}

type SessionConnection implements ConnectionInterface {
  pageInfo: PaginationPageInfo!
  sessions: [Session!]!
  totalPages: Int
}

input SessionConnectionFilterInput {
  campaignVariantId: String
  deliveryType: SessionDeliveryType
  endDate: String
  offset: Int
  orderBy: SessionConnectionOrderByInput
  perPage: Int = 10
  scoreRange: SessionScoreRangeFilter
  search: String
  startDate: String
}

"""Fields to order SessionConnection by."""
enum SessionConnectionOrder {
  createdAt
}

"""Sorting of sessionConnection"""
input SessionConnectionOrderByInput {
  by: SessionConnectionOrder!
  desc: Boolean = true
}

"""Delivery type of session to filter by."""
enum SessionDeliveryType {
  campaigns
  noCampaigns
}

"""Input for session"""
input SessionInput {
  createdAt: String
  deliveryId: String
  device: String
  dialogueId: String!
  entries: [NodeEntryInput!]
  originUrl: String
  totalTimeInSec: Int
}

"""Scores to filter sessions by."""
input SessionScoreRangeFilter {
  max: Int
  min: Int
}

input SessionWhereUniqueInput {
  dialogueId: ID
  id: ID
}

input ShareNodeInputType {
  id: String
  title: String
  tooltip: String
  url: String
}

type ShareNodeType {
  createdAt: String
  id: String!
  title: String!
  tooltip: String
  updatedAt: String
  url: String!
}

input SlideNodeMarkerInput {
  id: ID
  label: String!
  range: SliderNodeRangeInputType
  subLabel: String!
}

"""Input type for a slider node"""
input SliderNodeEntryInput {
  value: Int
}

input SliderNodeInputType {
  id: ID
  markers: [SlideNodeMarkerInput!]
}

type SliderNodeMarkerType {
  id: ID!
  label: String!
  range: SliderNodeRangeType
  subLabel: String!
}

input SliderNodeRangeInputType {
  end: Float
  start: Float
}

type SliderNodeRangeType {
  end: Float
  id: ID!
  start: Float
}

type SliderNodeType {
  happyText: String
  id: ID
  markers: [SliderNodeMarkerType!]
  unhappyText: String
}

"""Details regarding interaction with social node"""
input SocialNodeEntryInput {
  visitedLink: String
}

enum SystemPermission {
  CAN_ACCESS_ADMIN_PANEL
  CAN_ACCESS_REPORT_PAGE
  CAN_ADD_USERS
  CAN_BUILD_DIALOGUE
  CAN_CREATE_AUTOMATIONS
  CAN_CREATE_CAMPAIGNS
  CAN_CREATE_DELIVERIES
  CAN_CREATE_TRIGGERS
  CAN_DELETE_DIALOGUE
  CAN_DELETE_TRIGGERS
  CAN_DELETE_USERS
  CAN_DELETE_WORKSPACE
  CAN_DOWNLOAD_REPORTS
  CAN_EDIT_DIALOGUE
  CAN_EDIT_USERS
  CAN_EDIT_WORKSPACE
  CAN_UPDATE_AUTOMATIONS
  CAN_VIEW_AUTOMATIONS
  CAN_VIEW_CAMPAIGNS
  CAN_VIEW_DIALOGUE
  CAN_VIEW_DIALOGUE_ANALYTICS
  CAN_VIEW_USERS
}

type Tag {
  customerId: String!
  id: ID!
  name: String!
  type: TagTypeEnum!
}

input TagsInputObjectType {
  entries: [String!]
}

enum TagTypeEnum {
  AGENT
  DEFAULT
  LOCATION
}

"""Input type for a textbox node"""
input TextboxNodeEntryInput {
  value: String
}

input TopicInputType {
  endDateTime: String
  impactScoreType: DialogueImpactScoreType!
  isRoot: Boolean = false
  refresh: Boolean
  startDateTime: String!
  value: String!
}

type TopicNodeEntryValue {
  id: Int!
  mainScore: Int!
  nodeEntryId: String!
  value: String!
}

type TopicType {
  impactScore: Float!
  name: String!
  nrVotes: Int!
  subTopics: [TopicType!]
}

type topPathType {
  answer: String
  basicSentiment: String
  quantity: Int
}

enum TriggerConditionEnum {
  HIGH_THRESHOLD
  INNER_RANGE
  LOW_THRESHOLD
  OUTER_RANGE
  TEXT_MATCH
}

input TriggerConditionInputType {
  id: Int
  maxValue: Int
  minValue: Int
  questionId: String
  textValue: String
  type: TriggerConditionEnum
}

type TriggerConditionType {
  id: Int!
  maxValue: Int
  minValue: Int
  question: QuestionNode
  textValue: String
  triggerId: String!
  type: TriggerConditionEnum!
}

type TriggerConnectionType implements DeprecatedConnectionInterface {
  cursor: String
  endDate: String
  limit: Int!
  offset: Int
  pageInfo: DeprecatedPaginationPageInfo!
  startDate: String
  triggers: [TriggerType!]!
}

input TriggerInputType {
  conditions: [TriggerConditionInputType!]
  medium: TriggerMediumEnum
  name: String
  type: TriggerTypeEnum
}

enum TriggerMediumEnum {
  BOTH
  EMAIL
  PHONE
}

type TriggerType {
  conditions: [TriggerConditionType!]!
  id: String!
  medium: TriggerMediumEnum!
  name: String!
  recipients: [UserType!]!
  relatedDialogue: Dialogue
  relatedNodeId: String
  type: TriggerTypeEnum!
}

enum TriggerTypeEnum {
  QUESTION
  SCHEDULED
}

input UpdateCTAInputType {
  customerId: ID
  form: FormNodeInputType
  id: String
  links: CTALinksInputType
  share: ShareNodeInputType
  title: String
  type: QuestionNodeTypeEnum
}

input UpdatePermissionsInput {
  permissions: [SystemPermission!]
  roleId: String
}

input UpdateQuestionNodeInputType {
  customerId: ID
  edgeCondition: EdgeConditionInputType
  edgeId: ID
  extraContent: String
  happyText: String
  id: ID!
  optionEntries: OptionsInputType
  overrideLeafId: ID
  sliderNode: SliderNodeInputType
  title: String
  type: String
  unhappyText: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

enum UploadImageEnumType {
  LOGO
  WEBSITE_SCREENSHOT
}

input UploadSellImageInputType {
  file: Upload
  workspaceId: String
}

type UserConnection implements ConnectionInterface {
  pageInfo: PaginationPageInfo!
  totalPages: Int
  userCustomers: [UserCustomer!]!
}

input UserConnectionFilterInput {
  email: String
  endDate: String
  firstName: String
  lastName: String
  offset: Int
  orderBy: UserConnectionOrderByInput
  perPage: Int = 10
  role: String
  search: String
  startDate: String
}

"""Fields to order UserConnection by."""
enum UserConnectionOrder {
  createdAt
  email
  firstName
  isActive
  lastActivity
  lastName
  role
}

"""Sorting of UserConnection"""
input UserConnectionOrderByInput {
  by: UserConnectionOrder!
  desc: Boolean = true
}

type UserCustomer {
  createdAt: Date!
  customer: Customer!
  isActive: Boolean!
  role: RoleType!
  user: UserType!
}

input UserInput {
  customerId: String
  email: String!
  firstName: String
  lastName: String
  password: String
  phone: String
  roleId: String
}

input UserOfCustomerInput {
  customerId: String
  customerSlug: String
  userId: String
}

type UserType {
  customers: [Customer!]!
  email: String!
  firstName: String
  globalPermissions: [SystemPermission!]
  id: ID!
  lastActivity: Date
  lastLoggedIn: Date
  lastName: String
  phone: String
  role: RoleType
  roleId: String
  userCustomers: [UserCustomer!]!
}

type VerifyUserTokenOutput {
  accessToken: String!
  accessTokenExpiry: Int!
  userData: UserType!
}

"""Input type for a video node"""
input VideoNodeEntryInput {
  value: String
}

enum WorkspaceAspectType {
  GENERAL_SCORE
  NR_INTERACTIONS
  NR_VISITORS
}

"""WorkspaceConditionScope"""
type WorkspaceConditionScopeModel {
  aggregate: ConditionPropertyAggregate
  aspect: WorkspaceAspectType!
  createdAt: Date!
  id: ID!
  updatedAt: Date!
}
