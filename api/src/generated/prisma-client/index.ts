// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  colourSettings: (where?: ColourSettingsWhereInput) => Promise<boolean>;
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  fontSettings: (where?: FontSettingsWhereInput) => Promise<boolean>;
  question: (where?: QuestionWhereInput) => Promise<boolean>;
  questionCondition: (where?: QuestionConditionWhereInput) => Promise<boolean>;
  questionOption: (where?: QuestionOptionWhereInput) => Promise<boolean>;
  questionnaire: (where?: QuestionnaireWhereInput) => Promise<boolean>;
  questionnaireSettings: (
    where?: QuestionnaireSettingsWhereInput
  ) => Promise<boolean>;
  topic: (where?: TopicWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  colourSettings: (
    where: ColourSettingsWhereUniqueInput
  ) => ColourSettingsNullablePromise;
  colourSettingses: (args?: {
    where?: ColourSettingsWhereInput;
    orderBy?: ColourSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ColourSettings>;
  colourSettingsesConnection: (args?: {
    where?: ColourSettingsWhereInput;
    orderBy?: ColourSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ColourSettingsConnectionPromise;
  customer: (where: CustomerWhereUniqueInput) => CustomerNullablePromise;
  customers: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Customer>;
  customersConnection: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerConnectionPromise;
  fontSettings: (
    where: FontSettingsWhereUniqueInput
  ) => FontSettingsNullablePromise;
  fontSettingses: (args?: {
    where?: FontSettingsWhereInput;
    orderBy?: FontSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FontSettings>;
  fontSettingsesConnection: (args?: {
    where?: FontSettingsWhereInput;
    orderBy?: FontSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FontSettingsConnectionPromise;
  question: (where: QuestionWhereUniqueInput) => QuestionNullablePromise;
  questions: (args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Question>;
  questionsConnection: (args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionConnectionPromise;
  questionCondition: (
    where: QuestionConditionWhereUniqueInput
  ) => QuestionConditionNullablePromise;
  questionConditions: (args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QuestionCondition>;
  questionConditionsConnection: (args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionConditionConnectionPromise;
  questionOption: (
    where: QuestionOptionWhereUniqueInput
  ) => QuestionOptionNullablePromise;
  questionOptions: (args?: {
    where?: QuestionOptionWhereInput;
    orderBy?: QuestionOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QuestionOption>;
  questionOptionsConnection: (args?: {
    where?: QuestionOptionWhereInput;
    orderBy?: QuestionOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionOptionConnectionPromise;
  questionnaire: (
    where: QuestionnaireWhereUniqueInput
  ) => QuestionnaireNullablePromise;
  questionnaires: (args?: {
    where?: QuestionnaireWhereInput;
    orderBy?: QuestionnaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Questionnaire>;
  questionnairesConnection: (args?: {
    where?: QuestionnaireWhereInput;
    orderBy?: QuestionnaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionnaireConnectionPromise;
  questionnaireSettings: (
    where: QuestionnaireSettingsWhereUniqueInput
  ) => QuestionnaireSettingsNullablePromise;
  questionnaireSettingses: (args?: {
    where?: QuestionnaireSettingsWhereInput;
    orderBy?: QuestionnaireSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QuestionnaireSettings>;
  questionnaireSettingsesConnection: (args?: {
    where?: QuestionnaireSettingsWhereInput;
    orderBy?: QuestionnaireSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionnaireSettingsConnectionPromise;
  topic: (where: TopicWhereUniqueInput) => TopicNullablePromise;
  topics: (args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Topic>;
  topicsConnection: (args?: {
    where?: TopicWhereInput;
    orderBy?: TopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TopicConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createColourSettings: (
    data: ColourSettingsCreateInput
  ) => ColourSettingsPromise;
  updateColourSettings: (args: {
    data: ColourSettingsUpdateInput;
    where: ColourSettingsWhereUniqueInput;
  }) => ColourSettingsPromise;
  updateManyColourSettingses: (args: {
    data: ColourSettingsUpdateManyMutationInput;
    where?: ColourSettingsWhereInput;
  }) => BatchPayloadPromise;
  upsertColourSettings: (args: {
    where: ColourSettingsWhereUniqueInput;
    create: ColourSettingsCreateInput;
    update: ColourSettingsUpdateInput;
  }) => ColourSettingsPromise;
  deleteColourSettings: (
    where: ColourSettingsWhereUniqueInput
  ) => ColourSettingsPromise;
  deleteManyColourSettingses: (
    where?: ColourSettingsWhereInput
  ) => BatchPayloadPromise;
  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (args: {
    data: CustomerUpdateInput;
    where: CustomerWhereUniqueInput;
  }) => CustomerPromise;
  upsertCustomer: (args: {
    where: CustomerWhereUniqueInput;
    create: CustomerCreateInput;
    update: CustomerUpdateInput;
  }) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createFontSettings: (data: FontSettingsCreateInput) => FontSettingsPromise;
  updateFontSettings: (args: {
    data: FontSettingsUpdateInput;
    where: FontSettingsWhereUniqueInput;
  }) => FontSettingsPromise;
  updateManyFontSettingses: (args: {
    data: FontSettingsUpdateManyMutationInput;
    where?: FontSettingsWhereInput;
  }) => BatchPayloadPromise;
  upsertFontSettings: (args: {
    where: FontSettingsWhereUniqueInput;
    create: FontSettingsCreateInput;
    update: FontSettingsUpdateInput;
  }) => FontSettingsPromise;
  deleteFontSettings: (
    where: FontSettingsWhereUniqueInput
  ) => FontSettingsPromise;
  deleteManyFontSettingses: (
    where?: FontSettingsWhereInput
  ) => BatchPayloadPromise;
  createQuestion: (data: QuestionCreateInput) => QuestionPromise;
  updateQuestion: (args: {
    data: QuestionUpdateInput;
    where: QuestionWhereUniqueInput;
  }) => QuestionPromise;
  updateManyQuestions: (args: {
    data: QuestionUpdateManyMutationInput;
    where?: QuestionWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestion: (args: {
    where: QuestionWhereUniqueInput;
    create: QuestionCreateInput;
    update: QuestionUpdateInput;
  }) => QuestionPromise;
  deleteQuestion: (where: QuestionWhereUniqueInput) => QuestionPromise;
  deleteManyQuestions: (where?: QuestionWhereInput) => BatchPayloadPromise;
  createQuestionCondition: (
    data: QuestionConditionCreateInput
  ) => QuestionConditionPromise;
  updateQuestionCondition: (args: {
    data: QuestionConditionUpdateInput;
    where: QuestionConditionWhereUniqueInput;
  }) => QuestionConditionPromise;
  updateManyQuestionConditions: (args: {
    data: QuestionConditionUpdateManyMutationInput;
    where?: QuestionConditionWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestionCondition: (args: {
    where: QuestionConditionWhereUniqueInput;
    create: QuestionConditionCreateInput;
    update: QuestionConditionUpdateInput;
  }) => QuestionConditionPromise;
  deleteQuestionCondition: (
    where: QuestionConditionWhereUniqueInput
  ) => QuestionConditionPromise;
  deleteManyQuestionConditions: (
    where?: QuestionConditionWhereInput
  ) => BatchPayloadPromise;
  createQuestionOption: (
    data: QuestionOptionCreateInput
  ) => QuestionOptionPromise;
  updateQuestionOption: (args: {
    data: QuestionOptionUpdateInput;
    where: QuestionOptionWhereUniqueInput;
  }) => QuestionOptionPromise;
  updateManyQuestionOptions: (args: {
    data: QuestionOptionUpdateManyMutationInput;
    where?: QuestionOptionWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestionOption: (args: {
    where: QuestionOptionWhereUniqueInput;
    create: QuestionOptionCreateInput;
    update: QuestionOptionUpdateInput;
  }) => QuestionOptionPromise;
  deleteQuestionOption: (
    where: QuestionOptionWhereUniqueInput
  ) => QuestionOptionPromise;
  deleteManyQuestionOptions: (
    where?: QuestionOptionWhereInput
  ) => BatchPayloadPromise;
  createQuestionnaire: (data: QuestionnaireCreateInput) => QuestionnairePromise;
  updateQuestionnaire: (args: {
    data: QuestionnaireUpdateInput;
    where: QuestionnaireWhereUniqueInput;
  }) => QuestionnairePromise;
  updateManyQuestionnaires: (args: {
    data: QuestionnaireUpdateManyMutationInput;
    where?: QuestionnaireWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestionnaire: (args: {
    where: QuestionnaireWhereUniqueInput;
    create: QuestionnaireCreateInput;
    update: QuestionnaireUpdateInput;
  }) => QuestionnairePromise;
  deleteQuestionnaire: (
    where: QuestionnaireWhereUniqueInput
  ) => QuestionnairePromise;
  deleteManyQuestionnaires: (
    where?: QuestionnaireWhereInput
  ) => BatchPayloadPromise;
  createQuestionnaireSettings: (
    data: QuestionnaireSettingsCreateInput
  ) => QuestionnaireSettingsPromise;
  updateQuestionnaireSettings: (args: {
    data: QuestionnaireSettingsUpdateInput;
    where: QuestionnaireSettingsWhereUniqueInput;
  }) => QuestionnaireSettingsPromise;
  updateManyQuestionnaireSettingses: (args: {
    data: QuestionnaireSettingsUpdateManyMutationInput;
    where?: QuestionnaireSettingsWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestionnaireSettings: (args: {
    where: QuestionnaireSettingsWhereUniqueInput;
    create: QuestionnaireSettingsCreateInput;
    update: QuestionnaireSettingsUpdateInput;
  }) => QuestionnaireSettingsPromise;
  deleteQuestionnaireSettings: (
    where: QuestionnaireSettingsWhereUniqueInput
  ) => QuestionnaireSettingsPromise;
  deleteManyQuestionnaireSettingses: (
    where?: QuestionnaireSettingsWhereInput
  ) => BatchPayloadPromise;
  createTopic: (data: TopicCreateInput) => TopicPromise;
  updateTopic: (args: {
    data: TopicUpdateInput;
    where: TopicWhereUniqueInput;
  }) => TopicPromise;
  updateManyTopics: (args: {
    data: TopicUpdateManyMutationInput;
    where?: TopicWhereInput;
  }) => BatchPayloadPromise;
  upsertTopic: (args: {
    where: TopicWhereUniqueInput;
    create: TopicCreateInput;
    update: TopicUpdateInput;
  }) => TopicPromise;
  deleteTopic: (where: TopicWhereUniqueInput) => TopicPromise;
  deleteManyTopics: (where?: TopicWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  colourSettings: (
    where?: ColourSettingsSubscriptionWhereInput
  ) => ColourSettingsSubscriptionPayloadSubscription;
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  fontSettings: (
    where?: FontSettingsSubscriptionWhereInput
  ) => FontSettingsSubscriptionPayloadSubscription;
  question: (
    where?: QuestionSubscriptionWhereInput
  ) => QuestionSubscriptionPayloadSubscription;
  questionCondition: (
    where?: QuestionConditionSubscriptionWhereInput
  ) => QuestionConditionSubscriptionPayloadSubscription;
  questionOption: (
    where?: QuestionOptionSubscriptionWhereInput
  ) => QuestionOptionSubscriptionPayloadSubscription;
  questionnaire: (
    where?: QuestionnaireSubscriptionWhereInput
  ) => QuestionnaireSubscriptionPayloadSubscription;
  questionnaireSettings: (
    where?: QuestionnaireSettingsSubscriptionWhereInput
  ) => QuestionnaireSettingsSubscriptionPayloadSubscription;
  topic: (
    where?: TopicSubscriptionWhereInput
  ) => TopicSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type FontSettingsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "settingTitle_ASC"
  | "settingTitle_DESC"
  | "body_ASC"
  | "body_DESC"
  | "fontTitle_ASC"
  | "fontTitle_DESC"
  | "special_ASC"
  | "special_DESC";

export type QuestionnaireOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "customerId_ASC"
  | "customerId_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "publicTitle_ASC"
  | "publicTitle_DESC"
  | "creationDate_ASC"
  | "creationDate_DESC";

export type QuestionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "questionnaireId_ASC"
  | "questionnaireId_DESC"
  | "title_ASC"
  | "title_DESC"
  | "type_ASC"
  | "type_DESC"
  | "overrideLeafId_ASC"
  | "overrideLeafId_DESC";

export type QuestionConditionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "renderMin_ASC"
  | "renderMin_DESC"
  | "renderMax_ASC"
  | "renderMax_DESC"
  | "matchValue_ASC"
  | "matchValue_DESC";

export type QuestionOptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC"
  | "publicValue_ASC"
  | "publicValue_DESC";

export type CustomerOrderByInput = "id_ASC" | "id_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ColourSettingsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "primary_ASC"
  | "primary_DESC"
  | "secondary_ASC"
  | "secondary_DESC"
  | "tertiary_ASC"
  | "tertiary_DESC"
  | "success_ASC"
  | "success_DESC"
  | "warning_ASC"
  | "warning_DESC"
  | "error_ASC"
  | "error_DESC"
  | "lightest_ASC"
  | "lightest_DESC"
  | "light_ASC"
  | "light_DESC"
  | "normal_ASC"
  | "normal_DESC"
  | "dark_ASC"
  | "dark_DESC"
  | "darkest_ASC"
  | "darkest_DESC"
  | "muted_ASC"
  | "muted_DESC"
  | "text_ASC"
  | "text_DESC";

export type QuestionnaireSettingsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "customerId_ASC"
  | "customerId_DESC"
  | "questionnaireId_ASC"
  | "questionnaireId_DESC"
  | "title_ASC"
  | "title_DESC"
  | "logo_ASC"
  | "logo_DESC";

export type TopicOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "publicTitle_ASC"
  | "publicTitle_DESC"
  | "logoUrl_ASC"
  | "logoUrl_DESC"
  | "language_ASC"
  | "language_DESC"
  | "topicUrl_ASC"
  | "topicUrl_DESC";

export interface QuestionConditionCreateManyInput {
  create?: Maybe<QuestionConditionCreateInput[] | QuestionConditionCreateInput>;
  connect?: Maybe<
    QuestionConditionWhereUniqueInput[] | QuestionConditionWhereUniqueInput
  >;
}

export type ColourSettingsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QuestionnaireUpdateWithWhereUniqueNestedInput {
  where: QuestionnaireWhereUniqueInput;
  data: QuestionnaireUpdateDataInput;
}

export type CustomerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QuestionnaireUpdateDataInput {
  customerId?: Maybe<ID_Input>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  publicTitle?: Maybe<String>;
  setting?: Maybe<QuestionnaireSettingsUpdateOneRequiredInput>;
  creationDate?: Maybe<String>;
  questions?: Maybe<QuestionUpdateManyInput>;
}

export interface QuestionnaireWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  customerId?: Maybe<ID_Input>;
  customerId_not?: Maybe<ID_Input>;
  customerId_in?: Maybe<ID_Input[] | ID_Input>;
  customerId_not_in?: Maybe<ID_Input[] | ID_Input>;
  customerId_lt?: Maybe<ID_Input>;
  customerId_lte?: Maybe<ID_Input>;
  customerId_gt?: Maybe<ID_Input>;
  customerId_gte?: Maybe<ID_Input>;
  customerId_contains?: Maybe<ID_Input>;
  customerId_not_contains?: Maybe<ID_Input>;
  customerId_starts_with?: Maybe<ID_Input>;
  customerId_not_starts_with?: Maybe<ID_Input>;
  customerId_ends_with?: Maybe<ID_Input>;
  customerId_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  publicTitle?: Maybe<String>;
  publicTitle_not?: Maybe<String>;
  publicTitle_in?: Maybe<String[] | String>;
  publicTitle_not_in?: Maybe<String[] | String>;
  publicTitle_lt?: Maybe<String>;
  publicTitle_lte?: Maybe<String>;
  publicTitle_gt?: Maybe<String>;
  publicTitle_gte?: Maybe<String>;
  publicTitle_contains?: Maybe<String>;
  publicTitle_not_contains?: Maybe<String>;
  publicTitle_starts_with?: Maybe<String>;
  publicTitle_not_starts_with?: Maybe<String>;
  publicTitle_ends_with?: Maybe<String>;
  publicTitle_not_ends_with?: Maybe<String>;
  setting?: Maybe<QuestionnaireSettingsWhereInput>;
  creationDate?: Maybe<String>;
  creationDate_not?: Maybe<String>;
  creationDate_in?: Maybe<String[] | String>;
  creationDate_not_in?: Maybe<String[] | String>;
  creationDate_lt?: Maybe<String>;
  creationDate_lte?: Maybe<String>;
  creationDate_gt?: Maybe<String>;
  creationDate_gte?: Maybe<String>;
  creationDate_contains?: Maybe<String>;
  creationDate_not_contains?: Maybe<String>;
  creationDate_starts_with?: Maybe<String>;
  creationDate_not_starts_with?: Maybe<String>;
  creationDate_ends_with?: Maybe<String>;
  creationDate_not_ends_with?: Maybe<String>;
  questions_every?: Maybe<QuestionWhereInput>;
  questions_some?: Maybe<QuestionWhereInput>;
  questions_none?: Maybe<QuestionWhereInput>;
  AND?: Maybe<QuestionnaireWhereInput[] | QuestionnaireWhereInput>;
  OR?: Maybe<QuestionnaireWhereInput[] | QuestionnaireWhereInput>;
  NOT?: Maybe<QuestionnaireWhereInput[] | QuestionnaireWhereInput>;
}

export interface QuestionnaireSettingsUpdateOneRequiredInput {
  create?: Maybe<QuestionnaireSettingsCreateInput>;
  update?: Maybe<QuestionnaireSettingsUpdateDataInput>;
  upsert?: Maybe<QuestionnaireSettingsUpsertNestedInput>;
  connect?: Maybe<QuestionnaireSettingsWhereUniqueInput>;
}

export interface FontSettingsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  settingTitle?: Maybe<String>;
  settingTitle_not?: Maybe<String>;
  settingTitle_in?: Maybe<String[] | String>;
  settingTitle_not_in?: Maybe<String[] | String>;
  settingTitle_lt?: Maybe<String>;
  settingTitle_lte?: Maybe<String>;
  settingTitle_gt?: Maybe<String>;
  settingTitle_gte?: Maybe<String>;
  settingTitle_contains?: Maybe<String>;
  settingTitle_not_contains?: Maybe<String>;
  settingTitle_starts_with?: Maybe<String>;
  settingTitle_not_starts_with?: Maybe<String>;
  settingTitle_ends_with?: Maybe<String>;
  settingTitle_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  fontTitle?: Maybe<String>;
  fontTitle_not?: Maybe<String>;
  fontTitle_in?: Maybe<String[] | String>;
  fontTitle_not_in?: Maybe<String[] | String>;
  fontTitle_lt?: Maybe<String>;
  fontTitle_lte?: Maybe<String>;
  fontTitle_gt?: Maybe<String>;
  fontTitle_gte?: Maybe<String>;
  fontTitle_contains?: Maybe<String>;
  fontTitle_not_contains?: Maybe<String>;
  fontTitle_starts_with?: Maybe<String>;
  fontTitle_not_starts_with?: Maybe<String>;
  fontTitle_ends_with?: Maybe<String>;
  fontTitle_not_ends_with?: Maybe<String>;
  special?: Maybe<String>;
  special_not?: Maybe<String>;
  special_in?: Maybe<String[] | String>;
  special_not_in?: Maybe<String[] | String>;
  special_lt?: Maybe<String>;
  special_lte?: Maybe<String>;
  special_gt?: Maybe<String>;
  special_gte?: Maybe<String>;
  special_contains?: Maybe<String>;
  special_not_contains?: Maybe<String>;
  special_starts_with?: Maybe<String>;
  special_not_starts_with?: Maybe<String>;
  special_ends_with?: Maybe<String>;
  special_not_ends_with?: Maybe<String>;
  AND?: Maybe<FontSettingsWhereInput[] | FontSettingsWhereInput>;
  OR?: Maybe<FontSettingsWhereInput[] | FontSettingsWhereInput>;
  NOT?: Maybe<FontSettingsWhereInput[] | FontSettingsWhereInput>;
}

export interface QuestionnaireSettingsUpdateDataInput {
  customerId?: Maybe<ID_Input>;
  questionnaireId?: Maybe<ID_Input>;
  title?: Maybe<String>;
  logo?: Maybe<String>;
  colourSettings?: Maybe<ColourSettingsUpdateOneRequiredInput>;
  fontSettings?: Maybe<FontSettingsUpdateOneRequiredInput>;
}

export interface QuestionConditionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  renderMin?: Maybe<Int>;
  renderMin_not?: Maybe<Int>;
  renderMin_in?: Maybe<Int[] | Int>;
  renderMin_not_in?: Maybe<Int[] | Int>;
  renderMin_lt?: Maybe<Int>;
  renderMin_lte?: Maybe<Int>;
  renderMin_gt?: Maybe<Int>;
  renderMin_gte?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  renderMax_not?: Maybe<Int>;
  renderMax_in?: Maybe<Int[] | Int>;
  renderMax_not_in?: Maybe<Int[] | Int>;
  renderMax_lt?: Maybe<Int>;
  renderMax_lte?: Maybe<Int>;
  renderMax_gt?: Maybe<Int>;
  renderMax_gte?: Maybe<Int>;
  matchValue?: Maybe<String>;
  matchValue_not?: Maybe<String>;
  matchValue_in?: Maybe<String[] | String>;
  matchValue_not_in?: Maybe<String[] | String>;
  matchValue_lt?: Maybe<String>;
  matchValue_lte?: Maybe<String>;
  matchValue_gt?: Maybe<String>;
  matchValue_gte?: Maybe<String>;
  matchValue_contains?: Maybe<String>;
  matchValue_not_contains?: Maybe<String>;
  matchValue_starts_with?: Maybe<String>;
  matchValue_not_starts_with?: Maybe<String>;
  matchValue_ends_with?: Maybe<String>;
  matchValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<QuestionConditionWhereInput[] | QuestionConditionWhereInput>;
  OR?: Maybe<QuestionConditionWhereInput[] | QuestionConditionWhereInput>;
  NOT?: Maybe<QuestionConditionWhereInput[] | QuestionConditionWhereInput>;
}

export interface QuestionOptionUpdateManyWithWhereNestedInput {
  where: QuestionOptionScalarWhereInput;
  data: QuestionOptionUpdateManyDataInput;
}

export interface QuestionConditionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  renderMin?: Maybe<Int>;
  renderMin_not?: Maybe<Int>;
  renderMin_in?: Maybe<Int[] | Int>;
  renderMin_not_in?: Maybe<Int[] | Int>;
  renderMin_lt?: Maybe<Int>;
  renderMin_lte?: Maybe<Int>;
  renderMin_gt?: Maybe<Int>;
  renderMin_gte?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  renderMax_not?: Maybe<Int>;
  renderMax_in?: Maybe<Int[] | Int>;
  renderMax_not_in?: Maybe<Int[] | Int>;
  renderMax_lt?: Maybe<Int>;
  renderMax_lte?: Maybe<Int>;
  renderMax_gt?: Maybe<Int>;
  renderMax_gte?: Maybe<Int>;
  matchValue?: Maybe<String>;
  matchValue_not?: Maybe<String>;
  matchValue_in?: Maybe<String[] | String>;
  matchValue_not_in?: Maybe<String[] | String>;
  matchValue_lt?: Maybe<String>;
  matchValue_lte?: Maybe<String>;
  matchValue_gt?: Maybe<String>;
  matchValue_gte?: Maybe<String>;
  matchValue_contains?: Maybe<String>;
  matchValue_not_contains?: Maybe<String>;
  matchValue_starts_with?: Maybe<String>;
  matchValue_not_starts_with?: Maybe<String>;
  matchValue_ends_with?: Maybe<String>;
  matchValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    QuestionConditionScalarWhereInput[] | QuestionConditionScalarWhereInput
  >;
  OR?: Maybe<
    QuestionConditionScalarWhereInput[] | QuestionConditionScalarWhereInput
  >;
  NOT?: Maybe<
    QuestionConditionScalarWhereInput[] | QuestionConditionScalarWhereInput
  >;
}

export interface QuestionOptionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  publicValue?: Maybe<String>;
  publicValue_not?: Maybe<String>;
  publicValue_in?: Maybe<String[] | String>;
  publicValue_not_in?: Maybe<String[] | String>;
  publicValue_lt?: Maybe<String>;
  publicValue_lte?: Maybe<String>;
  publicValue_gt?: Maybe<String>;
  publicValue_gte?: Maybe<String>;
  publicValue_contains?: Maybe<String>;
  publicValue_not_contains?: Maybe<String>;
  publicValue_starts_with?: Maybe<String>;
  publicValue_not_starts_with?: Maybe<String>;
  publicValue_ends_with?: Maybe<String>;
  publicValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    QuestionOptionScalarWhereInput[] | QuestionOptionScalarWhereInput
  >;
  OR?: Maybe<QuestionOptionScalarWhereInput[] | QuestionOptionScalarWhereInput>;
  NOT?: Maybe<
    QuestionOptionScalarWhereInput[] | QuestionOptionScalarWhereInput
  >;
}

export interface ColourSettingsUpdateOneRequiredInput {
  create?: Maybe<ColourSettingsCreateInput>;
  update?: Maybe<ColourSettingsUpdateDataInput>;
  upsert?: Maybe<ColourSettingsUpsertNestedInput>;
  connect?: Maybe<ColourSettingsWhereUniqueInput>;
}

export interface QuestionOptionUpsertWithWhereUniqueNestedInput {
  where: QuestionOptionWhereUniqueInput;
  update: QuestionOptionUpdateDataInput;
  create: QuestionOptionCreateInput;
}

export interface QuestionnaireSettingsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionnaireSettingsWhereInput>;
  AND?: Maybe<
    | QuestionnaireSettingsSubscriptionWhereInput[]
    | QuestionnaireSettingsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | QuestionnaireSettingsSubscriptionWhereInput[]
    | QuestionnaireSettingsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | QuestionnaireSettingsSubscriptionWhereInput[]
    | QuestionnaireSettingsSubscriptionWhereInput
  >;
}

export interface QuestionOptionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionOptionWhereInput>;
  AND?: Maybe<
    | QuestionOptionSubscriptionWhereInput[]
    | QuestionOptionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | QuestionOptionSubscriptionWhereInput[]
    | QuestionOptionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | QuestionOptionSubscriptionWhereInput[]
    | QuestionOptionSubscriptionWhereInput
  >;
}

export interface QuestionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionWhereInput>;
  AND?: Maybe<
    QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput
  >;
  OR?: Maybe<QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput>;
  NOT?: Maybe<
    QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput
  >;
}

export interface ColourSettingsCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  primary: String;
  secondary: String;
  tertiary: String;
  success: String;
  warning: String;
  error: String;
  lightest: String;
  light: String;
  normal: String;
  dark: String;
  darkest: String;
  muted: String;
  text: String;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerWhereInput>;
  AND?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
  OR?: Maybe<CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput>;
  NOT?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
}

export interface ColourSettingsUpdateInput {
  title?: Maybe<String>;
  primary?: Maybe<String>;
  secondary?: Maybe<String>;
  tertiary?: Maybe<String>;
  success?: Maybe<String>;
  warning?: Maybe<String>;
  error?: Maybe<String>;
  lightest?: Maybe<String>;
  light?: Maybe<String>;
  normal?: Maybe<String>;
  dark?: Maybe<String>;
  darkest?: Maybe<String>;
  muted?: Maybe<String>;
  text?: Maybe<String>;
}

export interface ColourSettingsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ColourSettingsWhereInput>;
  AND?: Maybe<
    | ColourSettingsSubscriptionWhereInput[]
    | ColourSettingsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ColourSettingsSubscriptionWhereInput[]
    | ColourSettingsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ColourSettingsSubscriptionWhereInput[]
    | ColourSettingsSubscriptionWhereInput
  >;
}

export interface ColourSettingsUpdateManyMutationInput {
  title?: Maybe<String>;
  primary?: Maybe<String>;
  secondary?: Maybe<String>;
  tertiary?: Maybe<String>;
  success?: Maybe<String>;
  warning?: Maybe<String>;
  error?: Maybe<String>;
  lightest?: Maybe<String>;
  light?: Maybe<String>;
  normal?: Maybe<String>;
  dark?: Maybe<String>;
  darkest?: Maybe<String>;
  muted?: Maybe<String>;
  text?: Maybe<String>;
}

export interface TopicUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  publicTitle?: Maybe<String>;
  logoUrl?: Maybe<String>;
  language?: Maybe<String>;
  topicUrl?: Maybe<String>;
  questions?: Maybe<QuestionUpdateManyInput>;
}

export interface QuestionOptionUpdateDataInput {
  value?: Maybe<String>;
  publicValue?: Maybe<String>;
}

export type FontSettingsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QuestionOptionUpdateWithWhereUniqueNestedInput {
  where: QuestionOptionWhereUniqueInput;
  data: QuestionOptionUpdateDataInput;
}

export interface QuestionnaireSettingsUpdateInput {
  customerId?: Maybe<ID_Input>;
  questionnaireId?: Maybe<ID_Input>;
  title?: Maybe<String>;
  logo?: Maybe<String>;
  colourSettings?: Maybe<ColourSettingsUpdateOneRequiredInput>;
  fontSettings?: Maybe<FontSettingsUpdateOneRequiredInput>;
}

export interface CustomerCreateInput {
  id?: Maybe<ID_Input>;
  questionnaires?: Maybe<QuestionnaireCreateManyInput>;
}

export interface QuestionnaireUpdateInput {
  customerId?: Maybe<ID_Input>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  publicTitle?: Maybe<String>;
  setting?: Maybe<QuestionnaireSettingsUpdateOneRequiredInput>;
  creationDate?: Maybe<String>;
  questions?: Maybe<QuestionUpdateManyInput>;
}

export interface QuestionnaireCreateManyInput {
  create?: Maybe<QuestionnaireCreateInput[] | QuestionnaireCreateInput>;
  connect?: Maybe<
    QuestionnaireWhereUniqueInput[] | QuestionnaireWhereUniqueInput
  >;
}

export interface QuestionOptionUpdateManyMutationInput {
  value?: Maybe<String>;
  publicValue?: Maybe<String>;
}

export interface QuestionnaireCreateInput {
  id?: Maybe<ID_Input>;
  customerId: ID_Input;
  title: String;
  description: String;
  publicTitle?: Maybe<String>;
  setting: QuestionnaireSettingsCreateOneInput;
  creationDate: String;
  questions?: Maybe<QuestionCreateManyInput>;
}

export interface QuestionConditionUpdateManyMutationInput {
  renderMin?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  matchValue?: Maybe<String>;
}

export interface QuestionnaireSettingsCreateOneInput {
  create?: Maybe<QuestionnaireSettingsCreateInput>;
  connect?: Maybe<QuestionnaireSettingsWhereUniqueInput>;
}

export interface QuestionConditionUpdateInput {
  renderMin?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  matchValue?: Maybe<String>;
}

export interface QuestionnaireSettingsCreateInput {
  id?: Maybe<ID_Input>;
  customerId: ID_Input;
  questionnaireId: ID_Input;
  title?: Maybe<String>;
  logo?: Maybe<String>;
  colourSettings: ColourSettingsCreateOneInput;
  fontSettings: FontSettingsCreateOneInput;
}

export interface QuestionUpdateInput {
  questionnaireId?: Maybe<ID_Input>;
  title?: Maybe<String>;
  type?: Maybe<String>;
  overrideLeafId?: Maybe<Int>;
  conditions?: Maybe<QuestionConditionUpdateManyInput>;
  options?: Maybe<QuestionOptionUpdateManyInput>;
  children?: Maybe<QuestionUpdateManyInput>;
}

export interface ColourSettingsCreateOneInput {
  create?: Maybe<ColourSettingsCreateInput>;
  connect?: Maybe<ColourSettingsWhereUniqueInput>;
}

export interface FontSettingsUpdateManyMutationInput {
  settingTitle?: Maybe<String>;
  body?: Maybe<String>;
  fontTitle?: Maybe<String>;
  special?: Maybe<String>;
}

export interface FontSettingsCreateOneInput {
  create?: Maybe<FontSettingsCreateInput>;
  connect?: Maybe<FontSettingsWhereUniqueInput>;
}

export interface QuestionnaireUpdateManyDataInput {
  customerId?: Maybe<ID_Input>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  publicTitle?: Maybe<String>;
  creationDate?: Maybe<String>;
}

export interface FontSettingsCreateInput {
  id?: Maybe<ID_Input>;
  settingTitle?: Maybe<String>;
  body?: Maybe<String>;
  fontTitle?: Maybe<String>;
  special?: Maybe<String>;
}

export interface QuestionnaireUpdateManyWithWhereNestedInput {
  where: QuestionnaireScalarWhereInput;
  data: QuestionnaireUpdateManyDataInput;
}

export interface QuestionCreateManyInput {
  create?: Maybe<QuestionCreateInput[] | QuestionCreateInput>;
  connect?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
}

export interface QuestionnaireUpsertWithWhereUniqueNestedInput {
  where: QuestionnaireWhereUniqueInput;
  update: QuestionnaireUpdateDataInput;
  create: QuestionnaireCreateInput;
}

export interface QuestionCreateInput {
  id?: Maybe<ID_Input>;
  questionnaireId: ID_Input;
  title: String;
  type: String;
  overrideLeafId?: Maybe<Int>;
  conditions?: Maybe<QuestionConditionCreateManyInput>;
  options?: Maybe<QuestionOptionCreateManyInput>;
  children?: Maybe<QuestionCreateManyInput>;
}

export interface ColourSettingsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  primary?: Maybe<String>;
  primary_not?: Maybe<String>;
  primary_in?: Maybe<String[] | String>;
  primary_not_in?: Maybe<String[] | String>;
  primary_lt?: Maybe<String>;
  primary_lte?: Maybe<String>;
  primary_gt?: Maybe<String>;
  primary_gte?: Maybe<String>;
  primary_contains?: Maybe<String>;
  primary_not_contains?: Maybe<String>;
  primary_starts_with?: Maybe<String>;
  primary_not_starts_with?: Maybe<String>;
  primary_ends_with?: Maybe<String>;
  primary_not_ends_with?: Maybe<String>;
  secondary?: Maybe<String>;
  secondary_not?: Maybe<String>;
  secondary_in?: Maybe<String[] | String>;
  secondary_not_in?: Maybe<String[] | String>;
  secondary_lt?: Maybe<String>;
  secondary_lte?: Maybe<String>;
  secondary_gt?: Maybe<String>;
  secondary_gte?: Maybe<String>;
  secondary_contains?: Maybe<String>;
  secondary_not_contains?: Maybe<String>;
  secondary_starts_with?: Maybe<String>;
  secondary_not_starts_with?: Maybe<String>;
  secondary_ends_with?: Maybe<String>;
  secondary_not_ends_with?: Maybe<String>;
  tertiary?: Maybe<String>;
  tertiary_not?: Maybe<String>;
  tertiary_in?: Maybe<String[] | String>;
  tertiary_not_in?: Maybe<String[] | String>;
  tertiary_lt?: Maybe<String>;
  tertiary_lte?: Maybe<String>;
  tertiary_gt?: Maybe<String>;
  tertiary_gte?: Maybe<String>;
  tertiary_contains?: Maybe<String>;
  tertiary_not_contains?: Maybe<String>;
  tertiary_starts_with?: Maybe<String>;
  tertiary_not_starts_with?: Maybe<String>;
  tertiary_ends_with?: Maybe<String>;
  tertiary_not_ends_with?: Maybe<String>;
  success?: Maybe<String>;
  success_not?: Maybe<String>;
  success_in?: Maybe<String[] | String>;
  success_not_in?: Maybe<String[] | String>;
  success_lt?: Maybe<String>;
  success_lte?: Maybe<String>;
  success_gt?: Maybe<String>;
  success_gte?: Maybe<String>;
  success_contains?: Maybe<String>;
  success_not_contains?: Maybe<String>;
  success_starts_with?: Maybe<String>;
  success_not_starts_with?: Maybe<String>;
  success_ends_with?: Maybe<String>;
  success_not_ends_with?: Maybe<String>;
  warning?: Maybe<String>;
  warning_not?: Maybe<String>;
  warning_in?: Maybe<String[] | String>;
  warning_not_in?: Maybe<String[] | String>;
  warning_lt?: Maybe<String>;
  warning_lte?: Maybe<String>;
  warning_gt?: Maybe<String>;
  warning_gte?: Maybe<String>;
  warning_contains?: Maybe<String>;
  warning_not_contains?: Maybe<String>;
  warning_starts_with?: Maybe<String>;
  warning_not_starts_with?: Maybe<String>;
  warning_ends_with?: Maybe<String>;
  warning_not_ends_with?: Maybe<String>;
  error?: Maybe<String>;
  error_not?: Maybe<String>;
  error_in?: Maybe<String[] | String>;
  error_not_in?: Maybe<String[] | String>;
  error_lt?: Maybe<String>;
  error_lte?: Maybe<String>;
  error_gt?: Maybe<String>;
  error_gte?: Maybe<String>;
  error_contains?: Maybe<String>;
  error_not_contains?: Maybe<String>;
  error_starts_with?: Maybe<String>;
  error_not_starts_with?: Maybe<String>;
  error_ends_with?: Maybe<String>;
  error_not_ends_with?: Maybe<String>;
  lightest?: Maybe<String>;
  lightest_not?: Maybe<String>;
  lightest_in?: Maybe<String[] | String>;
  lightest_not_in?: Maybe<String[] | String>;
  lightest_lt?: Maybe<String>;
  lightest_lte?: Maybe<String>;
  lightest_gt?: Maybe<String>;
  lightest_gte?: Maybe<String>;
  lightest_contains?: Maybe<String>;
  lightest_not_contains?: Maybe<String>;
  lightest_starts_with?: Maybe<String>;
  lightest_not_starts_with?: Maybe<String>;
  lightest_ends_with?: Maybe<String>;
  lightest_not_ends_with?: Maybe<String>;
  light?: Maybe<String>;
  light_not?: Maybe<String>;
  light_in?: Maybe<String[] | String>;
  light_not_in?: Maybe<String[] | String>;
  light_lt?: Maybe<String>;
  light_lte?: Maybe<String>;
  light_gt?: Maybe<String>;
  light_gte?: Maybe<String>;
  light_contains?: Maybe<String>;
  light_not_contains?: Maybe<String>;
  light_starts_with?: Maybe<String>;
  light_not_starts_with?: Maybe<String>;
  light_ends_with?: Maybe<String>;
  light_not_ends_with?: Maybe<String>;
  normal?: Maybe<String>;
  normal_not?: Maybe<String>;
  normal_in?: Maybe<String[] | String>;
  normal_not_in?: Maybe<String[] | String>;
  normal_lt?: Maybe<String>;
  normal_lte?: Maybe<String>;
  normal_gt?: Maybe<String>;
  normal_gte?: Maybe<String>;
  normal_contains?: Maybe<String>;
  normal_not_contains?: Maybe<String>;
  normal_starts_with?: Maybe<String>;
  normal_not_starts_with?: Maybe<String>;
  normal_ends_with?: Maybe<String>;
  normal_not_ends_with?: Maybe<String>;
  dark?: Maybe<String>;
  dark_not?: Maybe<String>;
  dark_in?: Maybe<String[] | String>;
  dark_not_in?: Maybe<String[] | String>;
  dark_lt?: Maybe<String>;
  dark_lte?: Maybe<String>;
  dark_gt?: Maybe<String>;
  dark_gte?: Maybe<String>;
  dark_contains?: Maybe<String>;
  dark_not_contains?: Maybe<String>;
  dark_starts_with?: Maybe<String>;
  dark_not_starts_with?: Maybe<String>;
  dark_ends_with?: Maybe<String>;
  dark_not_ends_with?: Maybe<String>;
  darkest?: Maybe<String>;
  darkest_not?: Maybe<String>;
  darkest_in?: Maybe<String[] | String>;
  darkest_not_in?: Maybe<String[] | String>;
  darkest_lt?: Maybe<String>;
  darkest_lte?: Maybe<String>;
  darkest_gt?: Maybe<String>;
  darkest_gte?: Maybe<String>;
  darkest_contains?: Maybe<String>;
  darkest_not_contains?: Maybe<String>;
  darkest_starts_with?: Maybe<String>;
  darkest_not_starts_with?: Maybe<String>;
  darkest_ends_with?: Maybe<String>;
  darkest_not_ends_with?: Maybe<String>;
  muted?: Maybe<String>;
  muted_not?: Maybe<String>;
  muted_in?: Maybe<String[] | String>;
  muted_not_in?: Maybe<String[] | String>;
  muted_lt?: Maybe<String>;
  muted_lte?: Maybe<String>;
  muted_gt?: Maybe<String>;
  muted_gte?: Maybe<String>;
  muted_contains?: Maybe<String>;
  muted_not_contains?: Maybe<String>;
  muted_starts_with?: Maybe<String>;
  muted_not_starts_with?: Maybe<String>;
  muted_ends_with?: Maybe<String>;
  muted_not_ends_with?: Maybe<String>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  AND?: Maybe<ColourSettingsWhereInput[] | ColourSettingsWhereInput>;
  OR?: Maybe<ColourSettingsWhereInput[] | ColourSettingsWhereInput>;
  NOT?: Maybe<ColourSettingsWhereInput[] | ColourSettingsWhereInput>;
}

export interface QuestionOptionUpdateManyInput {
  create?: Maybe<QuestionOptionCreateInput[] | QuestionOptionCreateInput>;
  update?: Maybe<
    | QuestionOptionUpdateWithWhereUniqueNestedInput[]
    | QuestionOptionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QuestionOptionUpsertWithWhereUniqueNestedInput[]
    | QuestionOptionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    QuestionOptionWhereUniqueInput[] | QuestionOptionWhereUniqueInput
  >;
  connect?: Maybe<
    QuestionOptionWhereUniqueInput[] | QuestionOptionWhereUniqueInput
  >;
  set?: Maybe<
    QuestionOptionWhereUniqueInput[] | QuestionOptionWhereUniqueInput
  >;
  disconnect?: Maybe<
    QuestionOptionWhereUniqueInput[] | QuestionOptionWhereUniqueInput
  >;
  deleteMany?: Maybe<
    QuestionOptionScalarWhereInput[] | QuestionOptionScalarWhereInput
  >;
  updateMany?: Maybe<
    | QuestionOptionUpdateManyWithWhereNestedInput[]
    | QuestionOptionUpdateManyWithWhereNestedInput
  >;
}

export interface QuestionUpdateManyWithWhereNestedInput {
  where: QuestionScalarWhereInput;
  data: QuestionUpdateManyDataInput;
}

export interface QuestionConditionCreateInput {
  id?: Maybe<ID_Input>;
  renderMin?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  matchValue?: Maybe<String>;
}

export type TopicWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QuestionOptionCreateManyInput {
  create?: Maybe<QuestionOptionCreateInput[] | QuestionOptionCreateInput>;
  connect?: Maybe<
    QuestionOptionWhereUniqueInput[] | QuestionOptionWhereUniqueInput
  >;
}

export interface TopicWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  publicTitle?: Maybe<String>;
  publicTitle_not?: Maybe<String>;
  publicTitle_in?: Maybe<String[] | String>;
  publicTitle_not_in?: Maybe<String[] | String>;
  publicTitle_lt?: Maybe<String>;
  publicTitle_lte?: Maybe<String>;
  publicTitle_gt?: Maybe<String>;
  publicTitle_gte?: Maybe<String>;
  publicTitle_contains?: Maybe<String>;
  publicTitle_not_contains?: Maybe<String>;
  publicTitle_starts_with?: Maybe<String>;
  publicTitle_not_starts_with?: Maybe<String>;
  publicTitle_ends_with?: Maybe<String>;
  publicTitle_not_ends_with?: Maybe<String>;
  logoUrl?: Maybe<String>;
  logoUrl_not?: Maybe<String>;
  logoUrl_in?: Maybe<String[] | String>;
  logoUrl_not_in?: Maybe<String[] | String>;
  logoUrl_lt?: Maybe<String>;
  logoUrl_lte?: Maybe<String>;
  logoUrl_gt?: Maybe<String>;
  logoUrl_gte?: Maybe<String>;
  logoUrl_contains?: Maybe<String>;
  logoUrl_not_contains?: Maybe<String>;
  logoUrl_starts_with?: Maybe<String>;
  logoUrl_not_starts_with?: Maybe<String>;
  logoUrl_ends_with?: Maybe<String>;
  logoUrl_not_ends_with?: Maybe<String>;
  language?: Maybe<String>;
  language_not?: Maybe<String>;
  language_in?: Maybe<String[] | String>;
  language_not_in?: Maybe<String[] | String>;
  language_lt?: Maybe<String>;
  language_lte?: Maybe<String>;
  language_gt?: Maybe<String>;
  language_gte?: Maybe<String>;
  language_contains?: Maybe<String>;
  language_not_contains?: Maybe<String>;
  language_starts_with?: Maybe<String>;
  language_not_starts_with?: Maybe<String>;
  language_ends_with?: Maybe<String>;
  language_not_ends_with?: Maybe<String>;
  topicUrl?: Maybe<String>;
  topicUrl_not?: Maybe<String>;
  topicUrl_in?: Maybe<String[] | String>;
  topicUrl_not_in?: Maybe<String[] | String>;
  topicUrl_lt?: Maybe<String>;
  topicUrl_lte?: Maybe<String>;
  topicUrl_gt?: Maybe<String>;
  topicUrl_gte?: Maybe<String>;
  topicUrl_contains?: Maybe<String>;
  topicUrl_not_contains?: Maybe<String>;
  topicUrl_starts_with?: Maybe<String>;
  topicUrl_not_starts_with?: Maybe<String>;
  topicUrl_ends_with?: Maybe<String>;
  topicUrl_not_ends_with?: Maybe<String>;
  questions_every?: Maybe<QuestionWhereInput>;
  questions_some?: Maybe<QuestionWhereInput>;
  questions_none?: Maybe<QuestionWhereInput>;
  AND?: Maybe<TopicWhereInput[] | TopicWhereInput>;
  OR?: Maybe<TopicWhereInput[] | TopicWhereInput>;
  NOT?: Maybe<TopicWhereInput[] | TopicWhereInput>;
}

export interface QuestionOptionCreateInput {
  id?: Maybe<ID_Input>;
  value: String;
  publicValue?: Maybe<String>;
}

export interface TopicSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TopicWhereInput>;
  AND?: Maybe<TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput>;
  OR?: Maybe<TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput>;
  NOT?: Maybe<TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput>;
}

export interface CustomerUpdateInput {
  questionnaires?: Maybe<QuestionnaireUpdateManyInput>;
}

export interface QuestionConditionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionConditionWhereInput>;
  AND?: Maybe<
    | QuestionConditionSubscriptionWhereInput[]
    | QuestionConditionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | QuestionConditionSubscriptionWhereInput[]
    | QuestionConditionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | QuestionConditionSubscriptionWhereInput[]
    | QuestionConditionSubscriptionWhereInput
  >;
}

export interface QuestionnaireUpdateManyInput {
  create?: Maybe<QuestionnaireCreateInput[] | QuestionnaireCreateInput>;
  update?: Maybe<
    | QuestionnaireUpdateWithWhereUniqueNestedInput[]
    | QuestionnaireUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QuestionnaireUpsertWithWhereUniqueNestedInput[]
    | QuestionnaireUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    QuestionnaireWhereUniqueInput[] | QuestionnaireWhereUniqueInput
  >;
  connect?: Maybe<
    QuestionnaireWhereUniqueInput[] | QuestionnaireWhereUniqueInput
  >;
  set?: Maybe<QuestionnaireWhereUniqueInput[] | QuestionnaireWhereUniqueInput>;
  disconnect?: Maybe<
    QuestionnaireWhereUniqueInput[] | QuestionnaireWhereUniqueInput
  >;
  deleteMany?: Maybe<
    QuestionnaireScalarWhereInput[] | QuestionnaireScalarWhereInput
  >;
  updateMany?: Maybe<
    | QuestionnaireUpdateManyWithWhereNestedInput[]
    | QuestionnaireUpdateManyWithWhereNestedInput
  >;
}

export interface CustomerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  questionnaires_every?: Maybe<QuestionnaireWhereInput>;
  questionnaires_some?: Maybe<QuestionnaireWhereInput>;
  questionnaires_none?: Maybe<QuestionnaireWhereInput>;
  AND?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  OR?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  NOT?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
}

export interface QuestionConditionUpdateManyDataInput {
  renderMin?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  matchValue?: Maybe<String>;
}

export interface TopicCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  publicTitle?: Maybe<String>;
  logoUrl?: Maybe<String>;
  language?: Maybe<String>;
  topicUrl?: Maybe<String>;
  questions?: Maybe<QuestionCreateManyInput>;
}

export interface QuestionnaireSettingsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  customerId?: Maybe<ID_Input>;
  customerId_not?: Maybe<ID_Input>;
  customerId_in?: Maybe<ID_Input[] | ID_Input>;
  customerId_not_in?: Maybe<ID_Input[] | ID_Input>;
  customerId_lt?: Maybe<ID_Input>;
  customerId_lte?: Maybe<ID_Input>;
  customerId_gt?: Maybe<ID_Input>;
  customerId_gte?: Maybe<ID_Input>;
  customerId_contains?: Maybe<ID_Input>;
  customerId_not_contains?: Maybe<ID_Input>;
  customerId_starts_with?: Maybe<ID_Input>;
  customerId_not_starts_with?: Maybe<ID_Input>;
  customerId_ends_with?: Maybe<ID_Input>;
  customerId_not_ends_with?: Maybe<ID_Input>;
  questionnaireId?: Maybe<ID_Input>;
  questionnaireId_not?: Maybe<ID_Input>;
  questionnaireId_in?: Maybe<ID_Input[] | ID_Input>;
  questionnaireId_not_in?: Maybe<ID_Input[] | ID_Input>;
  questionnaireId_lt?: Maybe<ID_Input>;
  questionnaireId_lte?: Maybe<ID_Input>;
  questionnaireId_gt?: Maybe<ID_Input>;
  questionnaireId_gte?: Maybe<ID_Input>;
  questionnaireId_contains?: Maybe<ID_Input>;
  questionnaireId_not_contains?: Maybe<ID_Input>;
  questionnaireId_starts_with?: Maybe<ID_Input>;
  questionnaireId_not_starts_with?: Maybe<ID_Input>;
  questionnaireId_ends_with?: Maybe<ID_Input>;
  questionnaireId_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  logo?: Maybe<String>;
  logo_not?: Maybe<String>;
  logo_in?: Maybe<String[] | String>;
  logo_not_in?: Maybe<String[] | String>;
  logo_lt?: Maybe<String>;
  logo_lte?: Maybe<String>;
  logo_gt?: Maybe<String>;
  logo_gte?: Maybe<String>;
  logo_contains?: Maybe<String>;
  logo_not_contains?: Maybe<String>;
  logo_starts_with?: Maybe<String>;
  logo_not_starts_with?: Maybe<String>;
  logo_ends_with?: Maybe<String>;
  logo_not_ends_with?: Maybe<String>;
  colourSettings?: Maybe<ColourSettingsWhereInput>;
  fontSettings?: Maybe<FontSettingsWhereInput>;
  AND?: Maybe<
    QuestionnaireSettingsWhereInput[] | QuestionnaireSettingsWhereInput
  >;
  OR?: Maybe<
    QuestionnaireSettingsWhereInput[] | QuestionnaireSettingsWhereInput
  >;
  NOT?: Maybe<
    QuestionnaireSettingsWhereInput[] | QuestionnaireSettingsWhereInput
  >;
}

export interface QuestionnaireUpdateManyMutationInput {
  customerId?: Maybe<ID_Input>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  publicTitle?: Maybe<String>;
  creationDate?: Maybe<String>;
}

export interface QuestionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  questionnaireId?: Maybe<ID_Input>;
  questionnaireId_not?: Maybe<ID_Input>;
  questionnaireId_in?: Maybe<ID_Input[] | ID_Input>;
  questionnaireId_not_in?: Maybe<ID_Input[] | ID_Input>;
  questionnaireId_lt?: Maybe<ID_Input>;
  questionnaireId_lte?: Maybe<ID_Input>;
  questionnaireId_gt?: Maybe<ID_Input>;
  questionnaireId_gte?: Maybe<ID_Input>;
  questionnaireId_contains?: Maybe<ID_Input>;
  questionnaireId_not_contains?: Maybe<ID_Input>;
  questionnaireId_starts_with?: Maybe<ID_Input>;
  questionnaireId_not_starts_with?: Maybe<ID_Input>;
  questionnaireId_ends_with?: Maybe<ID_Input>;
  questionnaireId_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  overrideLeafId?: Maybe<Int>;
  overrideLeafId_not?: Maybe<Int>;
  overrideLeafId_in?: Maybe<Int[] | Int>;
  overrideLeafId_not_in?: Maybe<Int[] | Int>;
  overrideLeafId_lt?: Maybe<Int>;
  overrideLeafId_lte?: Maybe<Int>;
  overrideLeafId_gt?: Maybe<Int>;
  overrideLeafId_gte?: Maybe<Int>;
  conditions_every?: Maybe<QuestionConditionWhereInput>;
  conditions_some?: Maybe<QuestionConditionWhereInput>;
  conditions_none?: Maybe<QuestionConditionWhereInput>;
  options_every?: Maybe<QuestionOptionWhereInput>;
  options_some?: Maybe<QuestionOptionWhereInput>;
  options_none?: Maybe<QuestionOptionWhereInput>;
  children_every?: Maybe<QuestionWhereInput>;
  children_some?: Maybe<QuestionWhereInput>;
  children_none?: Maybe<QuestionWhereInput>;
  AND?: Maybe<QuestionWhereInput[] | QuestionWhereInput>;
  OR?: Maybe<QuestionWhereInput[] | QuestionWhereInput>;
  NOT?: Maybe<QuestionWhereInput[] | QuestionWhereInput>;
}

export interface QuestionOptionUpdateInput {
  value?: Maybe<String>;
  publicValue?: Maybe<String>;
}

export interface QuestionOptionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  publicValue?: Maybe<String>;
  publicValue_not?: Maybe<String>;
  publicValue_in?: Maybe<String[] | String>;
  publicValue_not_in?: Maybe<String[] | String>;
  publicValue_lt?: Maybe<String>;
  publicValue_lte?: Maybe<String>;
  publicValue_gt?: Maybe<String>;
  publicValue_gte?: Maybe<String>;
  publicValue_contains?: Maybe<String>;
  publicValue_not_contains?: Maybe<String>;
  publicValue_starts_with?: Maybe<String>;
  publicValue_not_starts_with?: Maybe<String>;
  publicValue_ends_with?: Maybe<String>;
  publicValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<QuestionOptionWhereInput[] | QuestionOptionWhereInput>;
  OR?: Maybe<QuestionOptionWhereInput[] | QuestionOptionWhereInput>;
  NOT?: Maybe<QuestionOptionWhereInput[] | QuestionOptionWhereInput>;
}

export interface QuestionUpdateManyMutationInput {
  questionnaireId?: Maybe<ID_Input>;
  title?: Maybe<String>;
  type?: Maybe<String>;
  overrideLeafId?: Maybe<Int>;
}

export interface QuestionConditionUpdateManyWithWhereNestedInput {
  where: QuestionConditionScalarWhereInput;
  data: QuestionConditionUpdateManyDataInput;
}

export interface FontSettingsUpdateInput {
  settingTitle?: Maybe<String>;
  body?: Maybe<String>;
  fontTitle?: Maybe<String>;
  special?: Maybe<String>;
}

export interface ColourSettingsUpdateDataInput {
  title?: Maybe<String>;
  primary?: Maybe<String>;
  secondary?: Maybe<String>;
  tertiary?: Maybe<String>;
  success?: Maybe<String>;
  warning?: Maybe<String>;
  error?: Maybe<String>;
  lightest?: Maybe<String>;
  light?: Maybe<String>;
  normal?: Maybe<String>;
  dark?: Maybe<String>;
  darkest?: Maybe<String>;
  muted?: Maybe<String>;
  text?: Maybe<String>;
}

export interface QuestionnaireScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  customerId?: Maybe<ID_Input>;
  customerId_not?: Maybe<ID_Input>;
  customerId_in?: Maybe<ID_Input[] | ID_Input>;
  customerId_not_in?: Maybe<ID_Input[] | ID_Input>;
  customerId_lt?: Maybe<ID_Input>;
  customerId_lte?: Maybe<ID_Input>;
  customerId_gt?: Maybe<ID_Input>;
  customerId_gte?: Maybe<ID_Input>;
  customerId_contains?: Maybe<ID_Input>;
  customerId_not_contains?: Maybe<ID_Input>;
  customerId_starts_with?: Maybe<ID_Input>;
  customerId_not_starts_with?: Maybe<ID_Input>;
  customerId_ends_with?: Maybe<ID_Input>;
  customerId_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  publicTitle?: Maybe<String>;
  publicTitle_not?: Maybe<String>;
  publicTitle_in?: Maybe<String[] | String>;
  publicTitle_not_in?: Maybe<String[] | String>;
  publicTitle_lt?: Maybe<String>;
  publicTitle_lte?: Maybe<String>;
  publicTitle_gt?: Maybe<String>;
  publicTitle_gte?: Maybe<String>;
  publicTitle_contains?: Maybe<String>;
  publicTitle_not_contains?: Maybe<String>;
  publicTitle_starts_with?: Maybe<String>;
  publicTitle_not_starts_with?: Maybe<String>;
  publicTitle_ends_with?: Maybe<String>;
  publicTitle_not_ends_with?: Maybe<String>;
  creationDate?: Maybe<String>;
  creationDate_not?: Maybe<String>;
  creationDate_in?: Maybe<String[] | String>;
  creationDate_not_in?: Maybe<String[] | String>;
  creationDate_lt?: Maybe<String>;
  creationDate_lte?: Maybe<String>;
  creationDate_gt?: Maybe<String>;
  creationDate_gte?: Maybe<String>;
  creationDate_contains?: Maybe<String>;
  creationDate_not_contains?: Maybe<String>;
  creationDate_starts_with?: Maybe<String>;
  creationDate_not_starts_with?: Maybe<String>;
  creationDate_ends_with?: Maybe<String>;
  creationDate_not_ends_with?: Maybe<String>;
  AND?: Maybe<QuestionnaireScalarWhereInput[] | QuestionnaireScalarWhereInput>;
  OR?: Maybe<QuestionnaireScalarWhereInput[] | QuestionnaireScalarWhereInput>;
  NOT?: Maybe<QuestionnaireScalarWhereInput[] | QuestionnaireScalarWhereInput>;
}

export interface ColourSettingsUpsertNestedInput {
  update: ColourSettingsUpdateDataInput;
  create: ColourSettingsCreateInput;
}

export interface QuestionUpdateManyDataInput {
  questionnaireId?: Maybe<ID_Input>;
  title?: Maybe<String>;
  type?: Maybe<String>;
  overrideLeafId?: Maybe<Int>;
}

export interface FontSettingsUpdateOneRequiredInput {
  create?: Maybe<FontSettingsCreateInput>;
  update?: Maybe<FontSettingsUpdateDataInput>;
  upsert?: Maybe<FontSettingsUpsertNestedInput>;
  connect?: Maybe<FontSettingsWhereUniqueInput>;
}

export interface QuestionUpsertWithWhereUniqueNestedInput {
  where: QuestionWhereUniqueInput;
  update: QuestionUpdateDataInput;
  create: QuestionCreateInput;
}

export interface FontSettingsUpdateDataInput {
  settingTitle?: Maybe<String>;
  body?: Maybe<String>;
  fontTitle?: Maybe<String>;
  special?: Maybe<String>;
}

export interface QuestionnaireSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionnaireWhereInput>;
  AND?: Maybe<
    QuestionnaireSubscriptionWhereInput[] | QuestionnaireSubscriptionWhereInput
  >;
  OR?: Maybe<
    QuestionnaireSubscriptionWhereInput[] | QuestionnaireSubscriptionWhereInput
  >;
  NOT?: Maybe<
    QuestionnaireSubscriptionWhereInput[] | QuestionnaireSubscriptionWhereInput
  >;
}

export interface FontSettingsUpsertNestedInput {
  update: FontSettingsUpdateDataInput;
  create: FontSettingsCreateInput;
}

export interface TopicUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  publicTitle?: Maybe<String>;
  logoUrl?: Maybe<String>;
  language?: Maybe<String>;
  topicUrl?: Maybe<String>;
}

export interface QuestionnaireSettingsUpsertNestedInput {
  update: QuestionnaireSettingsUpdateDataInput;
  create: QuestionnaireSettingsCreateInput;
}

export type QuestionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QuestionUpdateManyInput {
  create?: Maybe<QuestionCreateInput[] | QuestionCreateInput>;
  update?: Maybe<
    | QuestionUpdateWithWhereUniqueNestedInput[]
    | QuestionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QuestionUpsertWithWhereUniqueNestedInput[]
    | QuestionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
  connect?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
  set?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
  disconnect?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
  deleteMany?: Maybe<QuestionScalarWhereInput[] | QuestionScalarWhereInput>;
  updateMany?: Maybe<
    | QuestionUpdateManyWithWhereNestedInput[]
    | QuestionUpdateManyWithWhereNestedInput
  >;
}

export type QuestionOptionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QuestionUpdateWithWhereUniqueNestedInput {
  where: QuestionWhereUniqueInput;
  data: QuestionUpdateDataInput;
}

export type QuestionnaireSettingsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QuestionUpdateDataInput {
  questionnaireId?: Maybe<ID_Input>;
  title?: Maybe<String>;
  type?: Maybe<String>;
  overrideLeafId?: Maybe<Int>;
  conditions?: Maybe<QuestionConditionUpdateManyInput>;
  options?: Maybe<QuestionOptionUpdateManyInput>;
  children?: Maybe<QuestionUpdateManyInput>;
}

export interface QuestionOptionUpdateManyDataInput {
  value?: Maybe<String>;
  publicValue?: Maybe<String>;
}

export interface QuestionConditionUpsertWithWhereUniqueNestedInput {
  where: QuestionConditionWhereUniqueInput;
  update: QuestionConditionUpdateDataInput;
  create: QuestionConditionCreateInput;
}

export interface QuestionConditionUpdateDataInput {
  renderMin?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  matchValue?: Maybe<String>;
}

export interface QuestionConditionUpdateWithWhereUniqueNestedInput {
  where: QuestionConditionWhereUniqueInput;
  data: QuestionConditionUpdateDataInput;
}

export interface QuestionConditionUpdateManyInput {
  create?: Maybe<QuestionConditionCreateInput[] | QuestionConditionCreateInput>;
  update?: Maybe<
    | QuestionConditionUpdateWithWhereUniqueNestedInput[]
    | QuestionConditionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QuestionConditionUpsertWithWhereUniqueNestedInput[]
    | QuestionConditionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    QuestionConditionWhereUniqueInput[] | QuestionConditionWhereUniqueInput
  >;
  connect?: Maybe<
    QuestionConditionWhereUniqueInput[] | QuestionConditionWhereUniqueInput
  >;
  set?: Maybe<
    QuestionConditionWhereUniqueInput[] | QuestionConditionWhereUniqueInput
  >;
  disconnect?: Maybe<
    QuestionConditionWhereUniqueInput[] | QuestionConditionWhereUniqueInput
  >;
  deleteMany?: Maybe<
    QuestionConditionScalarWhereInput[] | QuestionConditionScalarWhereInput
  >;
  updateMany?: Maybe<
    | QuestionConditionUpdateManyWithWhereNestedInput[]
    | QuestionConditionUpdateManyWithWhereNestedInput
  >;
}

export interface FontSettingsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FontSettingsWhereInput>;
  AND?: Maybe<
    FontSettingsSubscriptionWhereInput[] | FontSettingsSubscriptionWhereInput
  >;
  OR?: Maybe<
    FontSettingsSubscriptionWhereInput[] | FontSettingsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    FontSettingsSubscriptionWhereInput[] | FontSettingsSubscriptionWhereInput
  >;
}

export interface QuestionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  questionnaireId?: Maybe<ID_Input>;
  questionnaireId_not?: Maybe<ID_Input>;
  questionnaireId_in?: Maybe<ID_Input[] | ID_Input>;
  questionnaireId_not_in?: Maybe<ID_Input[] | ID_Input>;
  questionnaireId_lt?: Maybe<ID_Input>;
  questionnaireId_lte?: Maybe<ID_Input>;
  questionnaireId_gt?: Maybe<ID_Input>;
  questionnaireId_gte?: Maybe<ID_Input>;
  questionnaireId_contains?: Maybe<ID_Input>;
  questionnaireId_not_contains?: Maybe<ID_Input>;
  questionnaireId_starts_with?: Maybe<ID_Input>;
  questionnaireId_not_starts_with?: Maybe<ID_Input>;
  questionnaireId_ends_with?: Maybe<ID_Input>;
  questionnaireId_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  overrideLeafId?: Maybe<Int>;
  overrideLeafId_not?: Maybe<Int>;
  overrideLeafId_in?: Maybe<Int[] | Int>;
  overrideLeafId_not_in?: Maybe<Int[] | Int>;
  overrideLeafId_lt?: Maybe<Int>;
  overrideLeafId_lte?: Maybe<Int>;
  overrideLeafId_gt?: Maybe<Int>;
  overrideLeafId_gte?: Maybe<Int>;
  AND?: Maybe<QuestionScalarWhereInput[] | QuestionScalarWhereInput>;
  OR?: Maybe<QuestionScalarWhereInput[] | QuestionScalarWhereInput>;
  NOT?: Maybe<QuestionScalarWhereInput[] | QuestionScalarWhereInput>;
}

export type QuestionnaireWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type QuestionConditionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QuestionnaireSettingsUpdateManyMutationInput {
  customerId?: Maybe<ID_Input>;
  questionnaireId?: Maybe<ID_Input>;
  title?: Maybe<String>;
  logo?: Maybe<String>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface TopicPreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  publicTitle?: String;
  logoUrl?: String;
  language?: String;
  topicUrl?: String;
}

export interface TopicPreviousValuesPromise
  extends Promise<TopicPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  publicTitle: () => Promise<String>;
  logoUrl: () => Promise<String>;
  language: () => Promise<String>;
  topicUrl: () => Promise<String>;
}

export interface TopicPreviousValuesSubscription
  extends Promise<AsyncIterator<TopicPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  publicTitle: () => Promise<AsyncIterator<String>>;
  logoUrl: () => Promise<AsyncIterator<String>>;
  language: () => Promise<AsyncIterator<String>>;
  topicUrl: () => Promise<AsyncIterator<String>>;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateColourSettings {
  count: Int;
}

export interface AggregateColourSettingsPromise
  extends Promise<AggregateColourSettings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateColourSettingsSubscription
  extends Promise<AsyncIterator<AggregateColourSettings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface Questionnaire {
  id: ID_Output;
  customerId: ID_Output;
  title: String;
  description: String;
  publicTitle?: String;
  creationDate: String;
}

export interface QuestionnairePromise
  extends Promise<Questionnaire>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customerId: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  publicTitle: () => Promise<String>;
  setting: <T = QuestionnaireSettingsPromise>() => T;
  creationDate: () => Promise<String>;
  questions: <T = FragmentableArray<Question>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuestionnaireSubscription
  extends Promise<AsyncIterator<Questionnaire>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customerId: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  publicTitle: () => Promise<AsyncIterator<String>>;
  setting: <T = QuestionnaireSettingsSubscription>() => T;
  creationDate: () => Promise<AsyncIterator<String>>;
  questions: <T = Promise<AsyncIterator<QuestionSubscription>>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuestionnaireNullablePromise
  extends Promise<Questionnaire | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customerId: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  publicTitle: () => Promise<String>;
  setting: <T = QuestionnaireSettingsPromise>() => T;
  creationDate: () => Promise<String>;
  questions: <T = FragmentableArray<Question>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ColourSettingsConnection {
  pageInfo: PageInfo;
  edges: ColourSettingsEdge[];
}

export interface ColourSettingsConnectionPromise
  extends Promise<ColourSettingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ColourSettingsEdge>>() => T;
  aggregate: <T = AggregateColourSettingsPromise>() => T;
}

export interface ColourSettingsConnectionSubscription
  extends Promise<AsyncIterator<ColourSettingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ColourSettingsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateColourSettingsSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ColourSettings {
  id: ID_Output;
  title?: String;
  primary: String;
  secondary: String;
  tertiary: String;
  success: String;
  warning: String;
  error: String;
  lightest: String;
  light: String;
  normal: String;
  dark: String;
  darkest: String;
  muted: String;
  text: String;
}

export interface ColourSettingsPromise
  extends Promise<ColourSettings>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  primary: () => Promise<String>;
  secondary: () => Promise<String>;
  tertiary: () => Promise<String>;
  success: () => Promise<String>;
  warning: () => Promise<String>;
  error: () => Promise<String>;
  lightest: () => Promise<String>;
  light: () => Promise<String>;
  normal: () => Promise<String>;
  dark: () => Promise<String>;
  darkest: () => Promise<String>;
  muted: () => Promise<String>;
  text: () => Promise<String>;
}

export interface ColourSettingsSubscription
  extends Promise<AsyncIterator<ColourSettings>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  primary: () => Promise<AsyncIterator<String>>;
  secondary: () => Promise<AsyncIterator<String>>;
  tertiary: () => Promise<AsyncIterator<String>>;
  success: () => Promise<AsyncIterator<String>>;
  warning: () => Promise<AsyncIterator<String>>;
  error: () => Promise<AsyncIterator<String>>;
  lightest: () => Promise<AsyncIterator<String>>;
  light: () => Promise<AsyncIterator<String>>;
  normal: () => Promise<AsyncIterator<String>>;
  dark: () => Promise<AsyncIterator<String>>;
  darkest: () => Promise<AsyncIterator<String>>;
  muted: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface ColourSettingsNullablePromise
  extends Promise<ColourSettings | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  primary: () => Promise<String>;
  secondary: () => Promise<String>;
  tertiary: () => Promise<String>;
  success: () => Promise<String>;
  warning: () => Promise<String>;
  error: () => Promise<String>;
  lightest: () => Promise<String>;
  light: () => Promise<String>;
  normal: () => Promise<String>;
  dark: () => Promise<String>;
  darkest: () => Promise<String>;
  muted: () => Promise<String>;
  text: () => Promise<String>;
}

export interface TopicEdge {
  node: Topic;
  cursor: String;
}

export interface TopicEdgePromise extends Promise<TopicEdge>, Fragmentable {
  node: <T = TopicPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TopicEdgeSubscription
  extends Promise<AsyncIterator<TopicEdge>>,
    Fragmentable {
  node: <T = TopicSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTopic {
  count: Int;
}

export interface AggregateTopicPromise
  extends Promise<AggregateTopic>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTopicSubscription
  extends Promise<AsyncIterator<AggregateTopic>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionnaireSettingsSubscriptionPayload {
  mutation: MutationType;
  node: QuestionnaireSettings;
  updatedFields: String[];
  previousValues: QuestionnaireSettingsPreviousValues;
}

export interface QuestionnaireSettingsSubscriptionPayloadPromise
  extends Promise<QuestionnaireSettingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionnaireSettingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionnaireSettingsPreviousValuesPromise>() => T;
}

export interface QuestionnaireSettingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionnaireSettingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionnaireSettingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionnaireSettingsPreviousValuesSubscription>() => T;
}

export interface TopicConnection {
  pageInfo: PageInfo;
  edges: TopicEdge[];
}

export interface TopicConnectionPromise
  extends Promise<TopicConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TopicEdge>>() => T;
  aggregate: <T = AggregateTopicPromise>() => T;
}

export interface TopicConnectionSubscription
  extends Promise<AsyncIterator<TopicConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TopicEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTopicSubscription>() => T;
}

export interface ColourSettingsSubscriptionPayload {
  mutation: MutationType;
  node: ColourSettings;
  updatedFields: String[];
  previousValues: ColourSettingsPreviousValues;
}

export interface ColourSettingsSubscriptionPayloadPromise
  extends Promise<ColourSettingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ColourSettingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ColourSettingsPreviousValuesPromise>() => T;
}

export interface ColourSettingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ColourSettingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ColourSettingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ColourSettingsPreviousValuesSubscription>() => T;
}

export interface Topic {
  id: ID_Output;
  title: String;
  description: String;
  publicTitle?: String;
  logoUrl?: String;
  language?: String;
  topicUrl?: String;
}

export interface TopicPromise extends Promise<Topic>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  publicTitle: () => Promise<String>;
  logoUrl: () => Promise<String>;
  language: () => Promise<String>;
  topicUrl: () => Promise<String>;
  questions: <T = FragmentableArray<Question>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TopicSubscription
  extends Promise<AsyncIterator<Topic>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  publicTitle: () => Promise<AsyncIterator<String>>;
  logoUrl: () => Promise<AsyncIterator<String>>;
  language: () => Promise<AsyncIterator<String>>;
  topicUrl: () => Promise<AsyncIterator<String>>;
  questions: <T = Promise<AsyncIterator<QuestionSubscription>>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TopicNullablePromise
  extends Promise<Topic | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  publicTitle: () => Promise<String>;
  logoUrl: () => Promise<String>;
  language: () => Promise<String>;
  topicUrl: () => Promise<String>;
  questions: <T = FragmentableArray<Question>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuestionnaireSettingsEdge {
  node: QuestionnaireSettings;
  cursor: String;
}

export interface QuestionnaireSettingsEdgePromise
  extends Promise<QuestionnaireSettingsEdge>,
    Fragmentable {
  node: <T = QuestionnaireSettingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionnaireSettingsEdgeSubscription
  extends Promise<AsyncIterator<QuestionnaireSettingsEdge>>,
    Fragmentable {
  node: <T = QuestionnaireSettingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ColourSettingsPreviousValues {
  id: ID_Output;
  title?: String;
  primary: String;
  secondary: String;
  tertiary: String;
  success: String;
  warning: String;
  error: String;
  lightest: String;
  light: String;
  normal: String;
  dark: String;
  darkest: String;
  muted: String;
  text: String;
}

export interface ColourSettingsPreviousValuesPromise
  extends Promise<ColourSettingsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  primary: () => Promise<String>;
  secondary: () => Promise<String>;
  tertiary: () => Promise<String>;
  success: () => Promise<String>;
  warning: () => Promise<String>;
  error: () => Promise<String>;
  lightest: () => Promise<String>;
  light: () => Promise<String>;
  normal: () => Promise<String>;
  dark: () => Promise<String>;
  darkest: () => Promise<String>;
  muted: () => Promise<String>;
  text: () => Promise<String>;
}

export interface ColourSettingsPreviousValuesSubscription
  extends Promise<AsyncIterator<ColourSettingsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  primary: () => Promise<AsyncIterator<String>>;
  secondary: () => Promise<AsyncIterator<String>>;
  tertiary: () => Promise<AsyncIterator<String>>;
  success: () => Promise<AsyncIterator<String>>;
  warning: () => Promise<AsyncIterator<String>>;
  error: () => Promise<AsyncIterator<String>>;
  lightest: () => Promise<AsyncIterator<String>>;
  light: () => Promise<AsyncIterator<String>>;
  normal: () => Promise<AsyncIterator<String>>;
  dark: () => Promise<AsyncIterator<String>>;
  darkest: () => Promise<AsyncIterator<String>>;
  muted: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuestionnaire {
  count: Int;
}

export interface AggregateQuestionnairePromise
  extends Promise<AggregateQuestionnaire>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionnaireSubscription
  extends Promise<AsyncIterator<AggregateQuestionnaire>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionOption {
  id: ID_Output;
  value: String;
  publicValue?: String;
}

export interface QuestionOptionPromise
  extends Promise<QuestionOption>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  publicValue: () => Promise<String>;
}

export interface QuestionOptionSubscription
  extends Promise<AsyncIterator<QuestionOption>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  publicValue: () => Promise<AsyncIterator<String>>;
}

export interface QuestionOptionNullablePromise
  extends Promise<QuestionOption | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  publicValue: () => Promise<String>;
}

export interface QuestionnaireConnection {
  pageInfo: PageInfo;
  edges: QuestionnaireEdge[];
}

export interface QuestionnaireConnectionPromise
  extends Promise<QuestionnaireConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionnaireEdge>>() => T;
  aggregate: <T = AggregateQuestionnairePromise>() => T;
}

export interface QuestionnaireConnectionSubscription
  extends Promise<AsyncIterator<QuestionnaireConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionnaireEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionnaireSubscription>() => T;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface QuestionOptionEdge {
  node: QuestionOption;
  cursor: String;
}

export interface QuestionOptionEdgePromise
  extends Promise<QuestionOptionEdge>,
    Fragmentable {
  node: <T = QuestionOptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionOptionEdgeSubscription
  extends Promise<AsyncIterator<QuestionOptionEdge>>,
    Fragmentable {
  node: <T = QuestionOptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CustomerPreviousValues {
  id: ID_Output;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateQuestionCondition {
  count: Int;
}

export interface AggregateQuestionConditionPromise
  extends Promise<AggregateQuestionCondition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionConditionSubscription
  extends Promise<AsyncIterator<AggregateQuestionCondition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface QuestionConditionConnection {
  pageInfo: PageInfo;
  edges: QuestionConditionEdge[];
}

export interface QuestionConditionConnectionPromise
  extends Promise<QuestionConditionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionConditionEdge>>() => T;
  aggregate: <T = AggregateQuestionConditionPromise>() => T;
}

export interface QuestionConditionConnectionSubscription
  extends Promise<AsyncIterator<QuestionConditionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionConditionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionConditionSubscription>() => T;
}

export interface FontSettingsSubscriptionPayload {
  mutation: MutationType;
  node: FontSettings;
  updatedFields: String[];
  previousValues: FontSettingsPreviousValues;
}

export interface FontSettingsSubscriptionPayloadPromise
  extends Promise<FontSettingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FontSettingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FontSettingsPreviousValuesPromise>() => T;
}

export interface FontSettingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FontSettingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FontSettingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FontSettingsPreviousValuesSubscription>() => T;
}

export interface QuestionEdge {
  node: Question;
  cursor: String;
}

export interface QuestionEdgePromise
  extends Promise<QuestionEdge>,
    Fragmentable {
  node: <T = QuestionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionEdgeSubscription
  extends Promise<AsyncIterator<QuestionEdge>>,
    Fragmentable {
  node: <T = QuestionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FontSettingsPreviousValues {
  id: ID_Output;
  settingTitle?: String;
  body?: String;
  fontTitle?: String;
  special?: String;
}

export interface FontSettingsPreviousValuesPromise
  extends Promise<FontSettingsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  settingTitle: () => Promise<String>;
  body: () => Promise<String>;
  fontTitle: () => Promise<String>;
  special: () => Promise<String>;
}

export interface FontSettingsPreviousValuesSubscription
  extends Promise<AsyncIterator<FontSettingsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  settingTitle: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  fontTitle: () => Promise<AsyncIterator<String>>;
  special: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFontSettings {
  count: Int;
}

export interface AggregateFontSettingsPromise
  extends Promise<AggregateFontSettings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFontSettingsSubscription
  extends Promise<AsyncIterator<AggregateFontSettings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionCondition {
  id: ID_Output;
  renderMin?: Int;
  renderMax?: Int;
  matchValue?: String;
}

export interface QuestionConditionPromise
  extends Promise<QuestionCondition>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  renderMin: () => Promise<Int>;
  renderMax: () => Promise<Int>;
  matchValue: () => Promise<String>;
}

export interface QuestionConditionSubscription
  extends Promise<AsyncIterator<QuestionCondition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  renderMin: () => Promise<AsyncIterator<Int>>;
  renderMax: () => Promise<AsyncIterator<Int>>;
  matchValue: () => Promise<AsyncIterator<String>>;
}

export interface QuestionConditionNullablePromise
  extends Promise<QuestionCondition | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  renderMin: () => Promise<Int>;
  renderMax: () => Promise<Int>;
  matchValue: () => Promise<String>;
}

export interface FontSettingsConnection {
  pageInfo: PageInfo;
  edges: FontSettingsEdge[];
}

export interface FontSettingsConnectionPromise
  extends Promise<FontSettingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FontSettingsEdge>>() => T;
  aggregate: <T = AggregateFontSettingsPromise>() => T;
}

export interface FontSettingsConnectionSubscription
  extends Promise<AsyncIterator<FontSettingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FontSettingsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFontSettingsSubscription>() => T;
}

export interface QuestionSubscriptionPayload {
  mutation: MutationType;
  node: Question;
  updatedFields: String[];
  previousValues: QuestionPreviousValues;
}

export interface QuestionSubscriptionPayloadPromise
  extends Promise<QuestionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionPreviousValuesPromise>() => T;
}

export interface QuestionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionPreviousValuesSubscription>() => T;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionPreviousValues {
  id: ID_Output;
  questionnaireId: ID_Output;
  title: String;
  type: String;
  overrideLeafId?: Int;
}

export interface QuestionPreviousValuesPromise
  extends Promise<QuestionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  questionnaireId: () => Promise<ID_Output>;
  title: () => Promise<String>;
  type: () => Promise<String>;
  overrideLeafId: () => Promise<Int>;
}

export interface QuestionPreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  questionnaireId: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  overrideLeafId: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionnaireSettings {
  id: ID_Output;
  customerId: ID_Output;
  questionnaireId: ID_Output;
  title?: String;
  logo?: String;
}

export interface QuestionnaireSettingsPromise
  extends Promise<QuestionnaireSettings>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customerId: () => Promise<ID_Output>;
  questionnaireId: () => Promise<ID_Output>;
  title: () => Promise<String>;
  logo: () => Promise<String>;
  colourSettings: <T = ColourSettingsPromise>() => T;
  fontSettings: <T = FontSettingsPromise>() => T;
}

export interface QuestionnaireSettingsSubscription
  extends Promise<AsyncIterator<QuestionnaireSettings>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customerId: () => Promise<AsyncIterator<ID_Output>>;
  questionnaireId: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
  colourSettings: <T = ColourSettingsSubscription>() => T;
  fontSettings: <T = FontSettingsSubscription>() => T;
}

export interface QuestionnaireSettingsNullablePromise
  extends Promise<QuestionnaireSettings | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customerId: () => Promise<ID_Output>;
  questionnaireId: () => Promise<ID_Output>;
  title: () => Promise<String>;
  logo: () => Promise<String>;
  colourSettings: <T = ColourSettingsPromise>() => T;
  fontSettings: <T = FontSettingsPromise>() => T;
}

export interface QuestionnaireSettingsPreviousValues {
  id: ID_Output;
  customerId: ID_Output;
  questionnaireId: ID_Output;
  title?: String;
  logo?: String;
}

export interface QuestionnaireSettingsPreviousValuesPromise
  extends Promise<QuestionnaireSettingsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customerId: () => Promise<ID_Output>;
  questionnaireId: () => Promise<ID_Output>;
  title: () => Promise<String>;
  logo: () => Promise<String>;
}

export interface QuestionnaireSettingsPreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionnaireSettingsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customerId: () => Promise<AsyncIterator<ID_Output>>;
  questionnaireId: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
}

export interface QuestionnaireSettingsConnection {
  pageInfo: PageInfo;
  edges: QuestionnaireSettingsEdge[];
}

export interface QuestionnaireSettingsConnectionPromise
  extends Promise<QuestionnaireSettingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionnaireSettingsEdge>>() => T;
  aggregate: <T = AggregateQuestionnaireSettingsPromise>() => T;
}

export interface QuestionnaireSettingsConnectionSubscription
  extends Promise<AsyncIterator<QuestionnaireSettingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<QuestionnaireSettingsEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateQuestionnaireSettingsSubscription>() => T;
}

export interface QuestionConditionSubscriptionPayload {
  mutation: MutationType;
  node: QuestionCondition;
  updatedFields: String[];
  previousValues: QuestionConditionPreviousValues;
}

export interface QuestionConditionSubscriptionPayloadPromise
  extends Promise<QuestionConditionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionConditionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionConditionPreviousValuesPromise>() => T;
}

export interface QuestionConditionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionConditionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionConditionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionConditionPreviousValuesSubscription>() => T;
}

export interface AggregateQuestionOption {
  count: Int;
}

export interface AggregateQuestionOptionPromise
  extends Promise<AggregateQuestionOption>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionOptionSubscription
  extends Promise<AsyncIterator<AggregateQuestionOption>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionConditionPreviousValues {
  id: ID_Output;
  renderMin?: Int;
  renderMax?: Int;
  matchValue?: String;
}

export interface QuestionConditionPreviousValuesPromise
  extends Promise<QuestionConditionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  renderMin: () => Promise<Int>;
  renderMax: () => Promise<Int>;
  matchValue: () => Promise<String>;
}

export interface QuestionConditionPreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionConditionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  renderMin: () => Promise<AsyncIterator<Int>>;
  renderMax: () => Promise<AsyncIterator<Int>>;
  matchValue: () => Promise<AsyncIterator<String>>;
}

export interface QuestionConditionEdge {
  node: QuestionCondition;
  cursor: String;
}

export interface QuestionConditionEdgePromise
  extends Promise<QuestionConditionEdge>,
    Fragmentable {
  node: <T = QuestionConditionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionConditionEdgeSubscription
  extends Promise<AsyncIterator<QuestionConditionEdge>>,
    Fragmentable {
  node: <T = QuestionConditionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Question {
  id: ID_Output;
  questionnaireId: ID_Output;
  title: String;
  type: String;
  overrideLeafId?: Int;
}

export interface QuestionPromise extends Promise<Question>, Fragmentable {
  id: () => Promise<ID_Output>;
  questionnaireId: () => Promise<ID_Output>;
  title: () => Promise<String>;
  type: () => Promise<String>;
  overrideLeafId: () => Promise<Int>;
  conditions: <T = FragmentableArray<QuestionCondition>>(args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  options: <T = FragmentableArray<QuestionOption>>(args?: {
    where?: QuestionOptionWhereInput;
    orderBy?: QuestionOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = FragmentableArray<Question>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuestionSubscription
  extends Promise<AsyncIterator<Question>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  questionnaireId: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  overrideLeafId: () => Promise<AsyncIterator<Int>>;
  conditions: <
    T = Promise<AsyncIterator<QuestionConditionSubscription>>
  >(args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  options: <T = Promise<AsyncIterator<QuestionOptionSubscription>>>(args?: {
    where?: QuestionOptionWhereInput;
    orderBy?: QuestionOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = Promise<AsyncIterator<QuestionSubscription>>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuestionNullablePromise
  extends Promise<Question | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  questionnaireId: () => Promise<ID_Output>;
  title: () => Promise<String>;
  type: () => Promise<String>;
  overrideLeafId: () => Promise<Int>;
  conditions: <T = FragmentableArray<QuestionCondition>>(args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  options: <T = FragmentableArray<QuestionOption>>(args?: {
    where?: QuestionOptionWhereInput;
    orderBy?: QuestionOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = FragmentableArray<Question>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuestionConnection {
  pageInfo: PageInfo;
  edges: QuestionEdge[];
}

export interface QuestionConnectionPromise
  extends Promise<QuestionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionEdge>>() => T;
  aggregate: <T = AggregateQuestionPromise>() => T;
}

export interface QuestionConnectionSubscription
  extends Promise<AsyncIterator<QuestionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionSubscription>() => T;
}

export interface QuestionOptionSubscriptionPayload {
  mutation: MutationType;
  node: QuestionOption;
  updatedFields: String[];
  previousValues: QuestionOptionPreviousValues;
}

export interface QuestionOptionSubscriptionPayloadPromise
  extends Promise<QuestionOptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionOptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionOptionPreviousValuesPromise>() => T;
}

export interface QuestionOptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionOptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionOptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionOptionPreviousValuesSubscription>() => T;
}

export interface TopicSubscriptionPayload {
  mutation: MutationType;
  node: Topic;
  updatedFields: String[];
  previousValues: TopicPreviousValues;
}

export interface TopicSubscriptionPayloadPromise
  extends Promise<TopicSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TopicPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TopicPreviousValuesPromise>() => T;
}

export interface TopicSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TopicSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TopicSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TopicPreviousValuesSubscription>() => T;
}

export interface QuestionOptionPreviousValues {
  id: ID_Output;
  value: String;
  publicValue?: String;
}

export interface QuestionOptionPreviousValuesPromise
  extends Promise<QuestionOptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  publicValue: () => Promise<String>;
}

export interface QuestionOptionPreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionOptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  publicValue: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuestionnaireSettings {
  count: Int;
}

export interface AggregateQuestionnaireSettingsPromise
  extends Promise<AggregateQuestionnaireSettings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionnaireSettingsSubscription
  extends Promise<AsyncIterator<AggregateQuestionnaireSettings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionOptionConnection {
  pageInfo: PageInfo;
  edges: QuestionOptionEdge[];
}

export interface QuestionOptionConnectionPromise
  extends Promise<QuestionOptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionOptionEdge>>() => T;
  aggregate: <T = AggregateQuestionOptionPromise>() => T;
}

export interface QuestionOptionConnectionSubscription
  extends Promise<AsyncIterator<QuestionOptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionOptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionOptionSubscription>() => T;
}

export interface FontSettings {
  id: ID_Output;
  settingTitle?: String;
  body?: String;
  fontTitle?: String;
  special?: String;
}

export interface FontSettingsPromise
  extends Promise<FontSettings>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  settingTitle: () => Promise<String>;
  body: () => Promise<String>;
  fontTitle: () => Promise<String>;
  special: () => Promise<String>;
}

export interface FontSettingsSubscription
  extends Promise<AsyncIterator<FontSettings>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  settingTitle: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  fontTitle: () => Promise<AsyncIterator<String>>;
  special: () => Promise<AsyncIterator<String>>;
}

export interface FontSettingsNullablePromise
  extends Promise<FontSettings | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  settingTitle: () => Promise<String>;
  body: () => Promise<String>;
  fontTitle: () => Promise<String>;
  special: () => Promise<String>;
}

export interface QuestionnairePreviousValues {
  id: ID_Output;
  customerId: ID_Output;
  title: String;
  description: String;
  publicTitle?: String;
  creationDate: String;
}

export interface QuestionnairePreviousValuesPromise
  extends Promise<QuestionnairePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customerId: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  publicTitle: () => Promise<String>;
  creationDate: () => Promise<String>;
}

export interface QuestionnairePreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionnairePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customerId: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  publicTitle: () => Promise<AsyncIterator<String>>;
  creationDate: () => Promise<AsyncIterator<String>>;
}

export interface QuestionnaireSubscriptionPayload {
  mutation: MutationType;
  node: Questionnaire;
  updatedFields: String[];
  previousValues: QuestionnairePreviousValues;
}

export interface QuestionnaireSubscriptionPayloadPromise
  extends Promise<QuestionnaireSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionnairePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionnairePreviousValuesPromise>() => T;
}

export interface QuestionnaireSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionnaireSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionnaireSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionnairePreviousValuesSubscription>() => T;
}

export interface ColourSettingsEdge {
  node: ColourSettings;
  cursor: String;
}

export interface ColourSettingsEdgePromise
  extends Promise<ColourSettingsEdge>,
    Fragmentable {
  node: <T = ColourSettingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ColourSettingsEdgeSubscription
  extends Promise<AsyncIterator<ColourSettingsEdge>>,
    Fragmentable {
  node: <T = ColourSettingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuestion {
  count: Int;
}

export interface AggregateQuestionPromise
  extends Promise<AggregateQuestion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionSubscription
  extends Promise<AsyncIterator<AggregateQuestion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionnaireEdge {
  node: Questionnaire;
  cursor: String;
}

export interface QuestionnaireEdgePromise
  extends Promise<QuestionnaireEdge>,
    Fragmentable {
  node: <T = QuestionnairePromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionnaireEdgeSubscription
  extends Promise<AsyncIterator<QuestionnaireEdge>>,
    Fragmentable {
  node: <T = QuestionnaireSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Customer {
  id: ID_Output;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  id: () => Promise<ID_Output>;
  questionnaires: <T = FragmentableArray<Questionnaire>>(args?: {
    where?: QuestionnaireWhereInput;
    orderBy?: QuestionnaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  questionnaires: <
    T = Promise<AsyncIterator<QuestionnaireSubscription>>
  >(args?: {
    where?: QuestionnaireWhereInput;
    orderBy?: QuestionnaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CustomerNullablePromise
  extends Promise<Customer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  questionnaires: <T = FragmentableArray<Questionnaire>>(args?: {
    where?: QuestionnaireWhereInput;
    orderBy?: QuestionnaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FontSettingsEdge {
  node: FontSettings;
  cursor: String;
}

export interface FontSettingsEdgePromise
  extends Promise<FontSettingsEdge>,
    Fragmentable {
  node: <T = FontSettingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FontSettingsEdgeSubscription
  extends Promise<AsyncIterator<FontSettingsEdge>>,
    Fragmentable {
  node: <T = FontSettingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Question",
    embedded: false
  },
  {
    name: "QuestionCondition",
    embedded: false
  },
  {
    name: "QuestionOption",
    embedded: false
  },
  {
    name: "Questionnaire",
    embedded: false
  },
  {
    name: "QuestionnaireSettings",
    embedded: false
  },
  {
    name: "ColourSettings",
    embedded: false
  },
  {
    name: "FontSettings",
    embedded: false
  },
  {
    name: "Customer",
    embedded: false
  },
  {
    name: "Topic",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
