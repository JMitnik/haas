// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  colourSettings: (where?: ColourSettingsWhereInput) => Promise<boolean>;
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  customerSettings: (where?: CustomerSettingsWhereInput) => Promise<boolean>;
  edge: (where?: EdgeWhereInput) => Promise<boolean>;
  fontSettings: (where?: FontSettingsWhereInput) => Promise<boolean>;
  leafNode: (where?: LeafNodeWhereInput) => Promise<boolean>;
  questionCondition: (where?: QuestionConditionWhereInput) => Promise<boolean>;
  questionNode: (where?: QuestionNodeWhereInput) => Promise<boolean>;
  questionOption: (where?: QuestionOptionWhereInput) => Promise<boolean>;
  questionnaire: (where?: QuestionnaireWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  colourSettings: (
    where: ColourSettingsWhereUniqueInput
  ) => ColourSettingsNullablePromise;
  colourSettingses: (args?: {
    where?: ColourSettingsWhereInput;
    orderBy?: ColourSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ColourSettings>;
  colourSettingsesConnection: (args?: {
    where?: ColourSettingsWhereInput;
    orderBy?: ColourSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ColourSettingsConnectionPromise;
  customer: (where: CustomerWhereUniqueInput) => CustomerNullablePromise;
  customers: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Customer>;
  customersConnection: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerConnectionPromise;
  customerSettings: (
    where: CustomerSettingsWhereUniqueInput
  ) => CustomerSettingsNullablePromise;
  customerSettingses: (args?: {
    where?: CustomerSettingsWhereInput;
    orderBy?: CustomerSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CustomerSettings>;
  customerSettingsesConnection: (args?: {
    where?: CustomerSettingsWhereInput;
    orderBy?: CustomerSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerSettingsConnectionPromise;
  edge: (where: EdgeWhereUniqueInput) => EdgeNullablePromise;
  edges: (args?: {
    where?: EdgeWhereInput;
    orderBy?: EdgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Edge>;
  edgesConnection: (args?: {
    where?: EdgeWhereInput;
    orderBy?: EdgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EdgeConnectionPromise;
  fontSettings: (
    where: FontSettingsWhereUniqueInput
  ) => FontSettingsNullablePromise;
  fontSettingses: (args?: {
    where?: FontSettingsWhereInput;
    orderBy?: FontSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FontSettings>;
  fontSettingsesConnection: (args?: {
    where?: FontSettingsWhereInput;
    orderBy?: FontSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FontSettingsConnectionPromise;
  leafNode: (where: LeafNodeWhereUniqueInput) => LeafNodeNullablePromise;
  leafNodes: (args?: {
    where?: LeafNodeWhereInput;
    orderBy?: LeafNodeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LeafNode>;
  leafNodesConnection: (args?: {
    where?: LeafNodeWhereInput;
    orderBy?: LeafNodeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LeafNodeConnectionPromise;
  questionCondition: (
    where: QuestionConditionWhereUniqueInput
  ) => QuestionConditionNullablePromise;
  questionConditions: (args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QuestionCondition>;
  questionConditionsConnection: (args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionConditionConnectionPromise;
  questionNode: (
    where: QuestionNodeWhereUniqueInput
  ) => QuestionNodeNullablePromise;
  questionNodes: (args?: {
    where?: QuestionNodeWhereInput;
    orderBy?: QuestionNodeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QuestionNode>;
  questionNodesConnection: (args?: {
    where?: QuestionNodeWhereInput;
    orderBy?: QuestionNodeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionNodeConnectionPromise;
  questionOption: (
    where: QuestionOptionWhereUniqueInput
  ) => QuestionOptionNullablePromise;
  questionOptions: (args?: {
    where?: QuestionOptionWhereInput;
    orderBy?: QuestionOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QuestionOption>;
  questionOptionsConnection: (args?: {
    where?: QuestionOptionWhereInput;
    orderBy?: QuestionOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionOptionConnectionPromise;
  questionnaire: (
    where: QuestionnaireWhereUniqueInput
  ) => QuestionnaireNullablePromise;
  questionnaires: (args?: {
    where?: QuestionnaireWhereInput;
    orderBy?: QuestionnaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Questionnaire>;
  questionnairesConnection: (args?: {
    where?: QuestionnaireWhereInput;
    orderBy?: QuestionnaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionnaireConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createColourSettings: (
    data: ColourSettingsCreateInput
  ) => ColourSettingsPromise;
  updateColourSettings: (args: {
    data: ColourSettingsUpdateInput;
    where: ColourSettingsWhereUniqueInput;
  }) => ColourSettingsPromise;
  updateManyColourSettingses: (args: {
    data: ColourSettingsUpdateManyMutationInput;
    where?: ColourSettingsWhereInput;
  }) => BatchPayloadPromise;
  upsertColourSettings: (args: {
    where: ColourSettingsWhereUniqueInput;
    create: ColourSettingsCreateInput;
    update: ColourSettingsUpdateInput;
  }) => ColourSettingsPromise;
  deleteColourSettings: (
    where: ColourSettingsWhereUniqueInput
  ) => ColourSettingsPromise;
  deleteManyColourSettingses: (
    where?: ColourSettingsWhereInput
  ) => BatchPayloadPromise;
  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (args: {
    data: CustomerUpdateInput;
    where: CustomerWhereUniqueInput;
  }) => CustomerPromise;
  updateManyCustomers: (args: {
    data: CustomerUpdateManyMutationInput;
    where?: CustomerWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomer: (args: {
    where: CustomerWhereUniqueInput;
    create: CustomerCreateInput;
    update: CustomerUpdateInput;
  }) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createCustomerSettings: (
    data: CustomerSettingsCreateInput
  ) => CustomerSettingsPromise;
  updateCustomerSettings: (args: {
    data: CustomerSettingsUpdateInput;
    where: CustomerSettingsWhereUniqueInput;
  }) => CustomerSettingsPromise;
  updateManyCustomerSettingses: (args: {
    data: CustomerSettingsUpdateManyMutationInput;
    where?: CustomerSettingsWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomerSettings: (args: {
    where: CustomerSettingsWhereUniqueInput;
    create: CustomerSettingsCreateInput;
    update: CustomerSettingsUpdateInput;
  }) => CustomerSettingsPromise;
  deleteCustomerSettings: (
    where: CustomerSettingsWhereUniqueInput
  ) => CustomerSettingsPromise;
  deleteManyCustomerSettingses: (
    where?: CustomerSettingsWhereInput
  ) => BatchPayloadPromise;
  createEdge: (data: EdgeCreateInput) => EdgePromise;
  updateEdge: (args: {
    data: EdgeUpdateInput;
    where: EdgeWhereUniqueInput;
  }) => EdgePromise;
  upsertEdge: (args: {
    where: EdgeWhereUniqueInput;
    create: EdgeCreateInput;
    update: EdgeUpdateInput;
  }) => EdgePromise;
  deleteEdge: (where: EdgeWhereUniqueInput) => EdgePromise;
  deleteManyEdges: (where?: EdgeWhereInput) => BatchPayloadPromise;
  createFontSettings: (data: FontSettingsCreateInput) => FontSettingsPromise;
  updateFontSettings: (args: {
    data: FontSettingsUpdateInput;
    where: FontSettingsWhereUniqueInput;
  }) => FontSettingsPromise;
  updateManyFontSettingses: (args: {
    data: FontSettingsUpdateManyMutationInput;
    where?: FontSettingsWhereInput;
  }) => BatchPayloadPromise;
  upsertFontSettings: (args: {
    where: FontSettingsWhereUniqueInput;
    create: FontSettingsCreateInput;
    update: FontSettingsUpdateInput;
  }) => FontSettingsPromise;
  deleteFontSettings: (
    where: FontSettingsWhereUniqueInput
  ) => FontSettingsPromise;
  deleteManyFontSettingses: (
    where?: FontSettingsWhereInput
  ) => BatchPayloadPromise;
  createLeafNode: (data: LeafNodeCreateInput) => LeafNodePromise;
  updateLeafNode: (args: {
    data: LeafNodeUpdateInput;
    where: LeafNodeWhereUniqueInput;
  }) => LeafNodePromise;
  updateManyLeafNodes: (args: {
    data: LeafNodeUpdateManyMutationInput;
    where?: LeafNodeWhereInput;
  }) => BatchPayloadPromise;
  upsertLeafNode: (args: {
    where: LeafNodeWhereUniqueInput;
    create: LeafNodeCreateInput;
    update: LeafNodeUpdateInput;
  }) => LeafNodePromise;
  deleteLeafNode: (where: LeafNodeWhereUniqueInput) => LeafNodePromise;
  deleteManyLeafNodes: (where?: LeafNodeWhereInput) => BatchPayloadPromise;
  createQuestionCondition: (
    data: QuestionConditionCreateInput
  ) => QuestionConditionPromise;
  updateQuestionCondition: (args: {
    data: QuestionConditionUpdateInput;
    where: QuestionConditionWhereUniqueInput;
  }) => QuestionConditionPromise;
  updateManyQuestionConditions: (args: {
    data: QuestionConditionUpdateManyMutationInput;
    where?: QuestionConditionWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestionCondition: (args: {
    where: QuestionConditionWhereUniqueInput;
    create: QuestionConditionCreateInput;
    update: QuestionConditionUpdateInput;
  }) => QuestionConditionPromise;
  deleteQuestionCondition: (
    where: QuestionConditionWhereUniqueInput
  ) => QuestionConditionPromise;
  deleteManyQuestionConditions: (
    where?: QuestionConditionWhereInput
  ) => BatchPayloadPromise;
  createQuestionNode: (data: QuestionNodeCreateInput) => QuestionNodePromise;
  updateQuestionNode: (args: {
    data: QuestionNodeUpdateInput;
    where: QuestionNodeWhereUniqueInput;
  }) => QuestionNodePromise;
  updateManyQuestionNodes: (args: {
    data: QuestionNodeUpdateManyMutationInput;
    where?: QuestionNodeWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestionNode: (args: {
    where: QuestionNodeWhereUniqueInput;
    create: QuestionNodeCreateInput;
    update: QuestionNodeUpdateInput;
  }) => QuestionNodePromise;
  deleteQuestionNode: (
    where: QuestionNodeWhereUniqueInput
  ) => QuestionNodePromise;
  deleteManyQuestionNodes: (
    where?: QuestionNodeWhereInput
  ) => BatchPayloadPromise;
  createQuestionOption: (
    data: QuestionOptionCreateInput
  ) => QuestionOptionPromise;
  updateQuestionOption: (args: {
    data: QuestionOptionUpdateInput;
    where: QuestionOptionWhereUniqueInput;
  }) => QuestionOptionPromise;
  updateManyQuestionOptions: (args: {
    data: QuestionOptionUpdateManyMutationInput;
    where?: QuestionOptionWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestionOption: (args: {
    where: QuestionOptionWhereUniqueInput;
    create: QuestionOptionCreateInput;
    update: QuestionOptionUpdateInput;
  }) => QuestionOptionPromise;
  deleteQuestionOption: (
    where: QuestionOptionWhereUniqueInput
  ) => QuestionOptionPromise;
  deleteManyQuestionOptions: (
    where?: QuestionOptionWhereInput
  ) => BatchPayloadPromise;
  createQuestionnaire: (data: QuestionnaireCreateInput) => QuestionnairePromise;
  updateQuestionnaire: (args: {
    data: QuestionnaireUpdateInput;
    where: QuestionnaireWhereUniqueInput;
  }) => QuestionnairePromise;
  updateManyQuestionnaires: (args: {
    data: QuestionnaireUpdateManyMutationInput;
    where?: QuestionnaireWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestionnaire: (args: {
    where: QuestionnaireWhereUniqueInput;
    create: QuestionnaireCreateInput;
    update: QuestionnaireUpdateInput;
  }) => QuestionnairePromise;
  deleteQuestionnaire: (
    where: QuestionnaireWhereUniqueInput
  ) => QuestionnairePromise;
  deleteManyQuestionnaires: (
    where?: QuestionnaireWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  colourSettings: (
    where?: ColourSettingsSubscriptionWhereInput
  ) => ColourSettingsSubscriptionPayloadSubscription;
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  customerSettings: (
    where?: CustomerSettingsSubscriptionWhereInput
  ) => CustomerSettingsSubscriptionPayloadSubscription;
  edge: (
    where?: EdgeSubscriptionWhereInput
  ) => EdgeSubscriptionPayloadSubscription;
  fontSettings: (
    where?: FontSettingsSubscriptionWhereInput
  ) => FontSettingsSubscriptionPayloadSubscription;
  leafNode: (
    where?: LeafNodeSubscriptionWhereInput
  ) => LeafNodeSubscriptionPayloadSubscription;
  questionCondition: (
    where?: QuestionConditionSubscriptionWhereInput
  ) => QuestionConditionSubscriptionPayloadSubscription;
  questionNode: (
    where?: QuestionNodeSubscriptionWhereInput
  ) => QuestionNodeSubscriptionPayloadSubscription;
  questionOption: (
    where?: QuestionOptionSubscriptionWhereInput
  ) => QuestionOptionSubscriptionPayloadSubscription;
  questionnaire: (
    where?: QuestionnaireSubscriptionWhereInput
  ) => QuestionnaireSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ColourSettingsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "primary_ASC"
  | "primary_DESC"
  | "secondary_ASC"
  | "secondary_DESC"
  | "tertiary_ASC"
  | "tertiary_DESC"
  | "success_ASC"
  | "success_DESC"
  | "warning_ASC"
  | "warning_DESC"
  | "error_ASC"
  | "error_DESC"
  | "lightest_ASC"
  | "lightest_DESC"
  | "light_ASC"
  | "light_DESC"
  | "normal_ASC"
  | "normal_DESC"
  | "dark_ASC"
  | "dark_DESC"
  | "darkest_ASC"
  | "darkest_DESC"
  | "muted_ASC"
  | "muted_DESC"
  | "text_ASC"
  | "text_DESC";

export type NodeType =
  | "SLIDER"
  | "MULTI_CHOICE"
  | "TEXTBOX"
  | "SOCIAL_SHARE"
  | "REGISTRATION";

export type QuestionnaireOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "publicTitle_ASC"
  | "publicTitle_DESC"
  | "creationDate_ASC"
  | "creationDate_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type QuestionNodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "branchVal_ASC"
  | "branchVal_DESC"
  | "isRoot_ASC"
  | "isRoot_DESC"
  | "questionType_ASC"
  | "questionType_DESC";

export type QuestionConditionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "conditionType_ASC"
  | "conditionType_DESC"
  | "renderMin_ASC"
  | "renderMin_DESC"
  | "renderMax_ASC"
  | "renderMax_DESC"
  | "matchValue_ASC"
  | "matchValue_DESC";

export type QuestionOptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC"
  | "publicValue_ASC"
  | "publicValue_DESC";

export type EdgeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LeafNodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "nodeId_ASC"
  | "nodeId_DESC"
  | "type_ASC"
  | "type_DESC"
  | "title_ASC"
  | "title_DESC";

export type CustomerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type CustomerSettingsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "logoUrl_ASC"
  | "logoUrl_DESC";

export type FontSettingsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "settingTitle_ASC"
  | "settingTitle_DESC"
  | "body_ASC"
  | "body_DESC"
  | "fontTitle_ASC"
  | "fontTitle_DESC"
  | "special_ASC"
  | "special_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ColourSettingsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ColourSettingsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  primary?: Maybe<String>;
  primary_not?: Maybe<String>;
  primary_in?: Maybe<String[] | String>;
  primary_not_in?: Maybe<String[] | String>;
  primary_lt?: Maybe<String>;
  primary_lte?: Maybe<String>;
  primary_gt?: Maybe<String>;
  primary_gte?: Maybe<String>;
  primary_contains?: Maybe<String>;
  primary_not_contains?: Maybe<String>;
  primary_starts_with?: Maybe<String>;
  primary_not_starts_with?: Maybe<String>;
  primary_ends_with?: Maybe<String>;
  primary_not_ends_with?: Maybe<String>;
  secondary?: Maybe<String>;
  secondary_not?: Maybe<String>;
  secondary_in?: Maybe<String[] | String>;
  secondary_not_in?: Maybe<String[] | String>;
  secondary_lt?: Maybe<String>;
  secondary_lte?: Maybe<String>;
  secondary_gt?: Maybe<String>;
  secondary_gte?: Maybe<String>;
  secondary_contains?: Maybe<String>;
  secondary_not_contains?: Maybe<String>;
  secondary_starts_with?: Maybe<String>;
  secondary_not_starts_with?: Maybe<String>;
  secondary_ends_with?: Maybe<String>;
  secondary_not_ends_with?: Maybe<String>;
  tertiary?: Maybe<String>;
  tertiary_not?: Maybe<String>;
  tertiary_in?: Maybe<String[] | String>;
  tertiary_not_in?: Maybe<String[] | String>;
  tertiary_lt?: Maybe<String>;
  tertiary_lte?: Maybe<String>;
  tertiary_gt?: Maybe<String>;
  tertiary_gte?: Maybe<String>;
  tertiary_contains?: Maybe<String>;
  tertiary_not_contains?: Maybe<String>;
  tertiary_starts_with?: Maybe<String>;
  tertiary_not_starts_with?: Maybe<String>;
  tertiary_ends_with?: Maybe<String>;
  tertiary_not_ends_with?: Maybe<String>;
  success?: Maybe<String>;
  success_not?: Maybe<String>;
  success_in?: Maybe<String[] | String>;
  success_not_in?: Maybe<String[] | String>;
  success_lt?: Maybe<String>;
  success_lte?: Maybe<String>;
  success_gt?: Maybe<String>;
  success_gte?: Maybe<String>;
  success_contains?: Maybe<String>;
  success_not_contains?: Maybe<String>;
  success_starts_with?: Maybe<String>;
  success_not_starts_with?: Maybe<String>;
  success_ends_with?: Maybe<String>;
  success_not_ends_with?: Maybe<String>;
  warning?: Maybe<String>;
  warning_not?: Maybe<String>;
  warning_in?: Maybe<String[] | String>;
  warning_not_in?: Maybe<String[] | String>;
  warning_lt?: Maybe<String>;
  warning_lte?: Maybe<String>;
  warning_gt?: Maybe<String>;
  warning_gte?: Maybe<String>;
  warning_contains?: Maybe<String>;
  warning_not_contains?: Maybe<String>;
  warning_starts_with?: Maybe<String>;
  warning_not_starts_with?: Maybe<String>;
  warning_ends_with?: Maybe<String>;
  warning_not_ends_with?: Maybe<String>;
  error?: Maybe<String>;
  error_not?: Maybe<String>;
  error_in?: Maybe<String[] | String>;
  error_not_in?: Maybe<String[] | String>;
  error_lt?: Maybe<String>;
  error_lte?: Maybe<String>;
  error_gt?: Maybe<String>;
  error_gte?: Maybe<String>;
  error_contains?: Maybe<String>;
  error_not_contains?: Maybe<String>;
  error_starts_with?: Maybe<String>;
  error_not_starts_with?: Maybe<String>;
  error_ends_with?: Maybe<String>;
  error_not_ends_with?: Maybe<String>;
  lightest?: Maybe<String>;
  lightest_not?: Maybe<String>;
  lightest_in?: Maybe<String[] | String>;
  lightest_not_in?: Maybe<String[] | String>;
  lightest_lt?: Maybe<String>;
  lightest_lte?: Maybe<String>;
  lightest_gt?: Maybe<String>;
  lightest_gte?: Maybe<String>;
  lightest_contains?: Maybe<String>;
  lightest_not_contains?: Maybe<String>;
  lightest_starts_with?: Maybe<String>;
  lightest_not_starts_with?: Maybe<String>;
  lightest_ends_with?: Maybe<String>;
  lightest_not_ends_with?: Maybe<String>;
  light?: Maybe<String>;
  light_not?: Maybe<String>;
  light_in?: Maybe<String[] | String>;
  light_not_in?: Maybe<String[] | String>;
  light_lt?: Maybe<String>;
  light_lte?: Maybe<String>;
  light_gt?: Maybe<String>;
  light_gte?: Maybe<String>;
  light_contains?: Maybe<String>;
  light_not_contains?: Maybe<String>;
  light_starts_with?: Maybe<String>;
  light_not_starts_with?: Maybe<String>;
  light_ends_with?: Maybe<String>;
  light_not_ends_with?: Maybe<String>;
  normal?: Maybe<String>;
  normal_not?: Maybe<String>;
  normal_in?: Maybe<String[] | String>;
  normal_not_in?: Maybe<String[] | String>;
  normal_lt?: Maybe<String>;
  normal_lte?: Maybe<String>;
  normal_gt?: Maybe<String>;
  normal_gte?: Maybe<String>;
  normal_contains?: Maybe<String>;
  normal_not_contains?: Maybe<String>;
  normal_starts_with?: Maybe<String>;
  normal_not_starts_with?: Maybe<String>;
  normal_ends_with?: Maybe<String>;
  normal_not_ends_with?: Maybe<String>;
  dark?: Maybe<String>;
  dark_not?: Maybe<String>;
  dark_in?: Maybe<String[] | String>;
  dark_not_in?: Maybe<String[] | String>;
  dark_lt?: Maybe<String>;
  dark_lte?: Maybe<String>;
  dark_gt?: Maybe<String>;
  dark_gte?: Maybe<String>;
  dark_contains?: Maybe<String>;
  dark_not_contains?: Maybe<String>;
  dark_starts_with?: Maybe<String>;
  dark_not_starts_with?: Maybe<String>;
  dark_ends_with?: Maybe<String>;
  dark_not_ends_with?: Maybe<String>;
  darkest?: Maybe<String>;
  darkest_not?: Maybe<String>;
  darkest_in?: Maybe<String[] | String>;
  darkest_not_in?: Maybe<String[] | String>;
  darkest_lt?: Maybe<String>;
  darkest_lte?: Maybe<String>;
  darkest_gt?: Maybe<String>;
  darkest_gte?: Maybe<String>;
  darkest_contains?: Maybe<String>;
  darkest_not_contains?: Maybe<String>;
  darkest_starts_with?: Maybe<String>;
  darkest_not_starts_with?: Maybe<String>;
  darkest_ends_with?: Maybe<String>;
  darkest_not_ends_with?: Maybe<String>;
  muted?: Maybe<String>;
  muted_not?: Maybe<String>;
  muted_in?: Maybe<String[] | String>;
  muted_not_in?: Maybe<String[] | String>;
  muted_lt?: Maybe<String>;
  muted_lte?: Maybe<String>;
  muted_gt?: Maybe<String>;
  muted_gte?: Maybe<String>;
  muted_contains?: Maybe<String>;
  muted_not_contains?: Maybe<String>;
  muted_starts_with?: Maybe<String>;
  muted_not_starts_with?: Maybe<String>;
  muted_ends_with?: Maybe<String>;
  muted_not_ends_with?: Maybe<String>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  AND?: Maybe<ColourSettingsWhereInput[] | ColourSettingsWhereInput>;
  OR?: Maybe<ColourSettingsWhereInput[] | ColourSettingsWhereInput>;
  NOT?: Maybe<ColourSettingsWhereInput[] | ColourSettingsWhereInput>;
}

export type CustomerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QuestionnaireWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  customer?: Maybe<CustomerWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  publicTitle?: Maybe<String>;
  publicTitle_not?: Maybe<String>;
  publicTitle_in?: Maybe<String[] | String>;
  publicTitle_not_in?: Maybe<String[] | String>;
  publicTitle_lt?: Maybe<String>;
  publicTitle_lte?: Maybe<String>;
  publicTitle_gt?: Maybe<String>;
  publicTitle_gte?: Maybe<String>;
  publicTitle_contains?: Maybe<String>;
  publicTitle_not_contains?: Maybe<String>;
  publicTitle_starts_with?: Maybe<String>;
  publicTitle_not_starts_with?: Maybe<String>;
  publicTitle_ends_with?: Maybe<String>;
  publicTitle_not_ends_with?: Maybe<String>;
  creationDate?: Maybe<DateTimeInput>;
  creationDate_not?: Maybe<DateTimeInput>;
  creationDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  creationDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  creationDate_lt?: Maybe<DateTimeInput>;
  creationDate_lte?: Maybe<DateTimeInput>;
  creationDate_gt?: Maybe<DateTimeInput>;
  creationDate_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  questions_every?: Maybe<QuestionNodeWhereInput>;
  questions_some?: Maybe<QuestionNodeWhereInput>;
  questions_none?: Maybe<QuestionNodeWhereInput>;
  leafs_every?: Maybe<LeafNodeWhereInput>;
  leafs_some?: Maybe<LeafNodeWhereInput>;
  leafs_none?: Maybe<LeafNodeWhereInput>;
  AND?: Maybe<QuestionnaireWhereInput[] | QuestionnaireWhereInput>;
  OR?: Maybe<QuestionnaireWhereInput[] | QuestionnaireWhereInput>;
  NOT?: Maybe<QuestionnaireWhereInput[] | QuestionnaireWhereInput>;
}

export interface CustomerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  questionnaires_every?: Maybe<QuestionnaireWhereInput>;
  questionnaires_some?: Maybe<QuestionnaireWhereInput>;
  questionnaires_none?: Maybe<QuestionnaireWhereInput>;
  settings?: Maybe<CustomerSettingsWhereInput>;
  AND?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  OR?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  NOT?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
}

export interface CustomerSettingsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  logoUrl?: Maybe<String>;
  logoUrl_not?: Maybe<String>;
  logoUrl_in?: Maybe<String[] | String>;
  logoUrl_not_in?: Maybe<String[] | String>;
  logoUrl_lt?: Maybe<String>;
  logoUrl_lte?: Maybe<String>;
  logoUrl_gt?: Maybe<String>;
  logoUrl_gte?: Maybe<String>;
  logoUrl_contains?: Maybe<String>;
  logoUrl_not_contains?: Maybe<String>;
  logoUrl_starts_with?: Maybe<String>;
  logoUrl_not_starts_with?: Maybe<String>;
  logoUrl_ends_with?: Maybe<String>;
  logoUrl_not_ends_with?: Maybe<String>;
  colourSettings?: Maybe<ColourSettingsWhereInput>;
  fontSettings?: Maybe<FontSettingsWhereInput>;
  AND?: Maybe<CustomerSettingsWhereInput[] | CustomerSettingsWhereInput>;
  OR?: Maybe<CustomerSettingsWhereInput[] | CustomerSettingsWhereInput>;
  NOT?: Maybe<CustomerSettingsWhereInput[] | CustomerSettingsWhereInput>;
}

export interface FontSettingsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  settingTitle?: Maybe<String>;
  settingTitle_not?: Maybe<String>;
  settingTitle_in?: Maybe<String[] | String>;
  settingTitle_not_in?: Maybe<String[] | String>;
  settingTitle_lt?: Maybe<String>;
  settingTitle_lte?: Maybe<String>;
  settingTitle_gt?: Maybe<String>;
  settingTitle_gte?: Maybe<String>;
  settingTitle_contains?: Maybe<String>;
  settingTitle_not_contains?: Maybe<String>;
  settingTitle_starts_with?: Maybe<String>;
  settingTitle_not_starts_with?: Maybe<String>;
  settingTitle_ends_with?: Maybe<String>;
  settingTitle_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  fontTitle?: Maybe<String>;
  fontTitle_not?: Maybe<String>;
  fontTitle_in?: Maybe<String[] | String>;
  fontTitle_not_in?: Maybe<String[] | String>;
  fontTitle_lt?: Maybe<String>;
  fontTitle_lte?: Maybe<String>;
  fontTitle_gt?: Maybe<String>;
  fontTitle_gte?: Maybe<String>;
  fontTitle_contains?: Maybe<String>;
  fontTitle_not_contains?: Maybe<String>;
  fontTitle_starts_with?: Maybe<String>;
  fontTitle_not_starts_with?: Maybe<String>;
  fontTitle_ends_with?: Maybe<String>;
  fontTitle_not_ends_with?: Maybe<String>;
  special?: Maybe<String>;
  special_not?: Maybe<String>;
  special_in?: Maybe<String[] | String>;
  special_not_in?: Maybe<String[] | String>;
  special_lt?: Maybe<String>;
  special_lte?: Maybe<String>;
  special_gt?: Maybe<String>;
  special_gte?: Maybe<String>;
  special_contains?: Maybe<String>;
  special_not_contains?: Maybe<String>;
  special_starts_with?: Maybe<String>;
  special_not_starts_with?: Maybe<String>;
  special_ends_with?: Maybe<String>;
  special_not_ends_with?: Maybe<String>;
  AND?: Maybe<FontSettingsWhereInput[] | FontSettingsWhereInput>;
  OR?: Maybe<FontSettingsWhereInput[] | FontSettingsWhereInput>;
  NOT?: Maybe<FontSettingsWhereInput[] | FontSettingsWhereInput>;
}

export interface QuestionNodeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  branchVal?: Maybe<String>;
  branchVal_not?: Maybe<String>;
  branchVal_in?: Maybe<String[] | String>;
  branchVal_not_in?: Maybe<String[] | String>;
  branchVal_lt?: Maybe<String>;
  branchVal_lte?: Maybe<String>;
  branchVal_gt?: Maybe<String>;
  branchVal_gte?: Maybe<String>;
  branchVal_contains?: Maybe<String>;
  branchVal_not_contains?: Maybe<String>;
  branchVal_starts_with?: Maybe<String>;
  branchVal_not_starts_with?: Maybe<String>;
  branchVal_ends_with?: Maybe<String>;
  branchVal_not_ends_with?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  isRoot_not?: Maybe<Boolean>;
  questionType?: Maybe<NodeType>;
  questionType_not?: Maybe<NodeType>;
  questionType_in?: Maybe<NodeType[] | NodeType>;
  questionType_not_in?: Maybe<NodeType[] | NodeType>;
  overrideLeaf?: Maybe<LeafNodeWhereInput>;
  conditions_every?: Maybe<QuestionConditionWhereInput>;
  conditions_some?: Maybe<QuestionConditionWhereInput>;
  conditions_none?: Maybe<QuestionConditionWhereInput>;
  options_every?: Maybe<QuestionOptionWhereInput>;
  options_some?: Maybe<QuestionOptionWhereInput>;
  options_none?: Maybe<QuestionOptionWhereInput>;
  children_every?: Maybe<QuestionNodeWhereInput>;
  children_some?: Maybe<QuestionNodeWhereInput>;
  children_none?: Maybe<QuestionNodeWhereInput>;
  edgeChildren_every?: Maybe<EdgeWhereInput>;
  edgeChildren_some?: Maybe<EdgeWhereInput>;
  edgeChildren_none?: Maybe<EdgeWhereInput>;
  AND?: Maybe<QuestionNodeWhereInput[] | QuestionNodeWhereInput>;
  OR?: Maybe<QuestionNodeWhereInput[] | QuestionNodeWhereInput>;
  NOT?: Maybe<QuestionNodeWhereInput[] | QuestionNodeWhereInput>;
}

export interface LeafNodeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  nodeId?: Maybe<Int>;
  nodeId_not?: Maybe<Int>;
  nodeId_in?: Maybe<Int[] | Int>;
  nodeId_not_in?: Maybe<Int[] | Int>;
  nodeId_lt?: Maybe<Int>;
  nodeId_lte?: Maybe<Int>;
  nodeId_gt?: Maybe<Int>;
  nodeId_gte?: Maybe<Int>;
  type?: Maybe<NodeType>;
  type_not?: Maybe<NodeType>;
  type_in?: Maybe<NodeType[] | NodeType>;
  type_not_in?: Maybe<NodeType[] | NodeType>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<LeafNodeWhereInput[] | LeafNodeWhereInput>;
  OR?: Maybe<LeafNodeWhereInput[] | LeafNodeWhereInput>;
  NOT?: Maybe<LeafNodeWhereInput[] | LeafNodeWhereInput>;
}

export interface QuestionConditionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  conditionType?: Maybe<String>;
  conditionType_not?: Maybe<String>;
  conditionType_in?: Maybe<String[] | String>;
  conditionType_not_in?: Maybe<String[] | String>;
  conditionType_lt?: Maybe<String>;
  conditionType_lte?: Maybe<String>;
  conditionType_gt?: Maybe<String>;
  conditionType_gte?: Maybe<String>;
  conditionType_contains?: Maybe<String>;
  conditionType_not_contains?: Maybe<String>;
  conditionType_starts_with?: Maybe<String>;
  conditionType_not_starts_with?: Maybe<String>;
  conditionType_ends_with?: Maybe<String>;
  conditionType_not_ends_with?: Maybe<String>;
  renderMin?: Maybe<Int>;
  renderMin_not?: Maybe<Int>;
  renderMin_in?: Maybe<Int[] | Int>;
  renderMin_not_in?: Maybe<Int[] | Int>;
  renderMin_lt?: Maybe<Int>;
  renderMin_lte?: Maybe<Int>;
  renderMin_gt?: Maybe<Int>;
  renderMin_gte?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  renderMax_not?: Maybe<Int>;
  renderMax_in?: Maybe<Int[] | Int>;
  renderMax_not_in?: Maybe<Int[] | Int>;
  renderMax_lt?: Maybe<Int>;
  renderMax_lte?: Maybe<Int>;
  renderMax_gt?: Maybe<Int>;
  renderMax_gte?: Maybe<Int>;
  matchValue?: Maybe<String>;
  matchValue_not?: Maybe<String>;
  matchValue_in?: Maybe<String[] | String>;
  matchValue_not_in?: Maybe<String[] | String>;
  matchValue_lt?: Maybe<String>;
  matchValue_lte?: Maybe<String>;
  matchValue_gt?: Maybe<String>;
  matchValue_gte?: Maybe<String>;
  matchValue_contains?: Maybe<String>;
  matchValue_not_contains?: Maybe<String>;
  matchValue_starts_with?: Maybe<String>;
  matchValue_not_starts_with?: Maybe<String>;
  matchValue_ends_with?: Maybe<String>;
  matchValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<QuestionConditionWhereInput[] | QuestionConditionWhereInput>;
  OR?: Maybe<QuestionConditionWhereInput[] | QuestionConditionWhereInput>;
  NOT?: Maybe<QuestionConditionWhereInput[] | QuestionConditionWhereInput>;
}

export interface QuestionOptionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  publicValue?: Maybe<String>;
  publicValue_not?: Maybe<String>;
  publicValue_in?: Maybe<String[] | String>;
  publicValue_not_in?: Maybe<String[] | String>;
  publicValue_lt?: Maybe<String>;
  publicValue_lte?: Maybe<String>;
  publicValue_gt?: Maybe<String>;
  publicValue_gte?: Maybe<String>;
  publicValue_contains?: Maybe<String>;
  publicValue_not_contains?: Maybe<String>;
  publicValue_starts_with?: Maybe<String>;
  publicValue_not_starts_with?: Maybe<String>;
  publicValue_ends_with?: Maybe<String>;
  publicValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<QuestionOptionWhereInput[] | QuestionOptionWhereInput>;
  OR?: Maybe<QuestionOptionWhereInput[] | QuestionOptionWhereInput>;
  NOT?: Maybe<QuestionOptionWhereInput[] | QuestionOptionWhereInput>;
}

export interface EdgeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  conditions_every?: Maybe<QuestionConditionWhereInput>;
  conditions_some?: Maybe<QuestionConditionWhereInput>;
  conditions_none?: Maybe<QuestionConditionWhereInput>;
  parentNode?: Maybe<QuestionNodeWhereInput>;
  childNode?: Maybe<QuestionNodeWhereInput>;
  AND?: Maybe<EdgeWhereInput[] | EdgeWhereInput>;
  OR?: Maybe<EdgeWhereInput[] | EdgeWhereInput>;
  NOT?: Maybe<EdgeWhereInput[] | EdgeWhereInput>;
}

export type CustomerSettingsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type EdgeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type FontSettingsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type LeafNodeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  nodeId?: Maybe<Int>;
}>;

export type QuestionConditionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type QuestionNodeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type QuestionOptionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type QuestionnaireWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ColourSettingsCreateInput {
  id?: Maybe<ID_Input>;
  primary: String;
  secondary?: Maybe<String>;
  tertiary?: Maybe<String>;
  success?: Maybe<String>;
  warning?: Maybe<String>;
  error?: Maybe<String>;
  lightest?: Maybe<String>;
  light?: Maybe<String>;
  normal?: Maybe<String>;
  dark?: Maybe<String>;
  darkest?: Maybe<String>;
  muted?: Maybe<String>;
  text?: Maybe<String>;
}

export interface ColourSettingsUpdateInput {
  primary?: Maybe<String>;
  secondary?: Maybe<String>;
  tertiary?: Maybe<String>;
  success?: Maybe<String>;
  warning?: Maybe<String>;
  error?: Maybe<String>;
  lightest?: Maybe<String>;
  light?: Maybe<String>;
  normal?: Maybe<String>;
  dark?: Maybe<String>;
  darkest?: Maybe<String>;
  muted?: Maybe<String>;
  text?: Maybe<String>;
}

export interface ColourSettingsUpdateManyMutationInput {
  primary?: Maybe<String>;
  secondary?: Maybe<String>;
  tertiary?: Maybe<String>;
  success?: Maybe<String>;
  warning?: Maybe<String>;
  error?: Maybe<String>;
  lightest?: Maybe<String>;
  light?: Maybe<String>;
  normal?: Maybe<String>;
  dark?: Maybe<String>;
  darkest?: Maybe<String>;
  muted?: Maybe<String>;
  text?: Maybe<String>;
}

export interface CustomerCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  questionnaires?: Maybe<QuestionnaireCreateManyWithoutCustomerInput>;
  settings?: Maybe<CustomerSettingsCreateOneInput>;
}

export interface QuestionnaireCreateManyWithoutCustomerInput {
  create?: Maybe<
    | QuestionnaireCreateWithoutCustomerInput[]
    | QuestionnaireCreateWithoutCustomerInput
  >;
  connect?: Maybe<
    QuestionnaireWhereUniqueInput[] | QuestionnaireWhereUniqueInput
  >;
}

export interface QuestionnaireCreateWithoutCustomerInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  publicTitle?: Maybe<String>;
  questions?: Maybe<QuestionNodeCreateManyInput>;
  leafs?: Maybe<LeafNodeCreateManyInput>;
}

export interface QuestionNodeCreateManyInput {
  create?: Maybe<QuestionNodeCreateInput[] | QuestionNodeCreateInput>;
  connect?: Maybe<
    QuestionNodeWhereUniqueInput[] | QuestionNodeWhereUniqueInput
  >;
}

export interface QuestionNodeCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  branchVal?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  questionType: NodeType;
  overrideLeaf?: Maybe<LeafNodeCreateOneInput>;
  conditions?: Maybe<QuestionConditionCreateManyInput>;
  options?: Maybe<QuestionOptionCreateManyInput>;
  children?: Maybe<QuestionNodeCreateManyInput>;
  edgeChildren?: Maybe<EdgeCreateManyInput>;
}

export interface LeafNodeCreateOneInput {
  create?: Maybe<LeafNodeCreateInput>;
  connect?: Maybe<LeafNodeWhereUniqueInput>;
}

export interface LeafNodeCreateInput {
  id?: Maybe<ID_Input>;
  nodeId?: Maybe<Int>;
  type?: Maybe<NodeType>;
  title: String;
}

export interface QuestionConditionCreateManyInput {
  create?: Maybe<QuestionConditionCreateInput[] | QuestionConditionCreateInput>;
  connect?: Maybe<
    QuestionConditionWhereUniqueInput[] | QuestionConditionWhereUniqueInput
  >;
}

export interface QuestionConditionCreateInput {
  id?: Maybe<ID_Input>;
  conditionType: String;
  renderMin?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  matchValue?: Maybe<String>;
}

export interface QuestionOptionCreateManyInput {
  create?: Maybe<QuestionOptionCreateInput[] | QuestionOptionCreateInput>;
  connect?: Maybe<
    QuestionOptionWhereUniqueInput[] | QuestionOptionWhereUniqueInput
  >;
}

export interface QuestionOptionCreateInput {
  id?: Maybe<ID_Input>;
  value: String;
  publicValue?: Maybe<String>;
}

export interface EdgeCreateManyInput {
  create?: Maybe<EdgeCreateInput[] | EdgeCreateInput>;
  connect?: Maybe<EdgeWhereUniqueInput[] | EdgeWhereUniqueInput>;
}

export interface EdgeCreateInput {
  id?: Maybe<ID_Input>;
  conditions?: Maybe<QuestionConditionCreateManyInput>;
  parentNode?: Maybe<QuestionNodeCreateOneInput>;
  childNode?: Maybe<QuestionNodeCreateOneInput>;
}

export interface QuestionNodeCreateOneInput {
  create?: Maybe<QuestionNodeCreateInput>;
  connect?: Maybe<QuestionNodeWhereUniqueInput>;
}

export interface LeafNodeCreateManyInput {
  create?: Maybe<LeafNodeCreateInput[] | LeafNodeCreateInput>;
  connect?: Maybe<LeafNodeWhereUniqueInput[] | LeafNodeWhereUniqueInput>;
}

export interface CustomerSettingsCreateOneInput {
  create?: Maybe<CustomerSettingsCreateInput>;
  connect?: Maybe<CustomerSettingsWhereUniqueInput>;
}

export interface CustomerSettingsCreateInput {
  id?: Maybe<ID_Input>;
  logoUrl?: Maybe<String>;
  colourSettings?: Maybe<ColourSettingsCreateOneInput>;
  fontSettings?: Maybe<FontSettingsCreateOneInput>;
}

export interface ColourSettingsCreateOneInput {
  create?: Maybe<ColourSettingsCreateInput>;
  connect?: Maybe<ColourSettingsWhereUniqueInput>;
}

export interface FontSettingsCreateOneInput {
  create?: Maybe<FontSettingsCreateInput>;
  connect?: Maybe<FontSettingsWhereUniqueInput>;
}

export interface FontSettingsCreateInput {
  id?: Maybe<ID_Input>;
  settingTitle?: Maybe<String>;
  body?: Maybe<String>;
  fontTitle?: Maybe<String>;
  special?: Maybe<String>;
}

export interface CustomerUpdateInput {
  name?: Maybe<String>;
  questionnaires?: Maybe<QuestionnaireUpdateManyWithoutCustomerInput>;
  settings?: Maybe<CustomerSettingsUpdateOneInput>;
}

export interface QuestionnaireUpdateManyWithoutCustomerInput {
  create?: Maybe<
    | QuestionnaireCreateWithoutCustomerInput[]
    | QuestionnaireCreateWithoutCustomerInput
  >;
  delete?: Maybe<
    QuestionnaireWhereUniqueInput[] | QuestionnaireWhereUniqueInput
  >;
  connect?: Maybe<
    QuestionnaireWhereUniqueInput[] | QuestionnaireWhereUniqueInput
  >;
  set?: Maybe<QuestionnaireWhereUniqueInput[] | QuestionnaireWhereUniqueInput>;
  disconnect?: Maybe<
    QuestionnaireWhereUniqueInput[] | QuestionnaireWhereUniqueInput
  >;
  update?: Maybe<
    | QuestionnaireUpdateWithWhereUniqueWithoutCustomerInput[]
    | QuestionnaireUpdateWithWhereUniqueWithoutCustomerInput
  >;
  upsert?: Maybe<
    | QuestionnaireUpsertWithWhereUniqueWithoutCustomerInput[]
    | QuestionnaireUpsertWithWhereUniqueWithoutCustomerInput
  >;
  deleteMany?: Maybe<
    QuestionnaireScalarWhereInput[] | QuestionnaireScalarWhereInput
  >;
  updateMany?: Maybe<
    | QuestionnaireUpdateManyWithWhereNestedInput[]
    | QuestionnaireUpdateManyWithWhereNestedInput
  >;
}

export interface QuestionnaireUpdateWithWhereUniqueWithoutCustomerInput {
  where: QuestionnaireWhereUniqueInput;
  data: QuestionnaireUpdateWithoutCustomerDataInput;
}

export interface QuestionnaireUpdateWithoutCustomerDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  publicTitle?: Maybe<String>;
  questions?: Maybe<QuestionNodeUpdateManyInput>;
  leafs?: Maybe<LeafNodeUpdateManyInput>;
}

export interface QuestionNodeUpdateManyInput {
  create?: Maybe<QuestionNodeCreateInput[] | QuestionNodeCreateInput>;
  update?: Maybe<
    | QuestionNodeUpdateWithWhereUniqueNestedInput[]
    | QuestionNodeUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QuestionNodeUpsertWithWhereUniqueNestedInput[]
    | QuestionNodeUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<QuestionNodeWhereUniqueInput[] | QuestionNodeWhereUniqueInput>;
  connect?: Maybe<
    QuestionNodeWhereUniqueInput[] | QuestionNodeWhereUniqueInput
  >;
  set?: Maybe<QuestionNodeWhereUniqueInput[] | QuestionNodeWhereUniqueInput>;
  disconnect?: Maybe<
    QuestionNodeWhereUniqueInput[] | QuestionNodeWhereUniqueInput
  >;
  deleteMany?: Maybe<
    QuestionNodeScalarWhereInput[] | QuestionNodeScalarWhereInput
  >;
  updateMany?: Maybe<
    | QuestionNodeUpdateManyWithWhereNestedInput[]
    | QuestionNodeUpdateManyWithWhereNestedInput
  >;
}

export interface QuestionNodeUpdateWithWhereUniqueNestedInput {
  where: QuestionNodeWhereUniqueInput;
  data: QuestionNodeUpdateDataInput;
}

export interface QuestionNodeUpdateDataInput {
  title?: Maybe<String>;
  branchVal?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  questionType?: Maybe<NodeType>;
  overrideLeaf?: Maybe<LeafNodeUpdateOneInput>;
  conditions?: Maybe<QuestionConditionUpdateManyInput>;
  options?: Maybe<QuestionOptionUpdateManyInput>;
  children?: Maybe<QuestionNodeUpdateManyInput>;
  edgeChildren?: Maybe<EdgeUpdateManyInput>;
}

export interface LeafNodeUpdateOneInput {
  create?: Maybe<LeafNodeCreateInput>;
  update?: Maybe<LeafNodeUpdateDataInput>;
  upsert?: Maybe<LeafNodeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<LeafNodeWhereUniqueInput>;
}

export interface LeafNodeUpdateDataInput {
  nodeId?: Maybe<Int>;
  type?: Maybe<NodeType>;
  title?: Maybe<String>;
}

export interface LeafNodeUpsertNestedInput {
  update: LeafNodeUpdateDataInput;
  create: LeafNodeCreateInput;
}

export interface QuestionConditionUpdateManyInput {
  create?: Maybe<QuestionConditionCreateInput[] | QuestionConditionCreateInput>;
  update?: Maybe<
    | QuestionConditionUpdateWithWhereUniqueNestedInput[]
    | QuestionConditionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QuestionConditionUpsertWithWhereUniqueNestedInput[]
    | QuestionConditionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    QuestionConditionWhereUniqueInput[] | QuestionConditionWhereUniqueInput
  >;
  connect?: Maybe<
    QuestionConditionWhereUniqueInput[] | QuestionConditionWhereUniqueInput
  >;
  set?: Maybe<
    QuestionConditionWhereUniqueInput[] | QuestionConditionWhereUniqueInput
  >;
  disconnect?: Maybe<
    QuestionConditionWhereUniqueInput[] | QuestionConditionWhereUniqueInput
  >;
  deleteMany?: Maybe<
    QuestionConditionScalarWhereInput[] | QuestionConditionScalarWhereInput
  >;
  updateMany?: Maybe<
    | QuestionConditionUpdateManyWithWhereNestedInput[]
    | QuestionConditionUpdateManyWithWhereNestedInput
  >;
}

export interface QuestionConditionUpdateWithWhereUniqueNestedInput {
  where: QuestionConditionWhereUniqueInput;
  data: QuestionConditionUpdateDataInput;
}

export interface QuestionConditionUpdateDataInput {
  conditionType?: Maybe<String>;
  renderMin?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  matchValue?: Maybe<String>;
}

export interface QuestionConditionUpsertWithWhereUniqueNestedInput {
  where: QuestionConditionWhereUniqueInput;
  update: QuestionConditionUpdateDataInput;
  create: QuestionConditionCreateInput;
}

export interface QuestionConditionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  conditionType?: Maybe<String>;
  conditionType_not?: Maybe<String>;
  conditionType_in?: Maybe<String[] | String>;
  conditionType_not_in?: Maybe<String[] | String>;
  conditionType_lt?: Maybe<String>;
  conditionType_lte?: Maybe<String>;
  conditionType_gt?: Maybe<String>;
  conditionType_gte?: Maybe<String>;
  conditionType_contains?: Maybe<String>;
  conditionType_not_contains?: Maybe<String>;
  conditionType_starts_with?: Maybe<String>;
  conditionType_not_starts_with?: Maybe<String>;
  conditionType_ends_with?: Maybe<String>;
  conditionType_not_ends_with?: Maybe<String>;
  renderMin?: Maybe<Int>;
  renderMin_not?: Maybe<Int>;
  renderMin_in?: Maybe<Int[] | Int>;
  renderMin_not_in?: Maybe<Int[] | Int>;
  renderMin_lt?: Maybe<Int>;
  renderMin_lte?: Maybe<Int>;
  renderMin_gt?: Maybe<Int>;
  renderMin_gte?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  renderMax_not?: Maybe<Int>;
  renderMax_in?: Maybe<Int[] | Int>;
  renderMax_not_in?: Maybe<Int[] | Int>;
  renderMax_lt?: Maybe<Int>;
  renderMax_lte?: Maybe<Int>;
  renderMax_gt?: Maybe<Int>;
  renderMax_gte?: Maybe<Int>;
  matchValue?: Maybe<String>;
  matchValue_not?: Maybe<String>;
  matchValue_in?: Maybe<String[] | String>;
  matchValue_not_in?: Maybe<String[] | String>;
  matchValue_lt?: Maybe<String>;
  matchValue_lte?: Maybe<String>;
  matchValue_gt?: Maybe<String>;
  matchValue_gte?: Maybe<String>;
  matchValue_contains?: Maybe<String>;
  matchValue_not_contains?: Maybe<String>;
  matchValue_starts_with?: Maybe<String>;
  matchValue_not_starts_with?: Maybe<String>;
  matchValue_ends_with?: Maybe<String>;
  matchValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    QuestionConditionScalarWhereInput[] | QuestionConditionScalarWhereInput
  >;
  OR?: Maybe<
    QuestionConditionScalarWhereInput[] | QuestionConditionScalarWhereInput
  >;
  NOT?: Maybe<
    QuestionConditionScalarWhereInput[] | QuestionConditionScalarWhereInput
  >;
}

export interface QuestionConditionUpdateManyWithWhereNestedInput {
  where: QuestionConditionScalarWhereInput;
  data: QuestionConditionUpdateManyDataInput;
}

export interface QuestionConditionUpdateManyDataInput {
  conditionType?: Maybe<String>;
  renderMin?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  matchValue?: Maybe<String>;
}

export interface QuestionOptionUpdateManyInput {
  create?: Maybe<QuestionOptionCreateInput[] | QuestionOptionCreateInput>;
  update?: Maybe<
    | QuestionOptionUpdateWithWhereUniqueNestedInput[]
    | QuestionOptionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QuestionOptionUpsertWithWhereUniqueNestedInput[]
    | QuestionOptionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    QuestionOptionWhereUniqueInput[] | QuestionOptionWhereUniqueInput
  >;
  connect?: Maybe<
    QuestionOptionWhereUniqueInput[] | QuestionOptionWhereUniqueInput
  >;
  set?: Maybe<
    QuestionOptionWhereUniqueInput[] | QuestionOptionWhereUniqueInput
  >;
  disconnect?: Maybe<
    QuestionOptionWhereUniqueInput[] | QuestionOptionWhereUniqueInput
  >;
  deleteMany?: Maybe<
    QuestionOptionScalarWhereInput[] | QuestionOptionScalarWhereInput
  >;
  updateMany?: Maybe<
    | QuestionOptionUpdateManyWithWhereNestedInput[]
    | QuestionOptionUpdateManyWithWhereNestedInput
  >;
}

export interface QuestionOptionUpdateWithWhereUniqueNestedInput {
  where: QuestionOptionWhereUniqueInput;
  data: QuestionOptionUpdateDataInput;
}

export interface QuestionOptionUpdateDataInput {
  value?: Maybe<String>;
  publicValue?: Maybe<String>;
}

export interface QuestionOptionUpsertWithWhereUniqueNestedInput {
  where: QuestionOptionWhereUniqueInput;
  update: QuestionOptionUpdateDataInput;
  create: QuestionOptionCreateInput;
}

export interface QuestionOptionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  publicValue?: Maybe<String>;
  publicValue_not?: Maybe<String>;
  publicValue_in?: Maybe<String[] | String>;
  publicValue_not_in?: Maybe<String[] | String>;
  publicValue_lt?: Maybe<String>;
  publicValue_lte?: Maybe<String>;
  publicValue_gt?: Maybe<String>;
  publicValue_gte?: Maybe<String>;
  publicValue_contains?: Maybe<String>;
  publicValue_not_contains?: Maybe<String>;
  publicValue_starts_with?: Maybe<String>;
  publicValue_not_starts_with?: Maybe<String>;
  publicValue_ends_with?: Maybe<String>;
  publicValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    QuestionOptionScalarWhereInput[] | QuestionOptionScalarWhereInput
  >;
  OR?: Maybe<QuestionOptionScalarWhereInput[] | QuestionOptionScalarWhereInput>;
  NOT?: Maybe<
    QuestionOptionScalarWhereInput[] | QuestionOptionScalarWhereInput
  >;
}

export interface QuestionOptionUpdateManyWithWhereNestedInput {
  where: QuestionOptionScalarWhereInput;
  data: QuestionOptionUpdateManyDataInput;
}

export interface QuestionOptionUpdateManyDataInput {
  value?: Maybe<String>;
  publicValue?: Maybe<String>;
}

export interface EdgeUpdateManyInput {
  create?: Maybe<EdgeCreateInput[] | EdgeCreateInput>;
  update?: Maybe<
    | EdgeUpdateWithWhereUniqueNestedInput[]
    | EdgeUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | EdgeUpsertWithWhereUniqueNestedInput[]
    | EdgeUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<EdgeWhereUniqueInput[] | EdgeWhereUniqueInput>;
  connect?: Maybe<EdgeWhereUniqueInput[] | EdgeWhereUniqueInput>;
  set?: Maybe<EdgeWhereUniqueInput[] | EdgeWhereUniqueInput>;
  disconnect?: Maybe<EdgeWhereUniqueInput[] | EdgeWhereUniqueInput>;
  deleteMany?: Maybe<EdgeScalarWhereInput[] | EdgeScalarWhereInput>;
}

export interface EdgeUpdateWithWhereUniqueNestedInput {
  where: EdgeWhereUniqueInput;
  data: EdgeUpdateDataInput;
}

export interface EdgeUpdateDataInput {
  conditions?: Maybe<QuestionConditionUpdateManyInput>;
  parentNode?: Maybe<QuestionNodeUpdateOneInput>;
  childNode?: Maybe<QuestionNodeUpdateOneInput>;
}

export interface QuestionNodeUpdateOneInput {
  create?: Maybe<QuestionNodeCreateInput>;
  update?: Maybe<QuestionNodeUpdateDataInput>;
  upsert?: Maybe<QuestionNodeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<QuestionNodeWhereUniqueInput>;
}

export interface QuestionNodeUpsertNestedInput {
  update: QuestionNodeUpdateDataInput;
  create: QuestionNodeCreateInput;
}

export interface EdgeUpsertWithWhereUniqueNestedInput {
  where: EdgeWhereUniqueInput;
  update: EdgeUpdateDataInput;
  create: EdgeCreateInput;
}

export interface EdgeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EdgeScalarWhereInput[] | EdgeScalarWhereInput>;
  OR?: Maybe<EdgeScalarWhereInput[] | EdgeScalarWhereInput>;
  NOT?: Maybe<EdgeScalarWhereInput[] | EdgeScalarWhereInput>;
}

export interface QuestionNodeUpsertWithWhereUniqueNestedInput {
  where: QuestionNodeWhereUniqueInput;
  update: QuestionNodeUpdateDataInput;
  create: QuestionNodeCreateInput;
}

export interface QuestionNodeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  branchVal?: Maybe<String>;
  branchVal_not?: Maybe<String>;
  branchVal_in?: Maybe<String[] | String>;
  branchVal_not_in?: Maybe<String[] | String>;
  branchVal_lt?: Maybe<String>;
  branchVal_lte?: Maybe<String>;
  branchVal_gt?: Maybe<String>;
  branchVal_gte?: Maybe<String>;
  branchVal_contains?: Maybe<String>;
  branchVal_not_contains?: Maybe<String>;
  branchVal_starts_with?: Maybe<String>;
  branchVal_not_starts_with?: Maybe<String>;
  branchVal_ends_with?: Maybe<String>;
  branchVal_not_ends_with?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  isRoot_not?: Maybe<Boolean>;
  questionType?: Maybe<NodeType>;
  questionType_not?: Maybe<NodeType>;
  questionType_in?: Maybe<NodeType[] | NodeType>;
  questionType_not_in?: Maybe<NodeType[] | NodeType>;
  AND?: Maybe<QuestionNodeScalarWhereInput[] | QuestionNodeScalarWhereInput>;
  OR?: Maybe<QuestionNodeScalarWhereInput[] | QuestionNodeScalarWhereInput>;
  NOT?: Maybe<QuestionNodeScalarWhereInput[] | QuestionNodeScalarWhereInput>;
}

export interface QuestionNodeUpdateManyWithWhereNestedInput {
  where: QuestionNodeScalarWhereInput;
  data: QuestionNodeUpdateManyDataInput;
}

export interface QuestionNodeUpdateManyDataInput {
  title?: Maybe<String>;
  branchVal?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  questionType?: Maybe<NodeType>;
}

export interface LeafNodeUpdateManyInput {
  create?: Maybe<LeafNodeCreateInput[] | LeafNodeCreateInput>;
  update?: Maybe<
    | LeafNodeUpdateWithWhereUniqueNestedInput[]
    | LeafNodeUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | LeafNodeUpsertWithWhereUniqueNestedInput[]
    | LeafNodeUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<LeafNodeWhereUniqueInput[] | LeafNodeWhereUniqueInput>;
  connect?: Maybe<LeafNodeWhereUniqueInput[] | LeafNodeWhereUniqueInput>;
  set?: Maybe<LeafNodeWhereUniqueInput[] | LeafNodeWhereUniqueInput>;
  disconnect?: Maybe<LeafNodeWhereUniqueInput[] | LeafNodeWhereUniqueInput>;
  deleteMany?: Maybe<LeafNodeScalarWhereInput[] | LeafNodeScalarWhereInput>;
  updateMany?: Maybe<
    | LeafNodeUpdateManyWithWhereNestedInput[]
    | LeafNodeUpdateManyWithWhereNestedInput
  >;
}

export interface LeafNodeUpdateWithWhereUniqueNestedInput {
  where: LeafNodeWhereUniqueInput;
  data: LeafNodeUpdateDataInput;
}

export interface LeafNodeUpsertWithWhereUniqueNestedInput {
  where: LeafNodeWhereUniqueInput;
  update: LeafNodeUpdateDataInput;
  create: LeafNodeCreateInput;
}

export interface LeafNodeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  nodeId?: Maybe<Int>;
  nodeId_not?: Maybe<Int>;
  nodeId_in?: Maybe<Int[] | Int>;
  nodeId_not_in?: Maybe<Int[] | Int>;
  nodeId_lt?: Maybe<Int>;
  nodeId_lte?: Maybe<Int>;
  nodeId_gt?: Maybe<Int>;
  nodeId_gte?: Maybe<Int>;
  type?: Maybe<NodeType>;
  type_not?: Maybe<NodeType>;
  type_in?: Maybe<NodeType[] | NodeType>;
  type_not_in?: Maybe<NodeType[] | NodeType>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<LeafNodeScalarWhereInput[] | LeafNodeScalarWhereInput>;
  OR?: Maybe<LeafNodeScalarWhereInput[] | LeafNodeScalarWhereInput>;
  NOT?: Maybe<LeafNodeScalarWhereInput[] | LeafNodeScalarWhereInput>;
}

export interface LeafNodeUpdateManyWithWhereNestedInput {
  where: LeafNodeScalarWhereInput;
  data: LeafNodeUpdateManyDataInput;
}

export interface LeafNodeUpdateManyDataInput {
  nodeId?: Maybe<Int>;
  type?: Maybe<NodeType>;
  title?: Maybe<String>;
}

export interface QuestionnaireUpsertWithWhereUniqueWithoutCustomerInput {
  where: QuestionnaireWhereUniqueInput;
  update: QuestionnaireUpdateWithoutCustomerDataInput;
  create: QuestionnaireCreateWithoutCustomerInput;
}

export interface QuestionnaireScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  publicTitle?: Maybe<String>;
  publicTitle_not?: Maybe<String>;
  publicTitle_in?: Maybe<String[] | String>;
  publicTitle_not_in?: Maybe<String[] | String>;
  publicTitle_lt?: Maybe<String>;
  publicTitle_lte?: Maybe<String>;
  publicTitle_gt?: Maybe<String>;
  publicTitle_gte?: Maybe<String>;
  publicTitle_contains?: Maybe<String>;
  publicTitle_not_contains?: Maybe<String>;
  publicTitle_starts_with?: Maybe<String>;
  publicTitle_not_starts_with?: Maybe<String>;
  publicTitle_ends_with?: Maybe<String>;
  publicTitle_not_ends_with?: Maybe<String>;
  creationDate?: Maybe<DateTimeInput>;
  creationDate_not?: Maybe<DateTimeInput>;
  creationDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  creationDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  creationDate_lt?: Maybe<DateTimeInput>;
  creationDate_lte?: Maybe<DateTimeInput>;
  creationDate_gt?: Maybe<DateTimeInput>;
  creationDate_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<QuestionnaireScalarWhereInput[] | QuestionnaireScalarWhereInput>;
  OR?: Maybe<QuestionnaireScalarWhereInput[] | QuestionnaireScalarWhereInput>;
  NOT?: Maybe<QuestionnaireScalarWhereInput[] | QuestionnaireScalarWhereInput>;
}

export interface QuestionnaireUpdateManyWithWhereNestedInput {
  where: QuestionnaireScalarWhereInput;
  data: QuestionnaireUpdateManyDataInput;
}

export interface QuestionnaireUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  publicTitle?: Maybe<String>;
}

export interface CustomerSettingsUpdateOneInput {
  create?: Maybe<CustomerSettingsCreateInput>;
  update?: Maybe<CustomerSettingsUpdateDataInput>;
  upsert?: Maybe<CustomerSettingsUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CustomerSettingsWhereUniqueInput>;
}

export interface CustomerSettingsUpdateDataInput {
  logoUrl?: Maybe<String>;
  colourSettings?: Maybe<ColourSettingsUpdateOneInput>;
  fontSettings?: Maybe<FontSettingsUpdateOneInput>;
}

export interface ColourSettingsUpdateOneInput {
  create?: Maybe<ColourSettingsCreateInput>;
  update?: Maybe<ColourSettingsUpdateDataInput>;
  upsert?: Maybe<ColourSettingsUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ColourSettingsWhereUniqueInput>;
}

export interface ColourSettingsUpdateDataInput {
  primary?: Maybe<String>;
  secondary?: Maybe<String>;
  tertiary?: Maybe<String>;
  success?: Maybe<String>;
  warning?: Maybe<String>;
  error?: Maybe<String>;
  lightest?: Maybe<String>;
  light?: Maybe<String>;
  normal?: Maybe<String>;
  dark?: Maybe<String>;
  darkest?: Maybe<String>;
  muted?: Maybe<String>;
  text?: Maybe<String>;
}

export interface ColourSettingsUpsertNestedInput {
  update: ColourSettingsUpdateDataInput;
  create: ColourSettingsCreateInput;
}

export interface FontSettingsUpdateOneInput {
  create?: Maybe<FontSettingsCreateInput>;
  update?: Maybe<FontSettingsUpdateDataInput>;
  upsert?: Maybe<FontSettingsUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<FontSettingsWhereUniqueInput>;
}

export interface FontSettingsUpdateDataInput {
  settingTitle?: Maybe<String>;
  body?: Maybe<String>;
  fontTitle?: Maybe<String>;
  special?: Maybe<String>;
}

export interface FontSettingsUpsertNestedInput {
  update: FontSettingsUpdateDataInput;
  create: FontSettingsCreateInput;
}

export interface CustomerSettingsUpsertNestedInput {
  update: CustomerSettingsUpdateDataInput;
  create: CustomerSettingsCreateInput;
}

export interface CustomerUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface CustomerSettingsUpdateInput {
  logoUrl?: Maybe<String>;
  colourSettings?: Maybe<ColourSettingsUpdateOneInput>;
  fontSettings?: Maybe<FontSettingsUpdateOneInput>;
}

export interface CustomerSettingsUpdateManyMutationInput {
  logoUrl?: Maybe<String>;
}

export interface EdgeUpdateInput {
  conditions?: Maybe<QuestionConditionUpdateManyInput>;
  parentNode?: Maybe<QuestionNodeUpdateOneInput>;
  childNode?: Maybe<QuestionNodeUpdateOneInput>;
}

export interface FontSettingsUpdateInput {
  settingTitle?: Maybe<String>;
  body?: Maybe<String>;
  fontTitle?: Maybe<String>;
  special?: Maybe<String>;
}

export interface FontSettingsUpdateManyMutationInput {
  settingTitle?: Maybe<String>;
  body?: Maybe<String>;
  fontTitle?: Maybe<String>;
  special?: Maybe<String>;
}

export interface LeafNodeUpdateInput {
  nodeId?: Maybe<Int>;
  type?: Maybe<NodeType>;
  title?: Maybe<String>;
}

export interface LeafNodeUpdateManyMutationInput {
  nodeId?: Maybe<Int>;
  type?: Maybe<NodeType>;
  title?: Maybe<String>;
}

export interface QuestionConditionUpdateInput {
  conditionType?: Maybe<String>;
  renderMin?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  matchValue?: Maybe<String>;
}

export interface QuestionConditionUpdateManyMutationInput {
  conditionType?: Maybe<String>;
  renderMin?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  matchValue?: Maybe<String>;
}

export interface QuestionNodeUpdateInput {
  title?: Maybe<String>;
  branchVal?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  questionType?: Maybe<NodeType>;
  overrideLeaf?: Maybe<LeafNodeUpdateOneInput>;
  conditions?: Maybe<QuestionConditionUpdateManyInput>;
  options?: Maybe<QuestionOptionUpdateManyInput>;
  children?: Maybe<QuestionNodeUpdateManyInput>;
  edgeChildren?: Maybe<EdgeUpdateManyInput>;
}

export interface QuestionNodeUpdateManyMutationInput {
  title?: Maybe<String>;
  branchVal?: Maybe<String>;
  isRoot?: Maybe<Boolean>;
  questionType?: Maybe<NodeType>;
}

export interface QuestionOptionUpdateInput {
  value?: Maybe<String>;
  publicValue?: Maybe<String>;
}

export interface QuestionOptionUpdateManyMutationInput {
  value?: Maybe<String>;
  publicValue?: Maybe<String>;
}

export interface QuestionnaireCreateInput {
  id?: Maybe<ID_Input>;
  customer: CustomerCreateOneWithoutQuestionnairesInput;
  title: String;
  description: String;
  publicTitle?: Maybe<String>;
  questions?: Maybe<QuestionNodeCreateManyInput>;
  leafs?: Maybe<LeafNodeCreateManyInput>;
}

export interface CustomerCreateOneWithoutQuestionnairesInput {
  create?: Maybe<CustomerCreateWithoutQuestionnairesInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerCreateWithoutQuestionnairesInput {
  id?: Maybe<ID_Input>;
  name: String;
  settings?: Maybe<CustomerSettingsCreateOneInput>;
}

export interface QuestionnaireUpdateInput {
  customer?: Maybe<CustomerUpdateOneRequiredWithoutQuestionnairesInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  publicTitle?: Maybe<String>;
  questions?: Maybe<QuestionNodeUpdateManyInput>;
  leafs?: Maybe<LeafNodeUpdateManyInput>;
}

export interface CustomerUpdateOneRequiredWithoutQuestionnairesInput {
  create?: Maybe<CustomerCreateWithoutQuestionnairesInput>;
  update?: Maybe<CustomerUpdateWithoutQuestionnairesDataInput>;
  upsert?: Maybe<CustomerUpsertWithoutQuestionnairesInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface CustomerUpdateWithoutQuestionnairesDataInput {
  name?: Maybe<String>;
  settings?: Maybe<CustomerSettingsUpdateOneInput>;
}

export interface CustomerUpsertWithoutQuestionnairesInput {
  update: CustomerUpdateWithoutQuestionnairesDataInput;
  create: CustomerCreateWithoutQuestionnairesInput;
}

export interface QuestionnaireUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  publicTitle?: Maybe<String>;
}

export interface ColourSettingsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ColourSettingsWhereInput>;
  AND?: Maybe<
    | ColourSettingsSubscriptionWhereInput[]
    | ColourSettingsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ColourSettingsSubscriptionWhereInput[]
    | ColourSettingsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ColourSettingsSubscriptionWhereInput[]
    | ColourSettingsSubscriptionWhereInput
  >;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerWhereInput>;
  AND?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
  OR?: Maybe<CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput>;
  NOT?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
}

export interface CustomerSettingsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerSettingsWhereInput>;
  AND?: Maybe<
    | CustomerSettingsSubscriptionWhereInput[]
    | CustomerSettingsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CustomerSettingsSubscriptionWhereInput[]
    | CustomerSettingsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CustomerSettingsSubscriptionWhereInput[]
    | CustomerSettingsSubscriptionWhereInput
  >;
}

export interface EdgeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EdgeWhereInput>;
  AND?: Maybe<EdgeSubscriptionWhereInput[] | EdgeSubscriptionWhereInput>;
  OR?: Maybe<EdgeSubscriptionWhereInput[] | EdgeSubscriptionWhereInput>;
  NOT?: Maybe<EdgeSubscriptionWhereInput[] | EdgeSubscriptionWhereInput>;
}

export interface FontSettingsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FontSettingsWhereInput>;
  AND?: Maybe<
    FontSettingsSubscriptionWhereInput[] | FontSettingsSubscriptionWhereInput
  >;
  OR?: Maybe<
    FontSettingsSubscriptionWhereInput[] | FontSettingsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    FontSettingsSubscriptionWhereInput[] | FontSettingsSubscriptionWhereInput
  >;
}

export interface LeafNodeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LeafNodeWhereInput>;
  AND?: Maybe<
    LeafNodeSubscriptionWhereInput[] | LeafNodeSubscriptionWhereInput
  >;
  OR?: Maybe<LeafNodeSubscriptionWhereInput[] | LeafNodeSubscriptionWhereInput>;
  NOT?: Maybe<
    LeafNodeSubscriptionWhereInput[] | LeafNodeSubscriptionWhereInput
  >;
}

export interface QuestionConditionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionConditionWhereInput>;
  AND?: Maybe<
    | QuestionConditionSubscriptionWhereInput[]
    | QuestionConditionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | QuestionConditionSubscriptionWhereInput[]
    | QuestionConditionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | QuestionConditionSubscriptionWhereInput[]
    | QuestionConditionSubscriptionWhereInput
  >;
}

export interface QuestionNodeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionNodeWhereInput>;
  AND?: Maybe<
    QuestionNodeSubscriptionWhereInput[] | QuestionNodeSubscriptionWhereInput
  >;
  OR?: Maybe<
    QuestionNodeSubscriptionWhereInput[] | QuestionNodeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    QuestionNodeSubscriptionWhereInput[] | QuestionNodeSubscriptionWhereInput
  >;
}

export interface QuestionOptionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionOptionWhereInput>;
  AND?: Maybe<
    | QuestionOptionSubscriptionWhereInput[]
    | QuestionOptionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | QuestionOptionSubscriptionWhereInput[]
    | QuestionOptionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | QuestionOptionSubscriptionWhereInput[]
    | QuestionOptionSubscriptionWhereInput
  >;
}

export interface QuestionnaireSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionnaireWhereInput>;
  AND?: Maybe<
    QuestionnaireSubscriptionWhereInput[] | QuestionnaireSubscriptionWhereInput
  >;
  OR?: Maybe<
    QuestionnaireSubscriptionWhereInput[] | QuestionnaireSubscriptionWhereInput
  >;
  NOT?: Maybe<
    QuestionnaireSubscriptionWhereInput[] | QuestionnaireSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface ColourSettings {
  id: ID_Output;
  primary: String;
  secondary?: String;
  tertiary?: String;
  success?: String;
  warning?: String;
  error?: String;
  lightest?: String;
  light?: String;
  normal?: String;
  dark?: String;
  darkest?: String;
  muted?: String;
  text?: String;
}

export interface ColourSettingsPromise
  extends Promise<ColourSettings>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  primary: () => Promise<String>;
  secondary: () => Promise<String>;
  tertiary: () => Promise<String>;
  success: () => Promise<String>;
  warning: () => Promise<String>;
  error: () => Promise<String>;
  lightest: () => Promise<String>;
  light: () => Promise<String>;
  normal: () => Promise<String>;
  dark: () => Promise<String>;
  darkest: () => Promise<String>;
  muted: () => Promise<String>;
  text: () => Promise<String>;
}

export interface ColourSettingsSubscription
  extends Promise<AsyncIterator<ColourSettings>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  primary: () => Promise<AsyncIterator<String>>;
  secondary: () => Promise<AsyncIterator<String>>;
  tertiary: () => Promise<AsyncIterator<String>>;
  success: () => Promise<AsyncIterator<String>>;
  warning: () => Promise<AsyncIterator<String>>;
  error: () => Promise<AsyncIterator<String>>;
  lightest: () => Promise<AsyncIterator<String>>;
  light: () => Promise<AsyncIterator<String>>;
  normal: () => Promise<AsyncIterator<String>>;
  dark: () => Promise<AsyncIterator<String>>;
  darkest: () => Promise<AsyncIterator<String>>;
  muted: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface ColourSettingsNullablePromise
  extends Promise<ColourSettings | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  primary: () => Promise<String>;
  secondary: () => Promise<String>;
  tertiary: () => Promise<String>;
  success: () => Promise<String>;
  warning: () => Promise<String>;
  error: () => Promise<String>;
  lightest: () => Promise<String>;
  light: () => Promise<String>;
  normal: () => Promise<String>;
  dark: () => Promise<String>;
  darkest: () => Promise<String>;
  muted: () => Promise<String>;
  text: () => Promise<String>;
}

export interface ColourSettingsConnection {
  pageInfo: PageInfo;
  edges: ColourSettingsEdge[];
}

export interface ColourSettingsConnectionPromise
  extends Promise<ColourSettingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ColourSettingsEdge>>() => T;
  aggregate: <T = AggregateColourSettingsPromise>() => T;
}

export interface ColourSettingsConnectionSubscription
  extends Promise<AsyncIterator<ColourSettingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ColourSettingsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateColourSettingsSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ColourSettingsEdge {
  node: ColourSettings;
  cursor: String;
}

export interface ColourSettingsEdgePromise
  extends Promise<ColourSettingsEdge>,
    Fragmentable {
  node: <T = ColourSettingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ColourSettingsEdgeSubscription
  extends Promise<AsyncIterator<ColourSettingsEdge>>,
    Fragmentable {
  node: <T = ColourSettingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateColourSettings {
  count: Int;
}

export interface AggregateColourSettingsPromise
  extends Promise<AggregateColourSettings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateColourSettingsSubscription
  extends Promise<AsyncIterator<AggregateColourSettings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Customer {
  id: ID_Output;
  name: String;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  questionnaires: <T = FragmentableArray<Questionnaire>>(args?: {
    where?: QuestionnaireWhereInput;
    orderBy?: QuestionnaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  settings: <T = CustomerSettingsPromise>() => T;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  questionnaires: <
    T = Promise<AsyncIterator<QuestionnaireSubscription>>
  >(args?: {
    where?: QuestionnaireWhereInput;
    orderBy?: QuestionnaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  settings: <T = CustomerSettingsSubscription>() => T;
}

export interface CustomerNullablePromise
  extends Promise<Customer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  questionnaires: <T = FragmentableArray<Questionnaire>>(args?: {
    where?: QuestionnaireWhereInput;
    orderBy?: QuestionnaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  settings: <T = CustomerSettingsPromise>() => T;
}

export interface Questionnaire {
  id: ID_Output;
  title: String;
  description: String;
  publicTitle?: String;
  creationDate: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface QuestionnairePromise
  extends Promise<Questionnaire>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
  publicTitle: () => Promise<String>;
  creationDate: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  questions: <T = FragmentableArray<QuestionNode>>(args?: {
    where?: QuestionNodeWhereInput;
    orderBy?: QuestionNodeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  leafs: <T = FragmentableArray<LeafNode>>(args?: {
    where?: LeafNodeWhereInput;
    orderBy?: LeafNodeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuestionnaireSubscription
  extends Promise<AsyncIterator<Questionnaire>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customer: <T = CustomerSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  publicTitle: () => Promise<AsyncIterator<String>>;
  creationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  questions: <T = Promise<AsyncIterator<QuestionNodeSubscription>>>(args?: {
    where?: QuestionNodeWhereInput;
    orderBy?: QuestionNodeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  leafs: <T = Promise<AsyncIterator<LeafNodeSubscription>>>(args?: {
    where?: LeafNodeWhereInput;
    orderBy?: LeafNodeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuestionnaireNullablePromise
  extends Promise<Questionnaire | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
  publicTitle: () => Promise<String>;
  creationDate: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  questions: <T = FragmentableArray<QuestionNode>>(args?: {
    where?: QuestionNodeWhereInput;
    orderBy?: QuestionNodeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  leafs: <T = FragmentableArray<LeafNode>>(args?: {
    where?: LeafNodeWhereInput;
    orderBy?: LeafNodeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuestionNode {
  id: ID_Output;
  title: String;
  branchVal?: String;
  isRoot: Boolean;
  questionType: NodeType;
}

export interface QuestionNodePromise
  extends Promise<QuestionNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  branchVal: () => Promise<String>;
  isRoot: () => Promise<Boolean>;
  questionType: () => Promise<NodeType>;
  overrideLeaf: <T = LeafNodePromise>() => T;
  conditions: <T = FragmentableArray<QuestionCondition>>(args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  options: <T = FragmentableArray<QuestionOption>>(args?: {
    where?: QuestionOptionWhereInput;
    orderBy?: QuestionOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = FragmentableArray<QuestionNode>>(args?: {
    where?: QuestionNodeWhereInput;
    orderBy?: QuestionNodeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  edgeChildren: <T = FragmentableArray<Edge>>(args?: {
    where?: EdgeWhereInput;
    orderBy?: EdgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuestionNodeSubscription
  extends Promise<AsyncIterator<QuestionNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  branchVal: () => Promise<AsyncIterator<String>>;
  isRoot: () => Promise<AsyncIterator<Boolean>>;
  questionType: () => Promise<AsyncIterator<NodeType>>;
  overrideLeaf: <T = LeafNodeSubscription>() => T;
  conditions: <
    T = Promise<AsyncIterator<QuestionConditionSubscription>>
  >(args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  options: <T = Promise<AsyncIterator<QuestionOptionSubscription>>>(args?: {
    where?: QuestionOptionWhereInput;
    orderBy?: QuestionOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = Promise<AsyncIterator<QuestionNodeSubscription>>>(args?: {
    where?: QuestionNodeWhereInput;
    orderBy?: QuestionNodeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  edgeChildren: <T = Promise<AsyncIterator<EdgeSubscription>>>(args?: {
    where?: EdgeWhereInput;
    orderBy?: EdgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuestionNodeNullablePromise
  extends Promise<QuestionNode | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  branchVal: () => Promise<String>;
  isRoot: () => Promise<Boolean>;
  questionType: () => Promise<NodeType>;
  overrideLeaf: <T = LeafNodePromise>() => T;
  conditions: <T = FragmentableArray<QuestionCondition>>(args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  options: <T = FragmentableArray<QuestionOption>>(args?: {
    where?: QuestionOptionWhereInput;
    orderBy?: QuestionOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = FragmentableArray<QuestionNode>>(args?: {
    where?: QuestionNodeWhereInput;
    orderBy?: QuestionNodeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  edgeChildren: <T = FragmentableArray<Edge>>(args?: {
    where?: EdgeWhereInput;
    orderBy?: EdgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LeafNode {
  id: ID_Output;
  nodeId?: Int;
  type?: NodeType;
  title: String;
}

export interface LeafNodePromise extends Promise<LeafNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  nodeId: () => Promise<Int>;
  type: () => Promise<NodeType>;
  title: () => Promise<String>;
}

export interface LeafNodeSubscription
  extends Promise<AsyncIterator<LeafNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nodeId: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<NodeType>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface LeafNodeNullablePromise
  extends Promise<LeafNode | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nodeId: () => Promise<Int>;
  type: () => Promise<NodeType>;
  title: () => Promise<String>;
}

export interface QuestionCondition {
  id: ID_Output;
  conditionType: String;
  renderMin?: Int;
  renderMax?: Int;
  matchValue?: String;
}

export interface QuestionConditionPromise
  extends Promise<QuestionCondition>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  conditionType: () => Promise<String>;
  renderMin: () => Promise<Int>;
  renderMax: () => Promise<Int>;
  matchValue: () => Promise<String>;
}

export interface QuestionConditionSubscription
  extends Promise<AsyncIterator<QuestionCondition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  conditionType: () => Promise<AsyncIterator<String>>;
  renderMin: () => Promise<AsyncIterator<Int>>;
  renderMax: () => Promise<AsyncIterator<Int>>;
  matchValue: () => Promise<AsyncIterator<String>>;
}

export interface QuestionConditionNullablePromise
  extends Promise<QuestionCondition | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  conditionType: () => Promise<String>;
  renderMin: () => Promise<Int>;
  renderMax: () => Promise<Int>;
  matchValue: () => Promise<String>;
}

export interface QuestionOption {
  id: ID_Output;
  value: String;
  publicValue?: String;
}

export interface QuestionOptionPromise
  extends Promise<QuestionOption>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  publicValue: () => Promise<String>;
}

export interface QuestionOptionSubscription
  extends Promise<AsyncIterator<QuestionOption>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  publicValue: () => Promise<AsyncIterator<String>>;
}

export interface QuestionOptionNullablePromise
  extends Promise<QuestionOption | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  publicValue: () => Promise<String>;
}

export interface Edge {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EdgePromise extends Promise<Edge>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  conditions: <T = FragmentableArray<QuestionCondition>>(args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parentNode: <T = QuestionNodePromise>() => T;
  childNode: <T = QuestionNodePromise>() => T;
}

export interface EdgeSubscription
  extends Promise<AsyncIterator<Edge>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  conditions: <
    T = Promise<AsyncIterator<QuestionConditionSubscription>>
  >(args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parentNode: <T = QuestionNodeSubscription>() => T;
  childNode: <T = QuestionNodeSubscription>() => T;
}

export interface EdgeNullablePromise
  extends Promise<Edge | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  conditions: <T = FragmentableArray<QuestionCondition>>(args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parentNode: <T = QuestionNodePromise>() => T;
  childNode: <T = QuestionNodePromise>() => T;
}

export interface CustomerSettings {
  id: ID_Output;
  logoUrl?: String;
}

export interface CustomerSettingsPromise
  extends Promise<CustomerSettings>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  logoUrl: () => Promise<String>;
  colourSettings: <T = ColourSettingsPromise>() => T;
  fontSettings: <T = FontSettingsPromise>() => T;
}

export interface CustomerSettingsSubscription
  extends Promise<AsyncIterator<CustomerSettings>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  logoUrl: () => Promise<AsyncIterator<String>>;
  colourSettings: <T = ColourSettingsSubscription>() => T;
  fontSettings: <T = FontSettingsSubscription>() => T;
}

export interface CustomerSettingsNullablePromise
  extends Promise<CustomerSettings | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  logoUrl: () => Promise<String>;
  colourSettings: <T = ColourSettingsPromise>() => T;
  fontSettings: <T = FontSettingsPromise>() => T;
}

export interface FontSettings {
  id: ID_Output;
  settingTitle?: String;
  body?: String;
  fontTitle?: String;
  special?: String;
}

export interface FontSettingsPromise
  extends Promise<FontSettings>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  settingTitle: () => Promise<String>;
  body: () => Promise<String>;
  fontTitle: () => Promise<String>;
  special: () => Promise<String>;
}

export interface FontSettingsSubscription
  extends Promise<AsyncIterator<FontSettings>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  settingTitle: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  fontTitle: () => Promise<AsyncIterator<String>>;
  special: () => Promise<AsyncIterator<String>>;
}

export interface FontSettingsNullablePromise
  extends Promise<FontSettings | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  settingTitle: () => Promise<String>;
  body: () => Promise<String>;
  fontTitle: () => Promise<String>;
  special: () => Promise<String>;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerSettingsConnection {
  pageInfo: PageInfo;
  edges: CustomerSettingsEdge[];
}

export interface CustomerSettingsConnectionPromise
  extends Promise<CustomerSettingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerSettingsEdge>>() => T;
  aggregate: <T = AggregateCustomerSettingsPromise>() => T;
}

export interface CustomerSettingsConnectionSubscription
  extends Promise<AsyncIterator<CustomerSettingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerSettingsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSettingsSubscription>() => T;
}

export interface CustomerSettingsEdge {
  node: CustomerSettings;
  cursor: String;
}

export interface CustomerSettingsEdgePromise
  extends Promise<CustomerSettingsEdge>,
    Fragmentable {
  node: <T = CustomerSettingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerSettingsEdgeSubscription
  extends Promise<AsyncIterator<CustomerSettingsEdge>>,
    Fragmentable {
  node: <T = CustomerSettingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomerSettings {
  count: Int;
}

export interface AggregateCustomerSettingsPromise
  extends Promise<AggregateCustomerSettings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSettingsSubscription
  extends Promise<AsyncIterator<AggregateCustomerSettings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EdgeConnection {
  pageInfo: PageInfo;
  edges: EdgeEdge[];
}

export interface EdgeConnectionPromise
  extends Promise<EdgeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EdgeEdge>>() => T;
  aggregate: <T = AggregateEdgePromise>() => T;
}

export interface EdgeConnectionSubscription
  extends Promise<AsyncIterator<EdgeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EdgeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEdgeSubscription>() => T;
}

export interface EdgeEdge {
  node: Edge;
  cursor: String;
}

export interface EdgeEdgePromise extends Promise<EdgeEdge>, Fragmentable {
  node: <T = EdgePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EdgeEdgeSubscription
  extends Promise<AsyncIterator<EdgeEdge>>,
    Fragmentable {
  node: <T = EdgeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEdge {
  count: Int;
}

export interface AggregateEdgePromise
  extends Promise<AggregateEdge>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEdgeSubscription
  extends Promise<AsyncIterator<AggregateEdge>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FontSettingsConnection {
  pageInfo: PageInfo;
  edges: FontSettingsEdge[];
}

export interface FontSettingsConnectionPromise
  extends Promise<FontSettingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FontSettingsEdge>>() => T;
  aggregate: <T = AggregateFontSettingsPromise>() => T;
}

export interface FontSettingsConnectionSubscription
  extends Promise<AsyncIterator<FontSettingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FontSettingsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFontSettingsSubscription>() => T;
}

export interface FontSettingsEdge {
  node: FontSettings;
  cursor: String;
}

export interface FontSettingsEdgePromise
  extends Promise<FontSettingsEdge>,
    Fragmentable {
  node: <T = FontSettingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FontSettingsEdgeSubscription
  extends Promise<AsyncIterator<FontSettingsEdge>>,
    Fragmentable {
  node: <T = FontSettingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFontSettings {
  count: Int;
}

export interface AggregateFontSettingsPromise
  extends Promise<AggregateFontSettings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFontSettingsSubscription
  extends Promise<AsyncIterator<AggregateFontSettings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LeafNodeConnection {
  pageInfo: PageInfo;
  edges: LeafNodeEdge[];
}

export interface LeafNodeConnectionPromise
  extends Promise<LeafNodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LeafNodeEdge>>() => T;
  aggregate: <T = AggregateLeafNodePromise>() => T;
}

export interface LeafNodeConnectionSubscription
  extends Promise<AsyncIterator<LeafNodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LeafNodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLeafNodeSubscription>() => T;
}

export interface LeafNodeEdge {
  node: LeafNode;
  cursor: String;
}

export interface LeafNodeEdgePromise
  extends Promise<LeafNodeEdge>,
    Fragmentable {
  node: <T = LeafNodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LeafNodeEdgeSubscription
  extends Promise<AsyncIterator<LeafNodeEdge>>,
    Fragmentable {
  node: <T = LeafNodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLeafNode {
  count: Int;
}

export interface AggregateLeafNodePromise
  extends Promise<AggregateLeafNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLeafNodeSubscription
  extends Promise<AsyncIterator<AggregateLeafNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionConditionConnection {
  pageInfo: PageInfo;
  edges: QuestionConditionEdge[];
}

export interface QuestionConditionConnectionPromise
  extends Promise<QuestionConditionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionConditionEdge>>() => T;
  aggregate: <T = AggregateQuestionConditionPromise>() => T;
}

export interface QuestionConditionConnectionSubscription
  extends Promise<AsyncIterator<QuestionConditionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionConditionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionConditionSubscription>() => T;
}

export interface QuestionConditionEdge {
  node: QuestionCondition;
  cursor: String;
}

export interface QuestionConditionEdgePromise
  extends Promise<QuestionConditionEdge>,
    Fragmentable {
  node: <T = QuestionConditionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionConditionEdgeSubscription
  extends Promise<AsyncIterator<QuestionConditionEdge>>,
    Fragmentable {
  node: <T = QuestionConditionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuestionCondition {
  count: Int;
}

export interface AggregateQuestionConditionPromise
  extends Promise<AggregateQuestionCondition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionConditionSubscription
  extends Promise<AsyncIterator<AggregateQuestionCondition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionNodeConnection {
  pageInfo: PageInfo;
  edges: QuestionNodeEdge[];
}

export interface QuestionNodeConnectionPromise
  extends Promise<QuestionNodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionNodeEdge>>() => T;
  aggregate: <T = AggregateQuestionNodePromise>() => T;
}

export interface QuestionNodeConnectionSubscription
  extends Promise<AsyncIterator<QuestionNodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionNodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionNodeSubscription>() => T;
}

export interface QuestionNodeEdge {
  node: QuestionNode;
  cursor: String;
}

export interface QuestionNodeEdgePromise
  extends Promise<QuestionNodeEdge>,
    Fragmentable {
  node: <T = QuestionNodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionNodeEdgeSubscription
  extends Promise<AsyncIterator<QuestionNodeEdge>>,
    Fragmentable {
  node: <T = QuestionNodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuestionNode {
  count: Int;
}

export interface AggregateQuestionNodePromise
  extends Promise<AggregateQuestionNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionNodeSubscription
  extends Promise<AsyncIterator<AggregateQuestionNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionOptionConnection {
  pageInfo: PageInfo;
  edges: QuestionOptionEdge[];
}

export interface QuestionOptionConnectionPromise
  extends Promise<QuestionOptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionOptionEdge>>() => T;
  aggregate: <T = AggregateQuestionOptionPromise>() => T;
}

export interface QuestionOptionConnectionSubscription
  extends Promise<AsyncIterator<QuestionOptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionOptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionOptionSubscription>() => T;
}

export interface QuestionOptionEdge {
  node: QuestionOption;
  cursor: String;
}

export interface QuestionOptionEdgePromise
  extends Promise<QuestionOptionEdge>,
    Fragmentable {
  node: <T = QuestionOptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionOptionEdgeSubscription
  extends Promise<AsyncIterator<QuestionOptionEdge>>,
    Fragmentable {
  node: <T = QuestionOptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuestionOption {
  count: Int;
}

export interface AggregateQuestionOptionPromise
  extends Promise<AggregateQuestionOption>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionOptionSubscription
  extends Promise<AsyncIterator<AggregateQuestionOption>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionnaireConnection {
  pageInfo: PageInfo;
  edges: QuestionnaireEdge[];
}

export interface QuestionnaireConnectionPromise
  extends Promise<QuestionnaireConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionnaireEdge>>() => T;
  aggregate: <T = AggregateQuestionnairePromise>() => T;
}

export interface QuestionnaireConnectionSubscription
  extends Promise<AsyncIterator<QuestionnaireConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionnaireEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionnaireSubscription>() => T;
}

export interface QuestionnaireEdge {
  node: Questionnaire;
  cursor: String;
}

export interface QuestionnaireEdgePromise
  extends Promise<QuestionnaireEdge>,
    Fragmentable {
  node: <T = QuestionnairePromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionnaireEdgeSubscription
  extends Promise<AsyncIterator<QuestionnaireEdge>>,
    Fragmentable {
  node: <T = QuestionnaireSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuestionnaire {
  count: Int;
}

export interface AggregateQuestionnairePromise
  extends Promise<AggregateQuestionnaire>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionnaireSubscription
  extends Promise<AsyncIterator<AggregateQuestionnaire>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ColourSettingsSubscriptionPayload {
  mutation: MutationType;
  node: ColourSettings;
  updatedFields: String[];
  previousValues: ColourSettingsPreviousValues;
}

export interface ColourSettingsSubscriptionPayloadPromise
  extends Promise<ColourSettingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ColourSettingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ColourSettingsPreviousValuesPromise>() => T;
}

export interface ColourSettingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ColourSettingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ColourSettingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ColourSettingsPreviousValuesSubscription>() => T;
}

export interface ColourSettingsPreviousValues {
  id: ID_Output;
  primary: String;
  secondary?: String;
  tertiary?: String;
  success?: String;
  warning?: String;
  error?: String;
  lightest?: String;
  light?: String;
  normal?: String;
  dark?: String;
  darkest?: String;
  muted?: String;
  text?: String;
}

export interface ColourSettingsPreviousValuesPromise
  extends Promise<ColourSettingsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  primary: () => Promise<String>;
  secondary: () => Promise<String>;
  tertiary: () => Promise<String>;
  success: () => Promise<String>;
  warning: () => Promise<String>;
  error: () => Promise<String>;
  lightest: () => Promise<String>;
  light: () => Promise<String>;
  normal: () => Promise<String>;
  dark: () => Promise<String>;
  darkest: () => Promise<String>;
  muted: () => Promise<String>;
  text: () => Promise<String>;
}

export interface ColourSettingsPreviousValuesSubscription
  extends Promise<AsyncIterator<ColourSettingsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  primary: () => Promise<AsyncIterator<String>>;
  secondary: () => Promise<AsyncIterator<String>>;
  tertiary: () => Promise<AsyncIterator<String>>;
  success: () => Promise<AsyncIterator<String>>;
  warning: () => Promise<AsyncIterator<String>>;
  error: () => Promise<AsyncIterator<String>>;
  lightest: () => Promise<AsyncIterator<String>>;
  light: () => Promise<AsyncIterator<String>>;
  normal: () => Promise<AsyncIterator<String>>;
  dark: () => Promise<AsyncIterator<String>>;
  darkest: () => Promise<AsyncIterator<String>>;
  muted: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface CustomerPreviousValues {
  id: ID_Output;
  name: String;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface CustomerSettingsSubscriptionPayload {
  mutation: MutationType;
  node: CustomerSettings;
  updatedFields: String[];
  previousValues: CustomerSettingsPreviousValues;
}

export interface CustomerSettingsSubscriptionPayloadPromise
  extends Promise<CustomerSettingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerSettingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerSettingsPreviousValuesPromise>() => T;
}

export interface CustomerSettingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSettingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSettingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerSettingsPreviousValuesSubscription>() => T;
}

export interface CustomerSettingsPreviousValues {
  id: ID_Output;
  logoUrl?: String;
}

export interface CustomerSettingsPreviousValuesPromise
  extends Promise<CustomerSettingsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  logoUrl: () => Promise<String>;
}

export interface CustomerSettingsPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerSettingsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  logoUrl: () => Promise<AsyncIterator<String>>;
}

export interface EdgeSubscriptionPayload {
  mutation: MutationType;
  node: Edge;
  updatedFields: String[];
  previousValues: EdgePreviousValues;
}

export interface EdgeSubscriptionPayloadPromise
  extends Promise<EdgeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EdgePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EdgePreviousValuesPromise>() => T;
}

export interface EdgeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EdgeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EdgeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EdgePreviousValuesSubscription>() => T;
}

export interface EdgePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EdgePreviousValuesPromise
  extends Promise<EdgePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EdgePreviousValuesSubscription
  extends Promise<AsyncIterator<EdgePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FontSettingsSubscriptionPayload {
  mutation: MutationType;
  node: FontSettings;
  updatedFields: String[];
  previousValues: FontSettingsPreviousValues;
}

export interface FontSettingsSubscriptionPayloadPromise
  extends Promise<FontSettingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FontSettingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FontSettingsPreviousValuesPromise>() => T;
}

export interface FontSettingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FontSettingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FontSettingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FontSettingsPreviousValuesSubscription>() => T;
}

export interface FontSettingsPreviousValues {
  id: ID_Output;
  settingTitle?: String;
  body?: String;
  fontTitle?: String;
  special?: String;
}

export interface FontSettingsPreviousValuesPromise
  extends Promise<FontSettingsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  settingTitle: () => Promise<String>;
  body: () => Promise<String>;
  fontTitle: () => Promise<String>;
  special: () => Promise<String>;
}

export interface FontSettingsPreviousValuesSubscription
  extends Promise<AsyncIterator<FontSettingsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  settingTitle: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  fontTitle: () => Promise<AsyncIterator<String>>;
  special: () => Promise<AsyncIterator<String>>;
}

export interface LeafNodeSubscriptionPayload {
  mutation: MutationType;
  node: LeafNode;
  updatedFields: String[];
  previousValues: LeafNodePreviousValues;
}

export interface LeafNodeSubscriptionPayloadPromise
  extends Promise<LeafNodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LeafNodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LeafNodePreviousValuesPromise>() => T;
}

export interface LeafNodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LeafNodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LeafNodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LeafNodePreviousValuesSubscription>() => T;
}

export interface LeafNodePreviousValues {
  id: ID_Output;
  nodeId?: Int;
  type?: NodeType;
  title: String;
}

export interface LeafNodePreviousValuesPromise
  extends Promise<LeafNodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nodeId: () => Promise<Int>;
  type: () => Promise<NodeType>;
  title: () => Promise<String>;
}

export interface LeafNodePreviousValuesSubscription
  extends Promise<AsyncIterator<LeafNodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nodeId: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<NodeType>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface QuestionConditionSubscriptionPayload {
  mutation: MutationType;
  node: QuestionCondition;
  updatedFields: String[];
  previousValues: QuestionConditionPreviousValues;
}

export interface QuestionConditionSubscriptionPayloadPromise
  extends Promise<QuestionConditionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionConditionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionConditionPreviousValuesPromise>() => T;
}

export interface QuestionConditionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionConditionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionConditionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionConditionPreviousValuesSubscription>() => T;
}

export interface QuestionConditionPreviousValues {
  id: ID_Output;
  conditionType: String;
  renderMin?: Int;
  renderMax?: Int;
  matchValue?: String;
}

export interface QuestionConditionPreviousValuesPromise
  extends Promise<QuestionConditionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  conditionType: () => Promise<String>;
  renderMin: () => Promise<Int>;
  renderMax: () => Promise<Int>;
  matchValue: () => Promise<String>;
}

export interface QuestionConditionPreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionConditionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  conditionType: () => Promise<AsyncIterator<String>>;
  renderMin: () => Promise<AsyncIterator<Int>>;
  renderMax: () => Promise<AsyncIterator<Int>>;
  matchValue: () => Promise<AsyncIterator<String>>;
}

export interface QuestionNodeSubscriptionPayload {
  mutation: MutationType;
  node: QuestionNode;
  updatedFields: String[];
  previousValues: QuestionNodePreviousValues;
}

export interface QuestionNodeSubscriptionPayloadPromise
  extends Promise<QuestionNodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionNodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionNodePreviousValuesPromise>() => T;
}

export interface QuestionNodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionNodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionNodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionNodePreviousValuesSubscription>() => T;
}

export interface QuestionNodePreviousValues {
  id: ID_Output;
  title: String;
  branchVal?: String;
  isRoot: Boolean;
  questionType: NodeType;
}

export interface QuestionNodePreviousValuesPromise
  extends Promise<QuestionNodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  branchVal: () => Promise<String>;
  isRoot: () => Promise<Boolean>;
  questionType: () => Promise<NodeType>;
}

export interface QuestionNodePreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionNodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  branchVal: () => Promise<AsyncIterator<String>>;
  isRoot: () => Promise<AsyncIterator<Boolean>>;
  questionType: () => Promise<AsyncIterator<NodeType>>;
}

export interface QuestionOptionSubscriptionPayload {
  mutation: MutationType;
  node: QuestionOption;
  updatedFields: String[];
  previousValues: QuestionOptionPreviousValues;
}

export interface QuestionOptionSubscriptionPayloadPromise
  extends Promise<QuestionOptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionOptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionOptionPreviousValuesPromise>() => T;
}

export interface QuestionOptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionOptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionOptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionOptionPreviousValuesSubscription>() => T;
}

export interface QuestionOptionPreviousValues {
  id: ID_Output;
  value: String;
  publicValue?: String;
}

export interface QuestionOptionPreviousValuesPromise
  extends Promise<QuestionOptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  publicValue: () => Promise<String>;
}

export interface QuestionOptionPreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionOptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  publicValue: () => Promise<AsyncIterator<String>>;
}

export interface QuestionnaireSubscriptionPayload {
  mutation: MutationType;
  node: Questionnaire;
  updatedFields: String[];
  previousValues: QuestionnairePreviousValues;
}

export interface QuestionnaireSubscriptionPayloadPromise
  extends Promise<QuestionnaireSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionnairePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionnairePreviousValuesPromise>() => T;
}

export interface QuestionnaireSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionnaireSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionnaireSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionnairePreviousValuesSubscription>() => T;
}

export interface QuestionnairePreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  publicTitle?: String;
  creationDate: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface QuestionnairePreviousValuesPromise
  extends Promise<QuestionnairePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  publicTitle: () => Promise<String>;
  creationDate: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface QuestionnairePreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionnairePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  publicTitle: () => Promise<AsyncIterator<String>>;
  creationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "NodeType",
    embedded: false
  },
  {
    name: "LeafNode",
    embedded: false
  },
  {
    name: "Questionnaire",
    embedded: false
  },
  {
    name: "ColourSettings",
    embedded: false
  },
  {
    name: "FontSettings",
    embedded: false
  },
  {
    name: "Customer",
    embedded: false
  },
  {
    name: "CustomerSettings",
    embedded: false
  },
  {
    name: "QuestionCondition",
    embedded: false
  },
  {
    name: "QuestionOption",
    embedded: false
  },
  {
    name: "QuestionNode",
    embedded: false
  },
  {
    name: "Edge",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SERVICE_SECRET"]}`
});
export const prisma = new Prisma();
