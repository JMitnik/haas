// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  colourSettings: (where?: ColourSettingsWhereInput) => Promise<boolean>;
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  fontSettings: (where?: FontSettingsWhereInput) => Promise<boolean>;
  leafNode: (where?: LeafNodeWhereInput) => Promise<boolean>;
  qQuestion: (where?: QQuestionWhereInput) => Promise<boolean>;
  questionCondition: (where?: QuestionConditionWhereInput) => Promise<boolean>;
  questionOption: (where?: QuestionOptionWhereInput) => Promise<boolean>;
  questionnaire: (where?: QuestionnaireWhereInput) => Promise<boolean>;
  questionnaireSettings: (
    where?: QuestionnaireSettingsWhereInput
  ) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  colourSettings: (
    where: ColourSettingsWhereUniqueInput
  ) => ColourSettingsNullablePromise;
  colourSettingses: (args?: {
    where?: ColourSettingsWhereInput;
    orderBy?: ColourSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ColourSettings>;
  colourSettingsesConnection: (args?: {
    where?: ColourSettingsWhereInput;
    orderBy?: ColourSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ColourSettingsConnectionPromise;
  customer: (where: CustomerWhereUniqueInput) => CustomerNullablePromise;
  customers: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Customer>;
  customersConnection: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerConnectionPromise;
  fontSettings: (
    where: FontSettingsWhereUniqueInput
  ) => FontSettingsNullablePromise;
  fontSettingses: (args?: {
    where?: FontSettingsWhereInput;
    orderBy?: FontSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FontSettings>;
  fontSettingsesConnection: (args?: {
    where?: FontSettingsWhereInput;
    orderBy?: FontSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FontSettingsConnectionPromise;
  leafNode: (where: LeafNodeWhereUniqueInput) => LeafNodeNullablePromise;
  leafNodes: (args?: {
    where?: LeafNodeWhereInput;
    orderBy?: LeafNodeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LeafNode>;
  leafNodesConnection: (args?: {
    where?: LeafNodeWhereInput;
    orderBy?: LeafNodeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LeafNodeConnectionPromise;
  qQuestion: (where: QQuestionWhereUniqueInput) => QQuestionNullablePromise;
  qQuestions: (args?: {
    where?: QQuestionWhereInput;
    orderBy?: QQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QQuestion>;
  qQuestionsConnection: (args?: {
    where?: QQuestionWhereInput;
    orderBy?: QQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QQuestionConnectionPromise;
  questionCondition: (
    where: QuestionConditionWhereUniqueInput
  ) => QuestionConditionNullablePromise;
  questionConditions: (args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QuestionCondition>;
  questionConditionsConnection: (args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionConditionConnectionPromise;
  questionOption: (
    where: QuestionOptionWhereUniqueInput
  ) => QuestionOptionNullablePromise;
  questionOptions: (args?: {
    where?: QuestionOptionWhereInput;
    orderBy?: QuestionOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QuestionOption>;
  questionOptionsConnection: (args?: {
    where?: QuestionOptionWhereInput;
    orderBy?: QuestionOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionOptionConnectionPromise;
  questionnaire: (
    where: QuestionnaireWhereUniqueInput
  ) => QuestionnaireNullablePromise;
  questionnaires: (args?: {
    where?: QuestionnaireWhereInput;
    orderBy?: QuestionnaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Questionnaire>;
  questionnairesConnection: (args?: {
    where?: QuestionnaireWhereInput;
    orderBy?: QuestionnaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionnaireConnectionPromise;
  questionnaireSettings: (
    where: QuestionnaireSettingsWhereUniqueInput
  ) => QuestionnaireSettingsNullablePromise;
  questionnaireSettingses: (args?: {
    where?: QuestionnaireSettingsWhereInput;
    orderBy?: QuestionnaireSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<QuestionnaireSettings>;
  questionnaireSettingsesConnection: (args?: {
    where?: QuestionnaireSettingsWhereInput;
    orderBy?: QuestionnaireSettingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionnaireSettingsConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createColourSettings: (
    data: ColourSettingsCreateInput
  ) => ColourSettingsPromise;
  updateColourSettings: (args: {
    data: ColourSettingsUpdateInput;
    where: ColourSettingsWhereUniqueInput;
  }) => ColourSettingsPromise;
  updateManyColourSettingses: (args: {
    data: ColourSettingsUpdateManyMutationInput;
    where?: ColourSettingsWhereInput;
  }) => BatchPayloadPromise;
  upsertColourSettings: (args: {
    where: ColourSettingsWhereUniqueInput;
    create: ColourSettingsCreateInput;
    update: ColourSettingsUpdateInput;
  }) => ColourSettingsPromise;
  deleteColourSettings: (
    where: ColourSettingsWhereUniqueInput
  ) => ColourSettingsPromise;
  deleteManyColourSettingses: (
    where?: ColourSettingsWhereInput
  ) => BatchPayloadPromise;
  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (args: {
    data: CustomerUpdateInput;
    where: CustomerWhereUniqueInput;
  }) => CustomerPromise;
  updateManyCustomers: (args: {
    data: CustomerUpdateManyMutationInput;
    where?: CustomerWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomer: (args: {
    where: CustomerWhereUniqueInput;
    create: CustomerCreateInput;
    update: CustomerUpdateInput;
  }) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createFontSettings: (data: FontSettingsCreateInput) => FontSettingsPromise;
  updateFontSettings: (args: {
    data: FontSettingsUpdateInput;
    where: FontSettingsWhereUniqueInput;
  }) => FontSettingsPromise;
  updateManyFontSettingses: (args: {
    data: FontSettingsUpdateManyMutationInput;
    where?: FontSettingsWhereInput;
  }) => BatchPayloadPromise;
  upsertFontSettings: (args: {
    where: FontSettingsWhereUniqueInput;
    create: FontSettingsCreateInput;
    update: FontSettingsUpdateInput;
  }) => FontSettingsPromise;
  deleteFontSettings: (
    where: FontSettingsWhereUniqueInput
  ) => FontSettingsPromise;
  deleteManyFontSettingses: (
    where?: FontSettingsWhereInput
  ) => BatchPayloadPromise;
  createLeafNode: (data: LeafNodeCreateInput) => LeafNodePromise;
  updateLeafNode: (args: {
    data: LeafNodeUpdateInput;
    where: LeafNodeWhereUniqueInput;
  }) => LeafNodePromise;
  updateManyLeafNodes: (args: {
    data: LeafNodeUpdateManyMutationInput;
    where?: LeafNodeWhereInput;
  }) => BatchPayloadPromise;
  upsertLeafNode: (args: {
    where: LeafNodeWhereUniqueInput;
    create: LeafNodeCreateInput;
    update: LeafNodeUpdateInput;
  }) => LeafNodePromise;
  deleteLeafNode: (where: LeafNodeWhereUniqueInput) => LeafNodePromise;
  deleteManyLeafNodes: (where?: LeafNodeWhereInput) => BatchPayloadPromise;
  createQQuestion: (data: QQuestionCreateInput) => QQuestionPromise;
  updateQQuestion: (args: {
    data: QQuestionUpdateInput;
    where: QQuestionWhereUniqueInput;
  }) => QQuestionPromise;
  updateManyQQuestions: (args: {
    data: QQuestionUpdateManyMutationInput;
    where?: QQuestionWhereInput;
  }) => BatchPayloadPromise;
  upsertQQuestion: (args: {
    where: QQuestionWhereUniqueInput;
    create: QQuestionCreateInput;
    update: QQuestionUpdateInput;
  }) => QQuestionPromise;
  deleteQQuestion: (where: QQuestionWhereUniqueInput) => QQuestionPromise;
  deleteManyQQuestions: (where?: QQuestionWhereInput) => BatchPayloadPromise;
  createQuestionCondition: (
    data: QuestionConditionCreateInput
  ) => QuestionConditionPromise;
  updateQuestionCondition: (args: {
    data: QuestionConditionUpdateInput;
    where: QuestionConditionWhereUniqueInput;
  }) => QuestionConditionPromise;
  updateManyQuestionConditions: (args: {
    data: QuestionConditionUpdateManyMutationInput;
    where?: QuestionConditionWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestionCondition: (args: {
    where: QuestionConditionWhereUniqueInput;
    create: QuestionConditionCreateInput;
    update: QuestionConditionUpdateInput;
  }) => QuestionConditionPromise;
  deleteQuestionCondition: (
    where: QuestionConditionWhereUniqueInput
  ) => QuestionConditionPromise;
  deleteManyQuestionConditions: (
    where?: QuestionConditionWhereInput
  ) => BatchPayloadPromise;
  createQuestionOption: (
    data: QuestionOptionCreateInput
  ) => QuestionOptionPromise;
  updateQuestionOption: (args: {
    data: QuestionOptionUpdateInput;
    where: QuestionOptionWhereUniqueInput;
  }) => QuestionOptionPromise;
  updateManyQuestionOptions: (args: {
    data: QuestionOptionUpdateManyMutationInput;
    where?: QuestionOptionWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestionOption: (args: {
    where: QuestionOptionWhereUniqueInput;
    create: QuestionOptionCreateInput;
    update: QuestionOptionUpdateInput;
  }) => QuestionOptionPromise;
  deleteQuestionOption: (
    where: QuestionOptionWhereUniqueInput
  ) => QuestionOptionPromise;
  deleteManyQuestionOptions: (
    where?: QuestionOptionWhereInput
  ) => BatchPayloadPromise;
  createQuestionnaire: (data: QuestionnaireCreateInput) => QuestionnairePromise;
  updateQuestionnaire: (args: {
    data: QuestionnaireUpdateInput;
    where: QuestionnaireWhereUniqueInput;
  }) => QuestionnairePromise;
  updateManyQuestionnaires: (args: {
    data: QuestionnaireUpdateManyMutationInput;
    where?: QuestionnaireWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestionnaire: (args: {
    where: QuestionnaireWhereUniqueInput;
    create: QuestionnaireCreateInput;
    update: QuestionnaireUpdateInput;
  }) => QuestionnairePromise;
  deleteQuestionnaire: (
    where: QuestionnaireWhereUniqueInput
  ) => QuestionnairePromise;
  deleteManyQuestionnaires: (
    where?: QuestionnaireWhereInput
  ) => BatchPayloadPromise;
  createQuestionnaireSettings: (
    data: QuestionnaireSettingsCreateInput
  ) => QuestionnaireSettingsPromise;
  updateQuestionnaireSettings: (args: {
    data: QuestionnaireSettingsUpdateInput;
    where: QuestionnaireSettingsWhereUniqueInput;
  }) => QuestionnaireSettingsPromise;
  updateManyQuestionnaireSettingses: (args: {
    data: QuestionnaireSettingsUpdateManyMutationInput;
    where?: QuestionnaireSettingsWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestionnaireSettings: (args: {
    where: QuestionnaireSettingsWhereUniqueInput;
    create: QuestionnaireSettingsCreateInput;
    update: QuestionnaireSettingsUpdateInput;
  }) => QuestionnaireSettingsPromise;
  deleteQuestionnaireSettings: (
    where: QuestionnaireSettingsWhereUniqueInput
  ) => QuestionnaireSettingsPromise;
  deleteManyQuestionnaireSettingses: (
    where?: QuestionnaireSettingsWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  colourSettings: (
    where?: ColourSettingsSubscriptionWhereInput
  ) => ColourSettingsSubscriptionPayloadSubscription;
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  fontSettings: (
    where?: FontSettingsSubscriptionWhereInput
  ) => FontSettingsSubscriptionPayloadSubscription;
  leafNode: (
    where?: LeafNodeSubscriptionWhereInput
  ) => LeafNodeSubscriptionPayloadSubscription;
  qQuestion: (
    where?: QQuestionSubscriptionWhereInput
  ) => QQuestionSubscriptionPayloadSubscription;
  questionCondition: (
    where?: QuestionConditionSubscriptionWhereInput
  ) => QuestionConditionSubscriptionPayloadSubscription;
  questionOption: (
    where?: QuestionOptionSubscriptionWhereInput
  ) => QuestionOptionSubscriptionPayloadSubscription;
  questionnaire: (
    where?: QuestionnaireSubscriptionWhereInput
  ) => QuestionnaireSubscriptionPayloadSubscription;
  questionnaireSettings: (
    where?: QuestionnaireSettingsSubscriptionWhereInput
  ) => QuestionnaireSettingsSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type FontSettingsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "settingTitle_ASC"
  | "settingTitle_DESC"
  | "body_ASC"
  | "body_DESC"
  | "fontTitle_ASC"
  | "fontTitle_DESC"
  | "special_ASC"
  | "special_DESC";

export type QuestionnaireOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "publicTitle_ASC"
  | "publicTitle_DESC"
  | "creationDate_ASC"
  | "creationDate_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type QQuestionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "branchVal_ASC"
  | "branchVal_DESC"
  | "questionType_ASC"
  | "questionType_DESC"
  | "overrideLeafId_ASC"
  | "overrideLeafId_DESC";

export type QuestionConditionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "conditionType_ASC"
  | "conditionType_DESC"
  | "renderMin_ASC"
  | "renderMin_DESC"
  | "renderMax_ASC"
  | "renderMax_DESC"
  | "matchValue_ASC"
  | "matchValue_DESC";

export type QuestionOptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC"
  | "publicValue_ASC"
  | "publicValue_DESC";

export type CustomerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ColourSettingsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "primary_ASC"
  | "primary_DESC"
  | "secondary_ASC"
  | "secondary_DESC"
  | "tertiary_ASC"
  | "tertiary_DESC"
  | "success_ASC"
  | "success_DESC"
  | "warning_ASC"
  | "warning_DESC"
  | "error_ASC"
  | "error_DESC"
  | "lightest_ASC"
  | "lightest_DESC"
  | "light_ASC"
  | "light_DESC"
  | "normal_ASC"
  | "normal_DESC"
  | "dark_ASC"
  | "dark_DESC"
  | "darkest_ASC"
  | "darkest_DESC"
  | "muted_ASC"
  | "muted_DESC"
  | "text_ASC"
  | "text_DESC";

export type LeafNodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "nodeId_ASC"
  | "nodeId_DESC"
  | "type_ASC"
  | "type_DESC"
  | "title_ASC"
  | "title_DESC";

export type QuestionnaireSettingsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "logo_ASC"
  | "logo_DESC";

export interface QuestionnaireUpdateWithoutCustomerDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  publicTitle?: Maybe<String>;
  setting?: Maybe<
    QuestionnaireSettingsUpdateOneRequiredWithoutQuestionnaireInput
  >;
  questions?: Maybe<QQuestionUpdateManyInput>;
}

export type ColourSettingsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ColourSettingsUpdateOneRequiredInput {
  create?: Maybe<ColourSettingsCreateInput>;
  update?: Maybe<ColourSettingsUpdateDataInput>;
  upsert?: Maybe<ColourSettingsUpsertNestedInput>;
  connect?: Maybe<ColourSettingsWhereUniqueInput>;
}

export type CustomerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ColourSettingsUpdateDataInput {
  title?: Maybe<String>;
  primary?: Maybe<String>;
  secondary?: Maybe<String>;
  tertiary?: Maybe<String>;
  success?: Maybe<String>;
  warning?: Maybe<String>;
  error?: Maybe<String>;
  lightest?: Maybe<String>;
  light?: Maybe<String>;
  normal?: Maybe<String>;
  dark?: Maybe<String>;
  darkest?: Maybe<String>;
  muted?: Maybe<String>;
  text?: Maybe<String>;
}

export interface QuestionnaireWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  customer?: Maybe<CustomerWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  publicTitle?: Maybe<String>;
  publicTitle_not?: Maybe<String>;
  publicTitle_in?: Maybe<String[] | String>;
  publicTitle_not_in?: Maybe<String[] | String>;
  publicTitle_lt?: Maybe<String>;
  publicTitle_lte?: Maybe<String>;
  publicTitle_gt?: Maybe<String>;
  publicTitle_gte?: Maybe<String>;
  publicTitle_contains?: Maybe<String>;
  publicTitle_not_contains?: Maybe<String>;
  publicTitle_starts_with?: Maybe<String>;
  publicTitle_not_starts_with?: Maybe<String>;
  publicTitle_ends_with?: Maybe<String>;
  publicTitle_not_ends_with?: Maybe<String>;
  setting?: Maybe<QuestionnaireSettingsWhereInput>;
  creationDate?: Maybe<DateTimeInput>;
  creationDate_not?: Maybe<DateTimeInput>;
  creationDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  creationDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  creationDate_lt?: Maybe<DateTimeInput>;
  creationDate_lte?: Maybe<DateTimeInput>;
  creationDate_gt?: Maybe<DateTimeInput>;
  creationDate_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  questions_every?: Maybe<QQuestionWhereInput>;
  questions_some?: Maybe<QQuestionWhereInput>;
  questions_none?: Maybe<QQuestionWhereInput>;
  AND?: Maybe<QuestionnaireWhereInput[] | QuestionnaireWhereInput>;
  OR?: Maybe<QuestionnaireWhereInput[] | QuestionnaireWhereInput>;
  NOT?: Maybe<QuestionnaireWhereInput[] | QuestionnaireWhereInput>;
}

export interface ColourSettingsUpsertNestedInput {
  update: ColourSettingsUpdateDataInput;
  create: ColourSettingsCreateInput;
}

export interface QuestionnaireSettingsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  customer?: Maybe<CustomerWhereInput>;
  questionnaire?: Maybe<QuestionnaireWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  logo?: Maybe<String>;
  logo_not?: Maybe<String>;
  logo_in?: Maybe<String[] | String>;
  logo_not_in?: Maybe<String[] | String>;
  logo_lt?: Maybe<String>;
  logo_lte?: Maybe<String>;
  logo_gt?: Maybe<String>;
  logo_gte?: Maybe<String>;
  logo_contains?: Maybe<String>;
  logo_not_contains?: Maybe<String>;
  logo_starts_with?: Maybe<String>;
  logo_not_starts_with?: Maybe<String>;
  logo_ends_with?: Maybe<String>;
  logo_not_ends_with?: Maybe<String>;
  colourSettings?: Maybe<ColourSettingsWhereInput>;
  fontSettings?: Maybe<FontSettingsWhereInput>;
  AND?: Maybe<
    QuestionnaireSettingsWhereInput[] | QuestionnaireSettingsWhereInput
  >;
  OR?: Maybe<
    QuestionnaireSettingsWhereInput[] | QuestionnaireSettingsWhereInput
  >;
  NOT?: Maybe<
    QuestionnaireSettingsWhereInput[] | QuestionnaireSettingsWhereInput
  >;
}

export interface QuestionnaireUpsertWithWhereUniqueWithoutCustomerInput {
  where: QuestionnaireWhereUniqueInput;
  update: QuestionnaireUpdateWithoutCustomerDataInput;
  create: QuestionnaireCreateWithoutCustomerInput;
}

export interface QQuestionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  branchVal?: Maybe<String>;
  branchVal_not?: Maybe<String>;
  branchVal_in?: Maybe<String[] | String>;
  branchVal_not_in?: Maybe<String[] | String>;
  branchVal_lt?: Maybe<String>;
  branchVal_lte?: Maybe<String>;
  branchVal_gt?: Maybe<String>;
  branchVal_gte?: Maybe<String>;
  branchVal_contains?: Maybe<String>;
  branchVal_not_contains?: Maybe<String>;
  branchVal_starts_with?: Maybe<String>;
  branchVal_not_starts_with?: Maybe<String>;
  branchVal_ends_with?: Maybe<String>;
  branchVal_not_ends_with?: Maybe<String>;
  questionType?: Maybe<String>;
  questionType_not?: Maybe<String>;
  questionType_in?: Maybe<String[] | String>;
  questionType_not_in?: Maybe<String[] | String>;
  questionType_lt?: Maybe<String>;
  questionType_lte?: Maybe<String>;
  questionType_gt?: Maybe<String>;
  questionType_gte?: Maybe<String>;
  questionType_contains?: Maybe<String>;
  questionType_not_contains?: Maybe<String>;
  questionType_starts_with?: Maybe<String>;
  questionType_not_starts_with?: Maybe<String>;
  questionType_ends_with?: Maybe<String>;
  questionType_not_ends_with?: Maybe<String>;
  overrideLeafId?: Maybe<Int>;
  overrideLeafId_not?: Maybe<Int>;
  overrideLeafId_in?: Maybe<Int[] | Int>;
  overrideLeafId_not_in?: Maybe<Int[] | Int>;
  overrideLeafId_lt?: Maybe<Int>;
  overrideLeafId_lte?: Maybe<Int>;
  overrideLeafId_gt?: Maybe<Int>;
  overrideLeafId_gte?: Maybe<Int>;
  AND?: Maybe<QQuestionScalarWhereInput[] | QQuestionScalarWhereInput>;
  OR?: Maybe<QQuestionScalarWhereInput[] | QQuestionScalarWhereInput>;
  NOT?: Maybe<QQuestionScalarWhereInput[] | QQuestionScalarWhereInput>;
}

export interface CustomerCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  questionnaires?: Maybe<QuestionnaireCreateManyWithoutCustomerInput>;
}

export interface FontSettingsUpdateOneRequiredInput {
  create?: Maybe<FontSettingsCreateInput>;
  update?: Maybe<FontSettingsUpdateDataInput>;
  upsert?: Maybe<FontSettingsUpsertNestedInput>;
  connect?: Maybe<FontSettingsWhereUniqueInput>;
}

export interface QuestionnaireCreateManyWithoutCustomerInput {
  create?: Maybe<
    | QuestionnaireCreateWithoutCustomerInput[]
    | QuestionnaireCreateWithoutCustomerInput
  >;
  connect?: Maybe<
    QuestionnaireWhereUniqueInput[] | QuestionnaireWhereUniqueInput
  >;
}

export interface QuestionConditionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  conditionType?: Maybe<String>;
  conditionType_not?: Maybe<String>;
  conditionType_in?: Maybe<String[] | String>;
  conditionType_not_in?: Maybe<String[] | String>;
  conditionType_lt?: Maybe<String>;
  conditionType_lte?: Maybe<String>;
  conditionType_gt?: Maybe<String>;
  conditionType_gte?: Maybe<String>;
  conditionType_contains?: Maybe<String>;
  conditionType_not_contains?: Maybe<String>;
  conditionType_starts_with?: Maybe<String>;
  conditionType_not_starts_with?: Maybe<String>;
  conditionType_ends_with?: Maybe<String>;
  conditionType_not_ends_with?: Maybe<String>;
  renderMin?: Maybe<Int>;
  renderMin_not?: Maybe<Int>;
  renderMin_in?: Maybe<Int[] | Int>;
  renderMin_not_in?: Maybe<Int[] | Int>;
  renderMin_lt?: Maybe<Int>;
  renderMin_lte?: Maybe<Int>;
  renderMin_gt?: Maybe<Int>;
  renderMin_gte?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  renderMax_not?: Maybe<Int>;
  renderMax_in?: Maybe<Int[] | Int>;
  renderMax_not_in?: Maybe<Int[] | Int>;
  renderMax_lt?: Maybe<Int>;
  renderMax_lte?: Maybe<Int>;
  renderMax_gt?: Maybe<Int>;
  renderMax_gte?: Maybe<Int>;
  matchValue?: Maybe<String>;
  matchValue_not?: Maybe<String>;
  matchValue_in?: Maybe<String[] | String>;
  matchValue_not_in?: Maybe<String[] | String>;
  matchValue_lt?: Maybe<String>;
  matchValue_lte?: Maybe<String>;
  matchValue_gt?: Maybe<String>;
  matchValue_gte?: Maybe<String>;
  matchValue_contains?: Maybe<String>;
  matchValue_not_contains?: Maybe<String>;
  matchValue_starts_with?: Maybe<String>;
  matchValue_not_starts_with?: Maybe<String>;
  matchValue_ends_with?: Maybe<String>;
  matchValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<QuestionConditionWhereInput[] | QuestionConditionWhereInput>;
  OR?: Maybe<QuestionConditionWhereInput[] | QuestionConditionWhereInput>;
  NOT?: Maybe<QuestionConditionWhereInput[] | QuestionConditionWhereInput>;
}

export interface QuestionnaireCreateWithoutCustomerInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  publicTitle?: Maybe<String>;
  setting: QuestionnaireSettingsCreateOneWithoutQuestionnaireInput;
  questions?: Maybe<QQuestionCreateManyInput>;
}

export interface QuestionnaireSettingsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionnaireSettingsWhereInput>;
  AND?: Maybe<
    | QuestionnaireSettingsSubscriptionWhereInput[]
    | QuestionnaireSettingsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | QuestionnaireSettingsSubscriptionWhereInput[]
    | QuestionnaireSettingsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | QuestionnaireSettingsSubscriptionWhereInput[]
    | QuestionnaireSettingsSubscriptionWhereInput
  >;
}

export interface QuestionnaireSettingsCreateOneWithoutQuestionnaireInput {
  create?: Maybe<QuestionnaireSettingsCreateWithoutQuestionnaireInput>;
  connect?: Maybe<QuestionnaireSettingsWhereUniqueInput>;
}

export interface QuestionOptionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionOptionWhereInput>;
  AND?: Maybe<
    | QuestionOptionSubscriptionWhereInput[]
    | QuestionOptionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | QuestionOptionSubscriptionWhereInput[]
    | QuestionOptionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | QuestionOptionSubscriptionWhereInput[]
    | QuestionOptionSubscriptionWhereInput
  >;
}

export interface QuestionnaireSettingsCreateWithoutQuestionnaireInput {
  id?: Maybe<ID_Input>;
  customer: CustomerCreateOneInput;
  title?: Maybe<String>;
  logo?: Maybe<String>;
  colourSettings: ColourSettingsCreateOneInput;
  fontSettings: FontSettingsCreateOneInput;
}

export interface QQuestionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QQuestionWhereInput>;
  AND?: Maybe<
    QQuestionSubscriptionWhereInput[] | QQuestionSubscriptionWhereInput
  >;
  OR?: Maybe<
    QQuestionSubscriptionWhereInput[] | QQuestionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    QQuestionSubscriptionWhereInput[] | QQuestionSubscriptionWhereInput
  >;
}

export interface CustomerCreateOneInput {
  create?: Maybe<CustomerCreateInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface FontSettingsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FontSettingsWhereInput>;
  AND?: Maybe<
    FontSettingsSubscriptionWhereInput[] | FontSettingsSubscriptionWhereInput
  >;
  OR?: Maybe<
    FontSettingsSubscriptionWhereInput[] | FontSettingsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    FontSettingsSubscriptionWhereInput[] | FontSettingsSubscriptionWhereInput
  >;
}

export interface ColourSettingsCreateOneInput {
  create?: Maybe<ColourSettingsCreateInput>;
  connect?: Maybe<ColourSettingsWhereUniqueInput>;
}

export interface ColourSettingsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ColourSettingsWhereInput>;
  AND?: Maybe<
    | ColourSettingsSubscriptionWhereInput[]
    | ColourSettingsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ColourSettingsSubscriptionWhereInput[]
    | ColourSettingsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ColourSettingsSubscriptionWhereInput[]
    | ColourSettingsSubscriptionWhereInput
  >;
}

export interface FontSettingsCreateOneInput {
  create?: Maybe<FontSettingsCreateInput>;
  connect?: Maybe<FontSettingsWhereUniqueInput>;
}

export interface QuestionnaireUpsertWithoutSettingInput {
  update: QuestionnaireUpdateWithoutSettingDataInput;
  create: QuestionnaireCreateWithoutSettingInput;
}

export interface FontSettingsCreateInput {
  id?: Maybe<ID_Input>;
  settingTitle?: Maybe<String>;
  body?: Maybe<String>;
  fontTitle?: Maybe<String>;
  special?: Maybe<String>;
}

export interface QuestionnaireUpdateOneRequiredWithoutSettingInput {
  create?: Maybe<QuestionnaireCreateWithoutSettingInput>;
  update?: Maybe<QuestionnaireUpdateWithoutSettingDataInput>;
  upsert?: Maybe<QuestionnaireUpsertWithoutSettingInput>;
  connect?: Maybe<QuestionnaireWhereUniqueInput>;
}

export interface QQuestionCreateManyInput {
  create?: Maybe<QQuestionCreateInput[] | QQuestionCreateInput>;
  connect?: Maybe<QQuestionWhereUniqueInput[] | QQuestionWhereUniqueInput>;
}

export interface QuestionnaireCreateWithoutSettingInput {
  id?: Maybe<ID_Input>;
  customer: CustomerCreateOneWithoutQuestionnairesInput;
  title: String;
  description: String;
  publicTitle?: Maybe<String>;
  questions?: Maybe<QQuestionCreateManyInput>;
}

export interface QQuestionCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  branchVal?: Maybe<String>;
  questionType: String;
  overrideLeafId?: Maybe<Int>;
  leafNode?: Maybe<LeafNodeCreateOneInput>;
  conditions?: Maybe<QuestionConditionCreateManyInput>;
  options?: Maybe<QuestionOptionCreateManyInput>;
  children?: Maybe<QQuestionCreateManyInput>;
}

export interface QuestionnaireCreateOneWithoutSettingInput {
  create?: Maybe<QuestionnaireCreateWithoutSettingInput>;
  connect?: Maybe<QuestionnaireWhereUniqueInput>;
}

export interface LeafNodeCreateOneInput {
  create?: Maybe<LeafNodeCreateInput>;
  connect?: Maybe<LeafNodeWhereUniqueInput>;
}

export interface QuestionnaireUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  publicTitle?: Maybe<String>;
}

export interface LeafNodeCreateInput {
  id?: Maybe<ID_Input>;
  nodeId?: Maybe<Int>;
  type: String;
  title: String;
}

export type LeafNodeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QuestionConditionCreateManyInput {
  create?: Maybe<QuestionConditionCreateInput[] | QuestionConditionCreateInput>;
  connect?: Maybe<
    QuestionConditionWhereUniqueInput[] | QuestionConditionWhereUniqueInput
  >;
}

export interface CustomerUpdateWithoutQuestionnairesDataInput {
  name?: Maybe<String>;
}

export interface QuestionConditionCreateInput {
  id?: Maybe<ID_Input>;
  conditionType: String;
  renderMin?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  matchValue?: Maybe<String>;
}

export interface QuestionnaireUpdateInput {
  customer?: Maybe<CustomerUpdateOneRequiredWithoutQuestionnairesInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  publicTitle?: Maybe<String>;
  setting?: Maybe<
    QuestionnaireSettingsUpdateOneRequiredWithoutQuestionnaireInput
  >;
  questions?: Maybe<QQuestionUpdateManyInput>;
}

export interface QuestionOptionCreateManyInput {
  create?: Maybe<QuestionOptionCreateInput[] | QuestionOptionCreateInput>;
  connect?: Maybe<
    QuestionOptionWhereUniqueInput[] | QuestionOptionWhereUniqueInput
  >;
}

export interface CustomerCreateWithoutQuestionnairesInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface QuestionOptionCreateInput {
  id?: Maybe<ID_Input>;
  value: String;
  publicValue?: Maybe<String>;
}

export interface QuestionnaireCreateInput {
  id?: Maybe<ID_Input>;
  customer: CustomerCreateOneWithoutQuestionnairesInput;
  title: String;
  description: String;
  publicTitle?: Maybe<String>;
  setting: QuestionnaireSettingsCreateOneWithoutQuestionnaireInput;
  questions?: Maybe<QQuestionCreateManyInput>;
}

export interface CustomerUpdateInput {
  name?: Maybe<String>;
  questionnaires?: Maybe<QuestionnaireUpdateManyWithoutCustomerInput>;
}

export interface QuestionOptionUpdateManyMutationInput {
  value?: Maybe<String>;
  publicValue?: Maybe<String>;
}

export interface QuestionnaireUpdateManyWithoutCustomerInput {
  create?: Maybe<
    | QuestionnaireCreateWithoutCustomerInput[]
    | QuestionnaireCreateWithoutCustomerInput
  >;
  delete?: Maybe<
    QuestionnaireWhereUniqueInput[] | QuestionnaireWhereUniqueInput
  >;
  connect?: Maybe<
    QuestionnaireWhereUniqueInput[] | QuestionnaireWhereUniqueInput
  >;
  set?: Maybe<QuestionnaireWhereUniqueInput[] | QuestionnaireWhereUniqueInput>;
  disconnect?: Maybe<
    QuestionnaireWhereUniqueInput[] | QuestionnaireWhereUniqueInput
  >;
  update?: Maybe<
    | QuestionnaireUpdateWithWhereUniqueWithoutCustomerInput[]
    | QuestionnaireUpdateWithWhereUniqueWithoutCustomerInput
  >;
  upsert?: Maybe<
    | QuestionnaireUpsertWithWhereUniqueWithoutCustomerInput[]
    | QuestionnaireUpsertWithWhereUniqueWithoutCustomerInput
  >;
  deleteMany?: Maybe<
    QuestionnaireScalarWhereInput[] | QuestionnaireScalarWhereInput
  >;
  updateMany?: Maybe<
    | QuestionnaireUpdateManyWithWhereNestedInput[]
    | QuestionnaireUpdateManyWithWhereNestedInput
  >;
}

export interface QuestionConditionUpdateManyMutationInput {
  conditionType?: Maybe<String>;
  renderMin?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  matchValue?: Maybe<String>;
}

export interface QuestionnaireUpdateWithWhereUniqueWithoutCustomerInput {
  where: QuestionnaireWhereUniqueInput;
  data: QuestionnaireUpdateWithoutCustomerDataInput;
}

export interface QuestionConditionUpdateInput {
  conditionType?: Maybe<String>;
  renderMin?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  matchValue?: Maybe<String>;
}

export interface QQuestionUpdateManyDataInput {
  title?: Maybe<String>;
  branchVal?: Maybe<String>;
  questionType?: Maybe<String>;
  overrideLeafId?: Maybe<Int>;
}

export interface QQuestionUpdateInput {
  title?: Maybe<String>;
  branchVal?: Maybe<String>;
  questionType?: Maybe<String>;
  overrideLeafId?: Maybe<Int>;
  leafNode?: Maybe<LeafNodeUpdateOneInput>;
  conditions?: Maybe<QuestionConditionUpdateManyInput>;
  options?: Maybe<QuestionOptionUpdateManyInput>;
  children?: Maybe<QQuestionUpdateManyInput>;
}

export interface QuestionnaireSettingsUpdateOneRequiredWithoutQuestionnaireInput {
  create?: Maybe<QuestionnaireSettingsCreateWithoutQuestionnaireInput>;
  update?: Maybe<QuestionnaireSettingsUpdateWithoutQuestionnaireDataInput>;
  upsert?: Maybe<QuestionnaireSettingsUpsertWithoutQuestionnaireInput>;
  connect?: Maybe<QuestionnaireSettingsWhereUniqueInput>;
}

export interface LeafNodeUpdateManyMutationInput {
  nodeId?: Maybe<Int>;
  type?: Maybe<String>;
  title?: Maybe<String>;
}

export interface QuestionnaireSettingsUpdateWithoutQuestionnaireDataInput {
  customer?: Maybe<CustomerUpdateOneRequiredInput>;
  title?: Maybe<String>;
  logo?: Maybe<String>;
  colourSettings?: Maybe<ColourSettingsUpdateOneRequiredInput>;
  fontSettings?: Maybe<FontSettingsUpdateOneRequiredInput>;
}

export interface FontSettingsUpdateManyMutationInput {
  settingTitle?: Maybe<String>;
  body?: Maybe<String>;
  fontTitle?: Maybe<String>;
  special?: Maybe<String>;
}

export interface CustomerUpdateOneRequiredInput {
  create?: Maybe<CustomerCreateInput>;
  update?: Maybe<CustomerUpdateDataInput>;
  upsert?: Maybe<CustomerUpsertNestedInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface FontSettingsUpdateInput {
  settingTitle?: Maybe<String>;
  body?: Maybe<String>;
  fontTitle?: Maybe<String>;
  special?: Maybe<String>;
}

export interface CustomerUpdateDataInput {
  name?: Maybe<String>;
  questionnaires?: Maybe<QuestionnaireUpdateManyWithoutCustomerInput>;
}

export interface QuestionnaireUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  publicTitle?: Maybe<String>;
}

export interface CustomerUpsertNestedInput {
  update: CustomerUpdateDataInput;
  create: CustomerCreateInput;
}

export interface ColourSettingsUpdateInput {
  title?: Maybe<String>;
  primary?: Maybe<String>;
  secondary?: Maybe<String>;
  tertiary?: Maybe<String>;
  success?: Maybe<String>;
  warning?: Maybe<String>;
  error?: Maybe<String>;
  lightest?: Maybe<String>;
  light?: Maybe<String>;
  normal?: Maybe<String>;
  dark?: Maybe<String>;
  darkest?: Maybe<String>;
  muted?: Maybe<String>;
  text?: Maybe<String>;
}

export interface QQuestionUpdateManyWithWhereNestedInput {
  where: QQuestionScalarWhereInput;
  data: QQuestionUpdateManyDataInput;
}

export interface QuestionnaireScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  publicTitle?: Maybe<String>;
  publicTitle_not?: Maybe<String>;
  publicTitle_in?: Maybe<String[] | String>;
  publicTitle_not_in?: Maybe<String[] | String>;
  publicTitle_lt?: Maybe<String>;
  publicTitle_lte?: Maybe<String>;
  publicTitle_gt?: Maybe<String>;
  publicTitle_gte?: Maybe<String>;
  publicTitle_contains?: Maybe<String>;
  publicTitle_not_contains?: Maybe<String>;
  publicTitle_starts_with?: Maybe<String>;
  publicTitle_not_starts_with?: Maybe<String>;
  publicTitle_ends_with?: Maybe<String>;
  publicTitle_not_ends_with?: Maybe<String>;
  creationDate?: Maybe<DateTimeInput>;
  creationDate_not?: Maybe<DateTimeInput>;
  creationDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  creationDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  creationDate_lt?: Maybe<DateTimeInput>;
  creationDate_lte?: Maybe<DateTimeInput>;
  creationDate_gt?: Maybe<DateTimeInput>;
  creationDate_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<QuestionnaireScalarWhereInput[] | QuestionnaireScalarWhereInput>;
  OR?: Maybe<QuestionnaireScalarWhereInput[] | QuestionnaireScalarWhereInput>;
  NOT?: Maybe<QuestionnaireScalarWhereInput[] | QuestionnaireScalarWhereInput>;
}

export interface CustomerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  questionnaires_every?: Maybe<QuestionnaireWhereInput>;
  questionnaires_some?: Maybe<QuestionnaireWhereInput>;
  questionnaires_none?: Maybe<QuestionnaireWhereInput>;
  AND?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  OR?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  NOT?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
}

export interface QuestionOptionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  publicValue?: Maybe<String>;
  publicValue_not?: Maybe<String>;
  publicValue_in?: Maybe<String[] | String>;
  publicValue_not_in?: Maybe<String[] | String>;
  publicValue_lt?: Maybe<String>;
  publicValue_lte?: Maybe<String>;
  publicValue_gt?: Maybe<String>;
  publicValue_gte?: Maybe<String>;
  publicValue_contains?: Maybe<String>;
  publicValue_not_contains?: Maybe<String>;
  publicValue_starts_with?: Maybe<String>;
  publicValue_not_starts_with?: Maybe<String>;
  publicValue_ends_with?: Maybe<String>;
  publicValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<QuestionOptionWhereInput[] | QuestionOptionWhereInput>;
  OR?: Maybe<QuestionOptionWhereInput[] | QuestionOptionWhereInput>;
  NOT?: Maybe<QuestionOptionWhereInput[] | QuestionOptionWhereInput>;
}

export interface FontSettingsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  settingTitle?: Maybe<String>;
  settingTitle_not?: Maybe<String>;
  settingTitle_in?: Maybe<String[] | String>;
  settingTitle_not_in?: Maybe<String[] | String>;
  settingTitle_lt?: Maybe<String>;
  settingTitle_lte?: Maybe<String>;
  settingTitle_gt?: Maybe<String>;
  settingTitle_gte?: Maybe<String>;
  settingTitle_contains?: Maybe<String>;
  settingTitle_not_contains?: Maybe<String>;
  settingTitle_starts_with?: Maybe<String>;
  settingTitle_not_starts_with?: Maybe<String>;
  settingTitle_ends_with?: Maybe<String>;
  settingTitle_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  fontTitle?: Maybe<String>;
  fontTitle_not?: Maybe<String>;
  fontTitle_in?: Maybe<String[] | String>;
  fontTitle_not_in?: Maybe<String[] | String>;
  fontTitle_lt?: Maybe<String>;
  fontTitle_lte?: Maybe<String>;
  fontTitle_gt?: Maybe<String>;
  fontTitle_gte?: Maybe<String>;
  fontTitle_contains?: Maybe<String>;
  fontTitle_not_contains?: Maybe<String>;
  fontTitle_starts_with?: Maybe<String>;
  fontTitle_not_starts_with?: Maybe<String>;
  fontTitle_ends_with?: Maybe<String>;
  fontTitle_not_ends_with?: Maybe<String>;
  special?: Maybe<String>;
  special_not?: Maybe<String>;
  special_in?: Maybe<String[] | String>;
  special_not_in?: Maybe<String[] | String>;
  special_lt?: Maybe<String>;
  special_lte?: Maybe<String>;
  special_gt?: Maybe<String>;
  special_gte?: Maybe<String>;
  special_contains?: Maybe<String>;
  special_not_contains?: Maybe<String>;
  special_starts_with?: Maybe<String>;
  special_not_starts_with?: Maybe<String>;
  special_ends_with?: Maybe<String>;
  special_not_ends_with?: Maybe<String>;
  AND?: Maybe<FontSettingsWhereInput[] | FontSettingsWhereInput>;
  OR?: Maybe<FontSettingsWhereInput[] | FontSettingsWhereInput>;
  NOT?: Maybe<FontSettingsWhereInput[] | FontSettingsWhereInput>;
}

export interface QuestionConditionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionConditionWhereInput>;
  AND?: Maybe<
    | QuestionConditionSubscriptionWhereInput[]
    | QuestionConditionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | QuestionConditionSubscriptionWhereInput[]
    | QuestionConditionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | QuestionConditionSubscriptionWhereInput[]
    | QuestionConditionSubscriptionWhereInput
  >;
}

export interface QQuestionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  branchVal?: Maybe<String>;
  branchVal_not?: Maybe<String>;
  branchVal_in?: Maybe<String[] | String>;
  branchVal_not_in?: Maybe<String[] | String>;
  branchVal_lt?: Maybe<String>;
  branchVal_lte?: Maybe<String>;
  branchVal_gt?: Maybe<String>;
  branchVal_gte?: Maybe<String>;
  branchVal_contains?: Maybe<String>;
  branchVal_not_contains?: Maybe<String>;
  branchVal_starts_with?: Maybe<String>;
  branchVal_not_starts_with?: Maybe<String>;
  branchVal_ends_with?: Maybe<String>;
  branchVal_not_ends_with?: Maybe<String>;
  questionType?: Maybe<String>;
  questionType_not?: Maybe<String>;
  questionType_in?: Maybe<String[] | String>;
  questionType_not_in?: Maybe<String[] | String>;
  questionType_lt?: Maybe<String>;
  questionType_lte?: Maybe<String>;
  questionType_gt?: Maybe<String>;
  questionType_gte?: Maybe<String>;
  questionType_contains?: Maybe<String>;
  questionType_not_contains?: Maybe<String>;
  questionType_starts_with?: Maybe<String>;
  questionType_not_starts_with?: Maybe<String>;
  questionType_ends_with?: Maybe<String>;
  questionType_not_ends_with?: Maybe<String>;
  overrideLeafId?: Maybe<Int>;
  overrideLeafId_not?: Maybe<Int>;
  overrideLeafId_in?: Maybe<Int[] | Int>;
  overrideLeafId_not_in?: Maybe<Int[] | Int>;
  overrideLeafId_lt?: Maybe<Int>;
  overrideLeafId_lte?: Maybe<Int>;
  overrideLeafId_gt?: Maybe<Int>;
  overrideLeafId_gte?: Maybe<Int>;
  leafNode?: Maybe<LeafNodeWhereInput>;
  conditions_every?: Maybe<QuestionConditionWhereInput>;
  conditions_some?: Maybe<QuestionConditionWhereInput>;
  conditions_none?: Maybe<QuestionConditionWhereInput>;
  options_every?: Maybe<QuestionOptionWhereInput>;
  options_some?: Maybe<QuestionOptionWhereInput>;
  options_none?: Maybe<QuestionOptionWhereInput>;
  children_every?: Maybe<QQuestionWhereInput>;
  children_some?: Maybe<QQuestionWhereInput>;
  children_none?: Maybe<QQuestionWhereInput>;
  AND?: Maybe<QQuestionWhereInput[] | QQuestionWhereInput>;
  OR?: Maybe<QQuestionWhereInput[] | QQuestionWhereInput>;
  NOT?: Maybe<QQuestionWhereInput[] | QQuestionWhereInput>;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerWhereInput>;
  AND?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
  OR?: Maybe<CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput>;
  NOT?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
}

export interface FontSettingsUpdateDataInput {
  settingTitle?: Maybe<String>;
  body?: Maybe<String>;
  fontTitle?: Maybe<String>;
  special?: Maybe<String>;
}

export interface QuestionnaireUpdateWithoutSettingDataInput {
  customer?: Maybe<CustomerUpdateOneRequiredWithoutQuestionnairesInput>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  publicTitle?: Maybe<String>;
  questions?: Maybe<QQuestionUpdateManyInput>;
}

export interface FontSettingsUpsertNestedInput {
  update: FontSettingsUpdateDataInput;
  create: FontSettingsCreateInput;
}

export type FontSettingsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QuestionnaireSettingsUpsertWithoutQuestionnaireInput {
  update: QuestionnaireSettingsUpdateWithoutQuestionnaireDataInput;
  create: QuestionnaireSettingsCreateWithoutQuestionnaireInput;
}

export interface CustomerUpsertWithoutQuestionnairesInput {
  update: CustomerUpdateWithoutQuestionnairesDataInput;
  create: CustomerCreateWithoutQuestionnairesInput;
}

export interface QQuestionUpdateManyInput {
  create?: Maybe<QQuestionCreateInput[] | QQuestionCreateInput>;
  update?: Maybe<
    | QQuestionUpdateWithWhereUniqueNestedInput[]
    | QQuestionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QQuestionUpsertWithWhereUniqueNestedInput[]
    | QQuestionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<QQuestionWhereUniqueInput[] | QQuestionWhereUniqueInput>;
  connect?: Maybe<QQuestionWhereUniqueInput[] | QQuestionWhereUniqueInput>;
  set?: Maybe<QQuestionWhereUniqueInput[] | QQuestionWhereUniqueInput>;
  disconnect?: Maybe<QQuestionWhereUniqueInput[] | QQuestionWhereUniqueInput>;
  deleteMany?: Maybe<QQuestionScalarWhereInput[] | QQuestionScalarWhereInput>;
  updateMany?: Maybe<
    | QQuestionUpdateManyWithWhereNestedInput[]
    | QQuestionUpdateManyWithWhereNestedInput
  >;
}

export interface CustomerUpdateOneRequiredWithoutQuestionnairesInput {
  create?: Maybe<CustomerCreateWithoutQuestionnairesInput>;
  update?: Maybe<CustomerUpdateWithoutQuestionnairesDataInput>;
  upsert?: Maybe<CustomerUpsertWithoutQuestionnairesInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface QQuestionUpdateWithWhereUniqueNestedInput {
  where: QQuestionWhereUniqueInput;
  data: QQuestionUpdateDataInput;
}

export interface CustomerCreateOneWithoutQuestionnairesInput {
  create?: Maybe<CustomerCreateWithoutQuestionnairesInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface QQuestionUpdateDataInput {
  title?: Maybe<String>;
  branchVal?: Maybe<String>;
  questionType?: Maybe<String>;
  overrideLeafId?: Maybe<Int>;
  leafNode?: Maybe<LeafNodeUpdateOneInput>;
  conditions?: Maybe<QuestionConditionUpdateManyInput>;
  options?: Maybe<QuestionOptionUpdateManyInput>;
  children?: Maybe<QQuestionUpdateManyInput>;
}

export interface QuestionOptionUpdateInput {
  value?: Maybe<String>;
  publicValue?: Maybe<String>;
}

export interface LeafNodeUpdateOneInput {
  create?: Maybe<LeafNodeCreateInput>;
  update?: Maybe<LeafNodeUpdateDataInput>;
  upsert?: Maybe<LeafNodeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<LeafNodeWhereUniqueInput>;
}

export interface QQuestionUpdateManyMutationInput {
  title?: Maybe<String>;
  branchVal?: Maybe<String>;
  questionType?: Maybe<String>;
  overrideLeafId?: Maybe<Int>;
}

export interface LeafNodeUpdateDataInput {
  nodeId?: Maybe<Int>;
  type?: Maybe<String>;
  title?: Maybe<String>;
}

export interface LeafNodeUpdateInput {
  nodeId?: Maybe<Int>;
  type?: Maybe<String>;
  title?: Maybe<String>;
}

export interface LeafNodeUpsertNestedInput {
  update: LeafNodeUpdateDataInput;
  create: LeafNodeCreateInput;
}

export interface CustomerUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface QuestionConditionUpdateManyInput {
  create?: Maybe<QuestionConditionCreateInput[] | QuestionConditionCreateInput>;
  update?: Maybe<
    | QuestionConditionUpdateWithWhereUniqueNestedInput[]
    | QuestionConditionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QuestionConditionUpsertWithWhereUniqueNestedInput[]
    | QuestionConditionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    QuestionConditionWhereUniqueInput[] | QuestionConditionWhereUniqueInput
  >;
  connect?: Maybe<
    QuestionConditionWhereUniqueInput[] | QuestionConditionWhereUniqueInput
  >;
  set?: Maybe<
    QuestionConditionWhereUniqueInput[] | QuestionConditionWhereUniqueInput
  >;
  disconnect?: Maybe<
    QuestionConditionWhereUniqueInput[] | QuestionConditionWhereUniqueInput
  >;
  deleteMany?: Maybe<
    QuestionConditionScalarWhereInput[] | QuestionConditionScalarWhereInput
  >;
  updateMany?: Maybe<
    | QuestionConditionUpdateManyWithWhereNestedInput[]
    | QuestionConditionUpdateManyWithWhereNestedInput
  >;
}

export interface ColourSettingsCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  primary: String;
  secondary: String;
  tertiary: String;
  success: String;
  warning: String;
  error: String;
  lightest: String;
  light: String;
  normal: String;
  dark: String;
  darkest: String;
  muted: String;
  text: String;
}

export interface QuestionConditionUpdateWithWhereUniqueNestedInput {
  where: QuestionConditionWhereUniqueInput;
  data: QuestionConditionUpdateDataInput;
}

export interface LeafNodeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  nodeId?: Maybe<Int>;
  nodeId_not?: Maybe<Int>;
  nodeId_in?: Maybe<Int[] | Int>;
  nodeId_not_in?: Maybe<Int[] | Int>;
  nodeId_lt?: Maybe<Int>;
  nodeId_lte?: Maybe<Int>;
  nodeId_gt?: Maybe<Int>;
  nodeId_gte?: Maybe<Int>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<LeafNodeWhereInput[] | LeafNodeWhereInput>;
  OR?: Maybe<LeafNodeWhereInput[] | LeafNodeWhereInput>;
  NOT?: Maybe<LeafNodeWhereInput[] | LeafNodeWhereInput>;
}

export interface QuestionConditionUpdateDataInput {
  conditionType?: Maybe<String>;
  renderMin?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  matchValue?: Maybe<String>;
}

export interface LeafNodeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LeafNodeWhereInput>;
  AND?: Maybe<
    LeafNodeSubscriptionWhereInput[] | LeafNodeSubscriptionWhereInput
  >;
  OR?: Maybe<LeafNodeSubscriptionWhereInput[] | LeafNodeSubscriptionWhereInput>;
  NOT?: Maybe<
    LeafNodeSubscriptionWhereInput[] | LeafNodeSubscriptionWhereInput
  >;
}

export interface QuestionConditionUpsertWithWhereUniqueNestedInput {
  where: QuestionConditionWhereUniqueInput;
  update: QuestionConditionUpdateDataInput;
  create: QuestionConditionCreateInput;
}

export interface QuestionnaireSettingsUpdateInput {
  customer?: Maybe<CustomerUpdateOneRequiredInput>;
  questionnaire?: Maybe<QuestionnaireUpdateOneRequiredWithoutSettingInput>;
  title?: Maybe<String>;
  logo?: Maybe<String>;
  colourSettings?: Maybe<ColourSettingsUpdateOneRequiredInput>;
  fontSettings?: Maybe<FontSettingsUpdateOneRequiredInput>;
}

export interface QuestionConditionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  conditionType?: Maybe<String>;
  conditionType_not?: Maybe<String>;
  conditionType_in?: Maybe<String[] | String>;
  conditionType_not_in?: Maybe<String[] | String>;
  conditionType_lt?: Maybe<String>;
  conditionType_lte?: Maybe<String>;
  conditionType_gt?: Maybe<String>;
  conditionType_gte?: Maybe<String>;
  conditionType_contains?: Maybe<String>;
  conditionType_not_contains?: Maybe<String>;
  conditionType_starts_with?: Maybe<String>;
  conditionType_not_starts_with?: Maybe<String>;
  conditionType_ends_with?: Maybe<String>;
  conditionType_not_ends_with?: Maybe<String>;
  renderMin?: Maybe<Int>;
  renderMin_not?: Maybe<Int>;
  renderMin_in?: Maybe<Int[] | Int>;
  renderMin_not_in?: Maybe<Int[] | Int>;
  renderMin_lt?: Maybe<Int>;
  renderMin_lte?: Maybe<Int>;
  renderMin_gt?: Maybe<Int>;
  renderMin_gte?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  renderMax_not?: Maybe<Int>;
  renderMax_in?: Maybe<Int[] | Int>;
  renderMax_not_in?: Maybe<Int[] | Int>;
  renderMax_lt?: Maybe<Int>;
  renderMax_lte?: Maybe<Int>;
  renderMax_gt?: Maybe<Int>;
  renderMax_gte?: Maybe<Int>;
  matchValue?: Maybe<String>;
  matchValue_not?: Maybe<String>;
  matchValue_in?: Maybe<String[] | String>;
  matchValue_not_in?: Maybe<String[] | String>;
  matchValue_lt?: Maybe<String>;
  matchValue_lte?: Maybe<String>;
  matchValue_gt?: Maybe<String>;
  matchValue_gte?: Maybe<String>;
  matchValue_contains?: Maybe<String>;
  matchValue_not_contains?: Maybe<String>;
  matchValue_starts_with?: Maybe<String>;
  matchValue_not_starts_with?: Maybe<String>;
  matchValue_ends_with?: Maybe<String>;
  matchValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    QuestionConditionScalarWhereInput[] | QuestionConditionScalarWhereInput
  >;
  OR?: Maybe<
    QuestionConditionScalarWhereInput[] | QuestionConditionScalarWhereInput
  >;
  NOT?: Maybe<
    QuestionConditionScalarWhereInput[] | QuestionConditionScalarWhereInput
  >;
}

export interface ColourSettingsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  primary?: Maybe<String>;
  primary_not?: Maybe<String>;
  primary_in?: Maybe<String[] | String>;
  primary_not_in?: Maybe<String[] | String>;
  primary_lt?: Maybe<String>;
  primary_lte?: Maybe<String>;
  primary_gt?: Maybe<String>;
  primary_gte?: Maybe<String>;
  primary_contains?: Maybe<String>;
  primary_not_contains?: Maybe<String>;
  primary_starts_with?: Maybe<String>;
  primary_not_starts_with?: Maybe<String>;
  primary_ends_with?: Maybe<String>;
  primary_not_ends_with?: Maybe<String>;
  secondary?: Maybe<String>;
  secondary_not?: Maybe<String>;
  secondary_in?: Maybe<String[] | String>;
  secondary_not_in?: Maybe<String[] | String>;
  secondary_lt?: Maybe<String>;
  secondary_lte?: Maybe<String>;
  secondary_gt?: Maybe<String>;
  secondary_gte?: Maybe<String>;
  secondary_contains?: Maybe<String>;
  secondary_not_contains?: Maybe<String>;
  secondary_starts_with?: Maybe<String>;
  secondary_not_starts_with?: Maybe<String>;
  secondary_ends_with?: Maybe<String>;
  secondary_not_ends_with?: Maybe<String>;
  tertiary?: Maybe<String>;
  tertiary_not?: Maybe<String>;
  tertiary_in?: Maybe<String[] | String>;
  tertiary_not_in?: Maybe<String[] | String>;
  tertiary_lt?: Maybe<String>;
  tertiary_lte?: Maybe<String>;
  tertiary_gt?: Maybe<String>;
  tertiary_gte?: Maybe<String>;
  tertiary_contains?: Maybe<String>;
  tertiary_not_contains?: Maybe<String>;
  tertiary_starts_with?: Maybe<String>;
  tertiary_not_starts_with?: Maybe<String>;
  tertiary_ends_with?: Maybe<String>;
  tertiary_not_ends_with?: Maybe<String>;
  success?: Maybe<String>;
  success_not?: Maybe<String>;
  success_in?: Maybe<String[] | String>;
  success_not_in?: Maybe<String[] | String>;
  success_lt?: Maybe<String>;
  success_lte?: Maybe<String>;
  success_gt?: Maybe<String>;
  success_gte?: Maybe<String>;
  success_contains?: Maybe<String>;
  success_not_contains?: Maybe<String>;
  success_starts_with?: Maybe<String>;
  success_not_starts_with?: Maybe<String>;
  success_ends_with?: Maybe<String>;
  success_not_ends_with?: Maybe<String>;
  warning?: Maybe<String>;
  warning_not?: Maybe<String>;
  warning_in?: Maybe<String[] | String>;
  warning_not_in?: Maybe<String[] | String>;
  warning_lt?: Maybe<String>;
  warning_lte?: Maybe<String>;
  warning_gt?: Maybe<String>;
  warning_gte?: Maybe<String>;
  warning_contains?: Maybe<String>;
  warning_not_contains?: Maybe<String>;
  warning_starts_with?: Maybe<String>;
  warning_not_starts_with?: Maybe<String>;
  warning_ends_with?: Maybe<String>;
  warning_not_ends_with?: Maybe<String>;
  error?: Maybe<String>;
  error_not?: Maybe<String>;
  error_in?: Maybe<String[] | String>;
  error_not_in?: Maybe<String[] | String>;
  error_lt?: Maybe<String>;
  error_lte?: Maybe<String>;
  error_gt?: Maybe<String>;
  error_gte?: Maybe<String>;
  error_contains?: Maybe<String>;
  error_not_contains?: Maybe<String>;
  error_starts_with?: Maybe<String>;
  error_not_starts_with?: Maybe<String>;
  error_ends_with?: Maybe<String>;
  error_not_ends_with?: Maybe<String>;
  lightest?: Maybe<String>;
  lightest_not?: Maybe<String>;
  lightest_in?: Maybe<String[] | String>;
  lightest_not_in?: Maybe<String[] | String>;
  lightest_lt?: Maybe<String>;
  lightest_lte?: Maybe<String>;
  lightest_gt?: Maybe<String>;
  lightest_gte?: Maybe<String>;
  lightest_contains?: Maybe<String>;
  lightest_not_contains?: Maybe<String>;
  lightest_starts_with?: Maybe<String>;
  lightest_not_starts_with?: Maybe<String>;
  lightest_ends_with?: Maybe<String>;
  lightest_not_ends_with?: Maybe<String>;
  light?: Maybe<String>;
  light_not?: Maybe<String>;
  light_in?: Maybe<String[] | String>;
  light_not_in?: Maybe<String[] | String>;
  light_lt?: Maybe<String>;
  light_lte?: Maybe<String>;
  light_gt?: Maybe<String>;
  light_gte?: Maybe<String>;
  light_contains?: Maybe<String>;
  light_not_contains?: Maybe<String>;
  light_starts_with?: Maybe<String>;
  light_not_starts_with?: Maybe<String>;
  light_ends_with?: Maybe<String>;
  light_not_ends_with?: Maybe<String>;
  normal?: Maybe<String>;
  normal_not?: Maybe<String>;
  normal_in?: Maybe<String[] | String>;
  normal_not_in?: Maybe<String[] | String>;
  normal_lt?: Maybe<String>;
  normal_lte?: Maybe<String>;
  normal_gt?: Maybe<String>;
  normal_gte?: Maybe<String>;
  normal_contains?: Maybe<String>;
  normal_not_contains?: Maybe<String>;
  normal_starts_with?: Maybe<String>;
  normal_not_starts_with?: Maybe<String>;
  normal_ends_with?: Maybe<String>;
  normal_not_ends_with?: Maybe<String>;
  dark?: Maybe<String>;
  dark_not?: Maybe<String>;
  dark_in?: Maybe<String[] | String>;
  dark_not_in?: Maybe<String[] | String>;
  dark_lt?: Maybe<String>;
  dark_lte?: Maybe<String>;
  dark_gt?: Maybe<String>;
  dark_gte?: Maybe<String>;
  dark_contains?: Maybe<String>;
  dark_not_contains?: Maybe<String>;
  dark_starts_with?: Maybe<String>;
  dark_not_starts_with?: Maybe<String>;
  dark_ends_with?: Maybe<String>;
  dark_not_ends_with?: Maybe<String>;
  darkest?: Maybe<String>;
  darkest_not?: Maybe<String>;
  darkest_in?: Maybe<String[] | String>;
  darkest_not_in?: Maybe<String[] | String>;
  darkest_lt?: Maybe<String>;
  darkest_lte?: Maybe<String>;
  darkest_gt?: Maybe<String>;
  darkest_gte?: Maybe<String>;
  darkest_contains?: Maybe<String>;
  darkest_not_contains?: Maybe<String>;
  darkest_starts_with?: Maybe<String>;
  darkest_not_starts_with?: Maybe<String>;
  darkest_ends_with?: Maybe<String>;
  darkest_not_ends_with?: Maybe<String>;
  muted?: Maybe<String>;
  muted_not?: Maybe<String>;
  muted_in?: Maybe<String[] | String>;
  muted_not_in?: Maybe<String[] | String>;
  muted_lt?: Maybe<String>;
  muted_lte?: Maybe<String>;
  muted_gt?: Maybe<String>;
  muted_gte?: Maybe<String>;
  muted_contains?: Maybe<String>;
  muted_not_contains?: Maybe<String>;
  muted_starts_with?: Maybe<String>;
  muted_not_starts_with?: Maybe<String>;
  muted_ends_with?: Maybe<String>;
  muted_not_ends_with?: Maybe<String>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  AND?: Maybe<ColourSettingsWhereInput[] | ColourSettingsWhereInput>;
  OR?: Maybe<ColourSettingsWhereInput[] | ColourSettingsWhereInput>;
  NOT?: Maybe<ColourSettingsWhereInput[] | ColourSettingsWhereInput>;
}

export interface QuestionConditionUpdateManyWithWhereNestedInput {
  where: QuestionConditionScalarWhereInput;
  data: QuestionConditionUpdateManyDataInput;
}

export type QuestionConditionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QuestionConditionUpdateManyDataInput {
  conditionType?: Maybe<String>;
  renderMin?: Maybe<Int>;
  renderMax?: Maybe<Int>;
  matchValue?: Maybe<String>;
}

export type QuestionnaireWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QuestionOptionUpdateManyInput {
  create?: Maybe<QuestionOptionCreateInput[] | QuestionOptionCreateInput>;
  update?: Maybe<
    | QuestionOptionUpdateWithWhereUniqueNestedInput[]
    | QuestionOptionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QuestionOptionUpsertWithWhereUniqueNestedInput[]
    | QuestionOptionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    QuestionOptionWhereUniqueInput[] | QuestionOptionWhereUniqueInput
  >;
  connect?: Maybe<
    QuestionOptionWhereUniqueInput[] | QuestionOptionWhereUniqueInput
  >;
  set?: Maybe<
    QuestionOptionWhereUniqueInput[] | QuestionOptionWhereUniqueInput
  >;
  disconnect?: Maybe<
    QuestionOptionWhereUniqueInput[] | QuestionOptionWhereUniqueInput
  >;
  deleteMany?: Maybe<
    QuestionOptionScalarWhereInput[] | QuestionOptionScalarWhereInput
  >;
  updateMany?: Maybe<
    | QuestionOptionUpdateManyWithWhereNestedInput[]
    | QuestionOptionUpdateManyWithWhereNestedInput
  >;
}

export interface QuestionnaireUpdateManyWithWhereNestedInput {
  where: QuestionnaireScalarWhereInput;
  data: QuestionnaireUpdateManyDataInput;
}

export interface QuestionOptionUpdateWithWhereUniqueNestedInput {
  where: QuestionOptionWhereUniqueInput;
  data: QuestionOptionUpdateDataInput;
}

export interface QuestionnaireSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionnaireWhereInput>;
  AND?: Maybe<
    QuestionnaireSubscriptionWhereInput[] | QuestionnaireSubscriptionWhereInput
  >;
  OR?: Maybe<
    QuestionnaireSubscriptionWhereInput[] | QuestionnaireSubscriptionWhereInput
  >;
  NOT?: Maybe<
    QuestionnaireSubscriptionWhereInput[] | QuestionnaireSubscriptionWhereInput
  >;
}

export interface QuestionOptionUpdateDataInput {
  value?: Maybe<String>;
  publicValue?: Maybe<String>;
}

export interface QuestionnaireSettingsCreateInput {
  id?: Maybe<ID_Input>;
  customer: CustomerCreateOneInput;
  questionnaire: QuestionnaireCreateOneWithoutSettingInput;
  title?: Maybe<String>;
  logo?: Maybe<String>;
  colourSettings: ColourSettingsCreateOneInput;
  fontSettings: FontSettingsCreateOneInput;
}

export interface QuestionOptionUpsertWithWhereUniqueNestedInput {
  where: QuestionOptionWhereUniqueInput;
  update: QuestionOptionUpdateDataInput;
  create: QuestionOptionCreateInput;
}

export type QuestionOptionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QQuestionUpsertWithWhereUniqueNestedInput {
  where: QQuestionWhereUniqueInput;
  update: QQuestionUpdateDataInput;
  create: QQuestionCreateInput;
}

export interface QuestionOptionUpdateManyDataInput {
  value?: Maybe<String>;
  publicValue?: Maybe<String>;
}

export interface QuestionOptionUpdateManyWithWhereNestedInput {
  where: QuestionOptionScalarWhereInput;
  data: QuestionOptionUpdateManyDataInput;
}

export interface QuestionOptionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  publicValue?: Maybe<String>;
  publicValue_not?: Maybe<String>;
  publicValue_in?: Maybe<String[] | String>;
  publicValue_not_in?: Maybe<String[] | String>;
  publicValue_lt?: Maybe<String>;
  publicValue_lte?: Maybe<String>;
  publicValue_gt?: Maybe<String>;
  publicValue_gte?: Maybe<String>;
  publicValue_contains?: Maybe<String>;
  publicValue_not_contains?: Maybe<String>;
  publicValue_starts_with?: Maybe<String>;
  publicValue_not_starts_with?: Maybe<String>;
  publicValue_ends_with?: Maybe<String>;
  publicValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    QuestionOptionScalarWhereInput[] | QuestionOptionScalarWhereInput
  >;
  OR?: Maybe<QuestionOptionScalarWhereInput[] | QuestionOptionScalarWhereInput>;
  NOT?: Maybe<
    QuestionOptionScalarWhereInput[] | QuestionOptionScalarWhereInput
  >;
}

export type QuestionnaireSettingsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type QQuestionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface QuestionnaireSettingsUpdateManyMutationInput {
  title?: Maybe<String>;
  logo?: Maybe<String>;
}

export interface ColourSettingsUpdateManyMutationInput {
  title?: Maybe<String>;
  primary?: Maybe<String>;
  secondary?: Maybe<String>;
  tertiary?: Maybe<String>;
  success?: Maybe<String>;
  warning?: Maybe<String>;
  error?: Maybe<String>;
  lightest?: Maybe<String>;
  light?: Maybe<String>;
  normal?: Maybe<String>;
  dark?: Maybe<String>;
  darkest?: Maybe<String>;
  muted?: Maybe<String>;
  text?: Maybe<String>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface QuestionnaireSettingsPreviousValues {
  id: ID_Output;
  title?: String;
  logo?: String;
}

export interface QuestionnaireSettingsPreviousValuesPromise
  extends Promise<QuestionnaireSettingsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  logo: () => Promise<String>;
}

export interface QuestionnaireSettingsPreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionnaireSettingsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
}

export interface ColourSettingsConnection {
  pageInfo: PageInfo;
  edges: ColourSettingsEdge[];
}

export interface ColourSettingsConnectionPromise
  extends Promise<ColourSettingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ColourSettingsEdge>>() => T;
  aggregate: <T = AggregateColourSettingsPromise>() => T;
}

export interface ColourSettingsConnectionSubscription
  extends Promise<AsyncIterator<ColourSettingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ColourSettingsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateColourSettingsSubscription>() => T;
}

export interface Customer {
  id: ID_Output;
  name: String;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  questionnaires: <T = FragmentableArray<Questionnaire>>(args?: {
    where?: QuestionnaireWhereInput;
    orderBy?: QuestionnaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  questionnaires: <
    T = Promise<AsyncIterator<QuestionnaireSubscription>>
  >(args?: {
    where?: QuestionnaireWhereInput;
    orderBy?: QuestionnaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CustomerNullablePromise
  extends Promise<Customer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  questionnaires: <T = FragmentableArray<Questionnaire>>(args?: {
    where?: QuestionnaireWhereInput;
    orderBy?: QuestionnaireOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface Questionnaire {
  id: ID_Output;
  title: String;
  description: String;
  publicTitle?: String;
  creationDate: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface QuestionnairePromise
  extends Promise<Questionnaire>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
  publicTitle: () => Promise<String>;
  setting: <T = QuestionnaireSettingsPromise>() => T;
  creationDate: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  questions: <T = FragmentableArray<QQuestion>>(args?: {
    where?: QQuestionWhereInput;
    orderBy?: QQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuestionnaireSubscription
  extends Promise<AsyncIterator<Questionnaire>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customer: <T = CustomerSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  publicTitle: () => Promise<AsyncIterator<String>>;
  setting: <T = QuestionnaireSettingsSubscription>() => T;
  creationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  questions: <T = Promise<AsyncIterator<QQuestionSubscription>>>(args?: {
    where?: QQuestionWhereInput;
    orderBy?: QQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuestionnaireNullablePromise
  extends Promise<Questionnaire | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
  publicTitle: () => Promise<String>;
  setting: <T = QuestionnaireSettingsPromise>() => T;
  creationDate: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  questions: <T = FragmentableArray<QQuestion>>(args?: {
    where?: QQuestionWhereInput;
    orderBy?: QQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuestionnairePreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  publicTitle?: String;
  creationDate: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface QuestionnairePreviousValuesPromise
  extends Promise<QuestionnairePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  publicTitle: () => Promise<String>;
  creationDate: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface QuestionnairePreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionnairePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  publicTitle: () => Promise<AsyncIterator<String>>;
  creationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface QuestionOption {
  id: ID_Output;
  value: String;
  publicValue?: String;
}

export interface QuestionOptionPromise
  extends Promise<QuestionOption>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  publicValue: () => Promise<String>;
}

export interface QuestionOptionSubscription
  extends Promise<AsyncIterator<QuestionOption>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  publicValue: () => Promise<AsyncIterator<String>>;
}

export interface QuestionOptionNullablePromise
  extends Promise<QuestionOption | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  publicValue: () => Promise<String>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface QuestionnaireSettingsEdge {
  node: QuestionnaireSettings;
  cursor: String;
}

export interface QuestionnaireSettingsEdgePromise
  extends Promise<QuestionnaireSettingsEdge>,
    Fragmentable {
  node: <T = QuestionnaireSettingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionnaireSettingsEdgeSubscription
  extends Promise<AsyncIterator<QuestionnaireSettingsEdge>>,
    Fragmentable {
  node: <T = QuestionnaireSettingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface QuestionnaireSettingsSubscriptionPayload {
  mutation: MutationType;
  node: QuestionnaireSettings;
  updatedFields: String[];
  previousValues: QuestionnaireSettingsPreviousValues;
}

export interface QuestionnaireSettingsSubscriptionPayloadPromise
  extends Promise<QuestionnaireSettingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionnaireSettingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionnaireSettingsPreviousValuesPromise>() => T;
}

export interface QuestionnaireSettingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionnaireSettingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionnaireSettingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionnaireSettingsPreviousValuesSubscription>() => T;
}

export interface QuestionCondition {
  id: ID_Output;
  conditionType: String;
  renderMin?: Int;
  renderMax?: Int;
  matchValue?: String;
}

export interface QuestionConditionPromise
  extends Promise<QuestionCondition>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  conditionType: () => Promise<String>;
  renderMin: () => Promise<Int>;
  renderMax: () => Promise<Int>;
  matchValue: () => Promise<String>;
}

export interface QuestionConditionSubscription
  extends Promise<AsyncIterator<QuestionCondition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  conditionType: () => Promise<AsyncIterator<String>>;
  renderMin: () => Promise<AsyncIterator<Int>>;
  renderMax: () => Promise<AsyncIterator<Int>>;
  matchValue: () => Promise<AsyncIterator<String>>;
}

export interface QuestionConditionNullablePromise
  extends Promise<QuestionCondition | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  conditionType: () => Promise<String>;
  renderMin: () => Promise<Int>;
  renderMax: () => Promise<Int>;
  matchValue: () => Promise<String>;
}

export interface QuestionnaireEdge {
  node: Questionnaire;
  cursor: String;
}

export interface QuestionnaireEdgePromise
  extends Promise<QuestionnaireEdge>,
    Fragmentable {
  node: <T = QuestionnairePromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionnaireEdgeSubscription
  extends Promise<AsyncIterator<QuestionnaireEdge>>,
    Fragmentable {
  node: <T = QuestionnaireSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ColourSettings {
  id: ID_Output;
  title?: String;
  primary: String;
  secondary: String;
  tertiary: String;
  success: String;
  warning: String;
  error: String;
  lightest: String;
  light: String;
  normal: String;
  dark: String;
  darkest: String;
  muted: String;
  text: String;
}

export interface ColourSettingsPromise
  extends Promise<ColourSettings>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  primary: () => Promise<String>;
  secondary: () => Promise<String>;
  tertiary: () => Promise<String>;
  success: () => Promise<String>;
  warning: () => Promise<String>;
  error: () => Promise<String>;
  lightest: () => Promise<String>;
  light: () => Promise<String>;
  normal: () => Promise<String>;
  dark: () => Promise<String>;
  darkest: () => Promise<String>;
  muted: () => Promise<String>;
  text: () => Promise<String>;
}

export interface ColourSettingsSubscription
  extends Promise<AsyncIterator<ColourSettings>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  primary: () => Promise<AsyncIterator<String>>;
  secondary: () => Promise<AsyncIterator<String>>;
  tertiary: () => Promise<AsyncIterator<String>>;
  success: () => Promise<AsyncIterator<String>>;
  warning: () => Promise<AsyncIterator<String>>;
  error: () => Promise<AsyncIterator<String>>;
  lightest: () => Promise<AsyncIterator<String>>;
  light: () => Promise<AsyncIterator<String>>;
  normal: () => Promise<AsyncIterator<String>>;
  dark: () => Promise<AsyncIterator<String>>;
  darkest: () => Promise<AsyncIterator<String>>;
  muted: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface ColourSettingsNullablePromise
  extends Promise<ColourSettings | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  primary: () => Promise<String>;
  secondary: () => Promise<String>;
  tertiary: () => Promise<String>;
  success: () => Promise<String>;
  warning: () => Promise<String>;
  error: () => Promise<String>;
  lightest: () => Promise<String>;
  light: () => Promise<String>;
  normal: () => Promise<String>;
  dark: () => Promise<String>;
  darkest: () => Promise<String>;
  muted: () => Promise<String>;
  text: () => Promise<String>;
}

export interface AggregateQuestionOption {
  count: Int;
}

export interface AggregateQuestionOptionPromise
  extends Promise<AggregateQuestionOption>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionOptionSubscription
  extends Promise<AsyncIterator<AggregateQuestionOption>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ColourSettingsSubscriptionPayload {
  mutation: MutationType;
  node: ColourSettings;
  updatedFields: String[];
  previousValues: ColourSettingsPreviousValues;
}

export interface ColourSettingsSubscriptionPayloadPromise
  extends Promise<ColourSettingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ColourSettingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ColourSettingsPreviousValuesPromise>() => T;
}

export interface ColourSettingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ColourSettingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ColourSettingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ColourSettingsPreviousValuesSubscription>() => T;
}

export interface QuestionOptionConnection {
  pageInfo: PageInfo;
  edges: QuestionOptionEdge[];
}

export interface QuestionOptionConnectionPromise
  extends Promise<QuestionOptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionOptionEdge>>() => T;
  aggregate: <T = AggregateQuestionOptionPromise>() => T;
}

export interface QuestionOptionConnectionSubscription
  extends Promise<AsyncIterator<QuestionOptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionOptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionOptionSubscription>() => T;
}

export interface ColourSettingsPreviousValues {
  id: ID_Output;
  title?: String;
  primary: String;
  secondary: String;
  tertiary: String;
  success: String;
  warning: String;
  error: String;
  lightest: String;
  light: String;
  normal: String;
  dark: String;
  darkest: String;
  muted: String;
  text: String;
}

export interface ColourSettingsPreviousValuesPromise
  extends Promise<ColourSettingsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  primary: () => Promise<String>;
  secondary: () => Promise<String>;
  tertiary: () => Promise<String>;
  success: () => Promise<String>;
  warning: () => Promise<String>;
  error: () => Promise<String>;
  lightest: () => Promise<String>;
  light: () => Promise<String>;
  normal: () => Promise<String>;
  dark: () => Promise<String>;
  darkest: () => Promise<String>;
  muted: () => Promise<String>;
  text: () => Promise<String>;
}

export interface ColourSettingsPreviousValuesSubscription
  extends Promise<AsyncIterator<ColourSettingsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  primary: () => Promise<AsyncIterator<String>>;
  secondary: () => Promise<AsyncIterator<String>>;
  tertiary: () => Promise<AsyncIterator<String>>;
  success: () => Promise<AsyncIterator<String>>;
  warning: () => Promise<AsyncIterator<String>>;
  error: () => Promise<AsyncIterator<String>>;
  lightest: () => Promise<AsyncIterator<String>>;
  light: () => Promise<AsyncIterator<String>>;
  normal: () => Promise<AsyncIterator<String>>;
  dark: () => Promise<AsyncIterator<String>>;
  darkest: () => Promise<AsyncIterator<String>>;
  muted: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface QuestionConditionEdge {
  node: QuestionCondition;
  cursor: String;
}

export interface QuestionConditionEdgePromise
  extends Promise<QuestionConditionEdge>,
    Fragmentable {
  node: <T = QuestionConditionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionConditionEdgeSubscription
  extends Promise<AsyncIterator<QuestionConditionEdge>>,
    Fragmentable {
  node: <T = QuestionConditionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface QuestionnaireSubscriptionPayload {
  mutation: MutationType;
  node: Questionnaire;
  updatedFields: String[];
  previousValues: QuestionnairePreviousValues;
}

export interface QuestionnaireSubscriptionPayloadPromise
  extends Promise<QuestionnaireSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionnairePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionnairePreviousValuesPromise>() => T;
}

export interface QuestionnaireSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionnaireSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionnaireSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionnairePreviousValuesSubscription>() => T;
}

export interface AggregateQQuestion {
  count: Int;
}

export interface AggregateQQuestionPromise
  extends Promise<AggregateQQuestion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQQuestionSubscription
  extends Promise<AsyncIterator<AggregateQQuestion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface QQuestionConnection {
  pageInfo: PageInfo;
  edges: QQuestionEdge[];
}

export interface QQuestionConnectionPromise
  extends Promise<QQuestionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QQuestionEdge>>() => T;
  aggregate: <T = AggregateQQuestionPromise>() => T;
}

export interface QQuestionConnectionSubscription
  extends Promise<AsyncIterator<QQuestionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QQuestionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQQuestionSubscription>() => T;
}

export interface CustomerPreviousValues {
  id: ID_Output;
  name: String;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface LeafNodeEdge {
  node: LeafNode;
  cursor: String;
}

export interface LeafNodeEdgePromise
  extends Promise<LeafNodeEdge>,
    Fragmentable {
  node: <T = LeafNodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LeafNodeEdgeSubscription
  extends Promise<AsyncIterator<LeafNodeEdge>>,
    Fragmentable {
  node: <T = LeafNodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LeafNode {
  id: ID_Output;
  nodeId?: Int;
  type: String;
  title: String;
}

export interface LeafNodePromise extends Promise<LeafNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  nodeId: () => Promise<Int>;
  type: () => Promise<String>;
  title: () => Promise<String>;
}

export interface LeafNodeSubscription
  extends Promise<AsyncIterator<LeafNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nodeId: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface LeafNodeNullablePromise
  extends Promise<LeafNode | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nodeId: () => Promise<Int>;
  type: () => Promise<String>;
  title: () => Promise<String>;
}

export interface AggregateFontSettings {
  count: Int;
}

export interface AggregateFontSettingsPromise
  extends Promise<AggregateFontSettings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFontSettingsSubscription
  extends Promise<AsyncIterator<AggregateFontSettings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FontSettingsSubscriptionPayload {
  mutation: MutationType;
  node: FontSettings;
  updatedFields: String[];
  previousValues: FontSettingsPreviousValues;
}

export interface FontSettingsSubscriptionPayloadPromise
  extends Promise<FontSettingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FontSettingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FontSettingsPreviousValuesPromise>() => T;
}

export interface FontSettingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FontSettingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FontSettingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FontSettingsPreviousValuesSubscription>() => T;
}

export interface FontSettingsConnection {
  pageInfo: PageInfo;
  edges: FontSettingsEdge[];
}

export interface FontSettingsConnectionPromise
  extends Promise<FontSettingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FontSettingsEdge>>() => T;
  aggregate: <T = AggregateFontSettingsPromise>() => T;
}

export interface FontSettingsConnectionSubscription
  extends Promise<AsyncIterator<FontSettingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FontSettingsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFontSettingsSubscription>() => T;
}

export interface FontSettingsPreviousValues {
  id: ID_Output;
  settingTitle?: String;
  body?: String;
  fontTitle?: String;
  special?: String;
}

export interface FontSettingsPreviousValuesPromise
  extends Promise<FontSettingsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  settingTitle: () => Promise<String>;
  body: () => Promise<String>;
  fontTitle: () => Promise<String>;
  special: () => Promise<String>;
}

export interface FontSettingsPreviousValuesSubscription
  extends Promise<AsyncIterator<FontSettingsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  settingTitle: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  fontTitle: () => Promise<AsyncIterator<String>>;
  special: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QQuestion {
  id: ID_Output;
  title: String;
  branchVal?: String;
  questionType: String;
  overrideLeafId?: Int;
}

export interface QQuestionPromise extends Promise<QQuestion>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  branchVal: () => Promise<String>;
  questionType: () => Promise<String>;
  overrideLeafId: () => Promise<Int>;
  leafNode: <T = LeafNodePromise>() => T;
  conditions: <T = FragmentableArray<QuestionCondition>>(args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  options: <T = FragmentableArray<QuestionOption>>(args?: {
    where?: QuestionOptionWhereInput;
    orderBy?: QuestionOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = FragmentableArray<QQuestion>>(args?: {
    where?: QQuestionWhereInput;
    orderBy?: QQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QQuestionSubscription
  extends Promise<AsyncIterator<QQuestion>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  branchVal: () => Promise<AsyncIterator<String>>;
  questionType: () => Promise<AsyncIterator<String>>;
  overrideLeafId: () => Promise<AsyncIterator<Int>>;
  leafNode: <T = LeafNodeSubscription>() => T;
  conditions: <
    T = Promise<AsyncIterator<QuestionConditionSubscription>>
  >(args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  options: <T = Promise<AsyncIterator<QuestionOptionSubscription>>>(args?: {
    where?: QuestionOptionWhereInput;
    orderBy?: QuestionOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = Promise<AsyncIterator<QQuestionSubscription>>>(args?: {
    where?: QQuestionWhereInput;
    orderBy?: QQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QQuestionNullablePromise
  extends Promise<QQuestion | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  branchVal: () => Promise<String>;
  questionType: () => Promise<String>;
  overrideLeafId: () => Promise<Int>;
  leafNode: <T = LeafNodePromise>() => T;
  conditions: <T = FragmentableArray<QuestionCondition>>(args?: {
    where?: QuestionConditionWhereInput;
    orderBy?: QuestionConditionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  options: <T = FragmentableArray<QuestionOption>>(args?: {
    where?: QuestionOptionWhereInput;
    orderBy?: QuestionOptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  children: <T = FragmentableArray<QQuestion>>(args?: {
    where?: QQuestionWhereInput;
    orderBy?: QQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateQuestionnaireSettings {
  count: Int;
}

export interface AggregateQuestionnaireSettingsPromise
  extends Promise<AggregateQuestionnaireSettings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionnaireSettingsSubscription
  extends Promise<AsyncIterator<AggregateQuestionnaireSettings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LeafNodeSubscriptionPayload {
  mutation: MutationType;
  node: LeafNode;
  updatedFields: String[];
  previousValues: LeafNodePreviousValues;
}

export interface LeafNodeSubscriptionPayloadPromise
  extends Promise<LeafNodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LeafNodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LeafNodePreviousValuesPromise>() => T;
}

export interface LeafNodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LeafNodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LeafNodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LeafNodePreviousValuesSubscription>() => T;
}

export interface AggregateQuestionnaire {
  count: Int;
}

export interface AggregateQuestionnairePromise
  extends Promise<AggregateQuestionnaire>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionnaireSubscription
  extends Promise<AsyncIterator<AggregateQuestionnaire>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LeafNodePreviousValues {
  id: ID_Output;
  nodeId?: Int;
  type: String;
  title: String;
}

export interface LeafNodePreviousValuesPromise
  extends Promise<LeafNodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nodeId: () => Promise<Int>;
  type: () => Promise<String>;
  title: () => Promise<String>;
}

export interface LeafNodePreviousValuesSubscription
  extends Promise<AsyncIterator<LeafNodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nodeId: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface QuestionOptionEdge {
  node: QuestionOption;
  cursor: String;
}

export interface QuestionOptionEdgePromise
  extends Promise<QuestionOptionEdge>,
    Fragmentable {
  node: <T = QuestionOptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionOptionEdgeSubscription
  extends Promise<AsyncIterator<QuestionOptionEdge>>,
    Fragmentable {
  node: <T = QuestionOptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ColourSettingsEdge {
  node: ColourSettings;
  cursor: String;
}

export interface ColourSettingsEdgePromise
  extends Promise<ColourSettingsEdge>,
    Fragmentable {
  node: <T = ColourSettingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ColourSettingsEdgeSubscription
  extends Promise<AsyncIterator<ColourSettingsEdge>>,
    Fragmentable {
  node: <T = ColourSettingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface QuestionConditionConnection {
  pageInfo: PageInfo;
  edges: QuestionConditionEdge[];
}

export interface QuestionConditionConnectionPromise
  extends Promise<QuestionConditionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionConditionEdge>>() => T;
  aggregate: <T = AggregateQuestionConditionPromise>() => T;
}

export interface QuestionConditionConnectionSubscription
  extends Promise<AsyncIterator<QuestionConditionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionConditionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionConditionSubscription>() => T;
}

export interface QQuestionSubscriptionPayload {
  mutation: MutationType;
  node: QQuestion;
  updatedFields: String[];
  previousValues: QQuestionPreviousValues;
}

export interface QQuestionSubscriptionPayloadPromise
  extends Promise<QQuestionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QQuestionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QQuestionPreviousValuesPromise>() => T;
}

export interface QQuestionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QQuestionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QQuestionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QQuestionPreviousValuesSubscription>() => T;
}

export interface AggregateLeafNode {
  count: Int;
}

export interface AggregateLeafNodePromise
  extends Promise<AggregateLeafNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLeafNodeSubscription
  extends Promise<AsyncIterator<AggregateLeafNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QQuestionPreviousValues {
  id: ID_Output;
  title: String;
  branchVal?: String;
  questionType: String;
  overrideLeafId?: Int;
}

export interface QQuestionPreviousValuesPromise
  extends Promise<QQuestionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  branchVal: () => Promise<String>;
  questionType: () => Promise<String>;
  overrideLeafId: () => Promise<Int>;
}

export interface QQuestionPreviousValuesSubscription
  extends Promise<AsyncIterator<QQuestionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  branchVal: () => Promise<AsyncIterator<String>>;
  questionType: () => Promise<AsyncIterator<String>>;
  overrideLeafId: () => Promise<AsyncIterator<Int>>;
}

export interface FontSettingsEdge {
  node: FontSettings;
  cursor: String;
}

export interface FontSettingsEdgePromise
  extends Promise<FontSettingsEdge>,
    Fragmentable {
  node: <T = FontSettingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FontSettingsEdgeSubscription
  extends Promise<AsyncIterator<FontSettingsEdge>>,
    Fragmentable {
  node: <T = FontSettingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FontSettings {
  id: ID_Output;
  settingTitle?: String;
  body?: String;
  fontTitle?: String;
  special?: String;
}

export interface FontSettingsPromise
  extends Promise<FontSettings>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  settingTitle: () => Promise<String>;
  body: () => Promise<String>;
  fontTitle: () => Promise<String>;
  special: () => Promise<String>;
}

export interface FontSettingsSubscription
  extends Promise<AsyncIterator<FontSettings>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  settingTitle: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  fontTitle: () => Promise<AsyncIterator<String>>;
  special: () => Promise<AsyncIterator<String>>;
}

export interface FontSettingsNullablePromise
  extends Promise<FontSettings | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  settingTitle: () => Promise<String>;
  body: () => Promise<String>;
  fontTitle: () => Promise<String>;
  special: () => Promise<String>;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface QuestionConditionSubscriptionPayload {
  mutation: MutationType;
  node: QuestionCondition;
  updatedFields: String[];
  previousValues: QuestionConditionPreviousValues;
}

export interface QuestionConditionSubscriptionPayloadPromise
  extends Promise<QuestionConditionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionConditionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionConditionPreviousValuesPromise>() => T;
}

export interface QuestionConditionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionConditionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionConditionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionConditionPreviousValuesSubscription>() => T;
}

export interface QuestionnaireConnection {
  pageInfo: PageInfo;
  edges: QuestionnaireEdge[];
}

export interface QuestionnaireConnectionPromise
  extends Promise<QuestionnaireConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionnaireEdge>>() => T;
  aggregate: <T = AggregateQuestionnairePromise>() => T;
}

export interface QuestionnaireConnectionSubscription
  extends Promise<AsyncIterator<QuestionnaireConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionnaireEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionnaireSubscription>() => T;
}

export interface QQuestionEdge {
  node: QQuestion;
  cursor: String;
}

export interface QQuestionEdgePromise
  extends Promise<QQuestionEdge>,
    Fragmentable {
  node: <T = QQuestionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QQuestionEdgeSubscription
  extends Promise<AsyncIterator<QQuestionEdge>>,
    Fragmentable {
  node: <T = QQuestionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface QuestionOptionPreviousValues {
  id: ID_Output;
  value: String;
  publicValue?: String;
}

export interface QuestionOptionPreviousValuesPromise
  extends Promise<QuestionOptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  publicValue: () => Promise<String>;
}

export interface QuestionOptionPreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionOptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  publicValue: () => Promise<AsyncIterator<String>>;
}

export interface QuestionOptionSubscriptionPayload {
  mutation: MutationType;
  node: QuestionOption;
  updatedFields: String[];
  previousValues: QuestionOptionPreviousValues;
}

export interface QuestionOptionSubscriptionPayloadPromise
  extends Promise<QuestionOptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionOptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionOptionPreviousValuesPromise>() => T;
}

export interface QuestionOptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionOptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionOptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionOptionPreviousValuesSubscription>() => T;
}

export interface QuestionnaireSettings {
  id: ID_Output;
  title?: String;
  logo?: String;
}

export interface QuestionnaireSettingsPromise
  extends Promise<QuestionnaireSettings>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  questionnaire: <T = QuestionnairePromise>() => T;
  title: () => Promise<String>;
  logo: () => Promise<String>;
  colourSettings: <T = ColourSettingsPromise>() => T;
  fontSettings: <T = FontSettingsPromise>() => T;
}

export interface QuestionnaireSettingsSubscription
  extends Promise<AsyncIterator<QuestionnaireSettings>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customer: <T = CustomerSubscription>() => T;
  questionnaire: <T = QuestionnaireSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
  colourSettings: <T = ColourSettingsSubscription>() => T;
  fontSettings: <T = FontSettingsSubscription>() => T;
}

export interface QuestionnaireSettingsNullablePromise
  extends Promise<QuestionnaireSettings | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  questionnaire: <T = QuestionnairePromise>() => T;
  title: () => Promise<String>;
  logo: () => Promise<String>;
  colourSettings: <T = ColourSettingsPromise>() => T;
  fontSettings: <T = FontSettingsPromise>() => T;
}

export interface QuestionConditionPreviousValues {
  id: ID_Output;
  conditionType: String;
  renderMin?: Int;
  renderMax?: Int;
  matchValue?: String;
}

export interface QuestionConditionPreviousValuesPromise
  extends Promise<QuestionConditionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  conditionType: () => Promise<String>;
  renderMin: () => Promise<Int>;
  renderMax: () => Promise<Int>;
  matchValue: () => Promise<String>;
}

export interface QuestionConditionPreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionConditionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  conditionType: () => Promise<AsyncIterator<String>>;
  renderMin: () => Promise<AsyncIterator<Int>>;
  renderMax: () => Promise<AsyncIterator<Int>>;
  matchValue: () => Promise<AsyncIterator<String>>;
}

export interface LeafNodeConnection {
  pageInfo: PageInfo;
  edges: LeafNodeEdge[];
}

export interface LeafNodeConnectionPromise
  extends Promise<LeafNodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LeafNodeEdge>>() => T;
  aggregate: <T = AggregateLeafNodePromise>() => T;
}

export interface LeafNodeConnectionSubscription
  extends Promise<AsyncIterator<LeafNodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LeafNodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLeafNodeSubscription>() => T;
}

export interface AggregateQuestionCondition {
  count: Int;
}

export interface AggregateQuestionConditionPromise
  extends Promise<AggregateQuestionCondition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionConditionSubscription
  extends Promise<AsyncIterator<AggregateQuestionCondition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionnaireSettingsConnection {
  pageInfo: PageInfo;
  edges: QuestionnaireSettingsEdge[];
}

export interface QuestionnaireSettingsConnectionPromise
  extends Promise<QuestionnaireSettingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionnaireSettingsEdge>>() => T;
  aggregate: <T = AggregateQuestionnaireSettingsPromise>() => T;
}

export interface QuestionnaireSettingsConnectionSubscription
  extends Promise<AsyncIterator<QuestionnaireSettingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<QuestionnaireSettingsEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateQuestionnaireSettingsSubscription>() => T;
}

export interface AggregateColourSettings {
  count: Int;
}

export interface AggregateColourSettingsPromise
  extends Promise<AggregateColourSettings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateColourSettingsSubscription
  extends Promise<AsyncIterator<AggregateColourSettings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "QuestionCondition",
    embedded: false
  },
  {
    name: "QuestionOption",
    embedded: false
  },
  {
    name: "Questionnaire",
    embedded: false
  },
  {
    name: "QuestionnaireSettings",
    embedded: false
  },
  {
    name: "ColourSettings",
    embedded: false
  },
  {
    name: "FontSettings",
    embedded: false
  },
  {
    name: "Customer",
    embedded: false
  },
  {
    name: "ConditionType",
    embedded: false
  },
  {
    name: "QuestionType",
    embedded: false
  },
  {
    name: "QQuestion",
    embedded: false
  },
  {
    name: "LeafNode",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
