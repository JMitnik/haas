// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateColourSettings {
  count: Int!
}

type AggregateCustomer {
  count: Int!
}

type AggregateCustomerSettings {
  count: Int!
}

type AggregateEdge {
  count: Int!
}

type AggregateFontSettings {
  count: Int!
}

type AggregateLeafNode {
  count: Int!
}

type AggregateNodeEntry {
  count: Int!
}

type AggregateNodeEntryValue {
  count: Int!
}

type AggregateQuestionCondition {
  count: Int!
}

type AggregateQuestionnaire {
  count: Int!
}

type AggregateQuestionNode {
  count: Int!
}

type AggregateQuestionOption {
  count: Int!
}

type AggregateSession {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type ColourSettings {
  id: ID!
  primary: String!
  primaryAlt: String
  secondary: String
  tertiary: String
  success: String
  warning: String
  error: String
  lightest: String
  light: String
  normal: String
  dark: String
  darkest: String
  muted: String
  text: String
}

type ColourSettingsConnection {
  pageInfo: PageInfo!
  edges: [ColourSettingsEdge]!
  aggregate: AggregateColourSettings!
}

input ColourSettingsCreateInput {
  id: ID
  primary: String!
  primaryAlt: String
  secondary: String
  tertiary: String
  success: String
  warning: String
  error: String
  lightest: String
  light: String
  normal: String
  dark: String
  darkest: String
  muted: String
  text: String
}

input ColourSettingsCreateOneInput {
  create: ColourSettingsCreateInput
  connect: ColourSettingsWhereUniqueInput
}

type ColourSettingsEdge {
  node: ColourSettings!
  cursor: String!
}

enum ColourSettingsOrderByInput {
  id_ASC
  id_DESC
  primary_ASC
  primary_DESC
  primaryAlt_ASC
  primaryAlt_DESC
  secondary_ASC
  secondary_DESC
  tertiary_ASC
  tertiary_DESC
  success_ASC
  success_DESC
  warning_ASC
  warning_DESC
  error_ASC
  error_DESC
  lightest_ASC
  lightest_DESC
  light_ASC
  light_DESC
  normal_ASC
  normal_DESC
  dark_ASC
  dark_DESC
  darkest_ASC
  darkest_DESC
  muted_ASC
  muted_DESC
  text_ASC
  text_DESC
}

type ColourSettingsPreviousValues {
  id: ID!
  primary: String!
  primaryAlt: String
  secondary: String
  tertiary: String
  success: String
  warning: String
  error: String
  lightest: String
  light: String
  normal: String
  dark: String
  darkest: String
  muted: String
  text: String
}

type ColourSettingsSubscriptionPayload {
  mutation: MutationType!
  node: ColourSettings
  updatedFields: [String!]
  previousValues: ColourSettingsPreviousValues
}

input ColourSettingsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ColourSettingsWhereInput
  AND: [ColourSettingsSubscriptionWhereInput!]
  OR: [ColourSettingsSubscriptionWhereInput!]
  NOT: [ColourSettingsSubscriptionWhereInput!]
}

input ColourSettingsUpdateDataInput {
  primary: String
  primaryAlt: String
  secondary: String
  tertiary: String
  success: String
  warning: String
  error: String
  lightest: String
  light: String
  normal: String
  dark: String
  darkest: String
  muted: String
  text: String
}

input ColourSettingsUpdateInput {
  primary: String
  primaryAlt: String
  secondary: String
  tertiary: String
  success: String
  warning: String
  error: String
  lightest: String
  light: String
  normal: String
  dark: String
  darkest: String
  muted: String
  text: String
}

input ColourSettingsUpdateManyMutationInput {
  primary: String
  primaryAlt: String
  secondary: String
  tertiary: String
  success: String
  warning: String
  error: String
  lightest: String
  light: String
  normal: String
  dark: String
  darkest: String
  muted: String
  text: String
}

input ColourSettingsUpdateOneInput {
  create: ColourSettingsCreateInput
  update: ColourSettingsUpdateDataInput
  upsert: ColourSettingsUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ColourSettingsWhereUniqueInput
}

input ColourSettingsUpsertNestedInput {
  update: ColourSettingsUpdateDataInput!
  create: ColourSettingsCreateInput!
}

input ColourSettingsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  primary: String
  primary_not: String
  primary_in: [String!]
  primary_not_in: [String!]
  primary_lt: String
  primary_lte: String
  primary_gt: String
  primary_gte: String
  primary_contains: String
  primary_not_contains: String
  primary_starts_with: String
  primary_not_starts_with: String
  primary_ends_with: String
  primary_not_ends_with: String
  primaryAlt: String
  primaryAlt_not: String
  primaryAlt_in: [String!]
  primaryAlt_not_in: [String!]
  primaryAlt_lt: String
  primaryAlt_lte: String
  primaryAlt_gt: String
  primaryAlt_gte: String
  primaryAlt_contains: String
  primaryAlt_not_contains: String
  primaryAlt_starts_with: String
  primaryAlt_not_starts_with: String
  primaryAlt_ends_with: String
  primaryAlt_not_ends_with: String
  secondary: String
  secondary_not: String
  secondary_in: [String!]
  secondary_not_in: [String!]
  secondary_lt: String
  secondary_lte: String
  secondary_gt: String
  secondary_gte: String
  secondary_contains: String
  secondary_not_contains: String
  secondary_starts_with: String
  secondary_not_starts_with: String
  secondary_ends_with: String
  secondary_not_ends_with: String
  tertiary: String
  tertiary_not: String
  tertiary_in: [String!]
  tertiary_not_in: [String!]
  tertiary_lt: String
  tertiary_lte: String
  tertiary_gt: String
  tertiary_gte: String
  tertiary_contains: String
  tertiary_not_contains: String
  tertiary_starts_with: String
  tertiary_not_starts_with: String
  tertiary_ends_with: String
  tertiary_not_ends_with: String
  success: String
  success_not: String
  success_in: [String!]
  success_not_in: [String!]
  success_lt: String
  success_lte: String
  success_gt: String
  success_gte: String
  success_contains: String
  success_not_contains: String
  success_starts_with: String
  success_not_starts_with: String
  success_ends_with: String
  success_not_ends_with: String
  warning: String
  warning_not: String
  warning_in: [String!]
  warning_not_in: [String!]
  warning_lt: String
  warning_lte: String
  warning_gt: String
  warning_gte: String
  warning_contains: String
  warning_not_contains: String
  warning_starts_with: String
  warning_not_starts_with: String
  warning_ends_with: String
  warning_not_ends_with: String
  error: String
  error_not: String
  error_in: [String!]
  error_not_in: [String!]
  error_lt: String
  error_lte: String
  error_gt: String
  error_gte: String
  error_contains: String
  error_not_contains: String
  error_starts_with: String
  error_not_starts_with: String
  error_ends_with: String
  error_not_ends_with: String
  lightest: String
  lightest_not: String
  lightest_in: [String!]
  lightest_not_in: [String!]
  lightest_lt: String
  lightest_lte: String
  lightest_gt: String
  lightest_gte: String
  lightest_contains: String
  lightest_not_contains: String
  lightest_starts_with: String
  lightest_not_starts_with: String
  lightest_ends_with: String
  lightest_not_ends_with: String
  light: String
  light_not: String
  light_in: [String!]
  light_not_in: [String!]
  light_lt: String
  light_lte: String
  light_gt: String
  light_gte: String
  light_contains: String
  light_not_contains: String
  light_starts_with: String
  light_not_starts_with: String
  light_ends_with: String
  light_not_ends_with: String
  normal: String
  normal_not: String
  normal_in: [String!]
  normal_not_in: [String!]
  normal_lt: String
  normal_lte: String
  normal_gt: String
  normal_gte: String
  normal_contains: String
  normal_not_contains: String
  normal_starts_with: String
  normal_not_starts_with: String
  normal_ends_with: String
  normal_not_ends_with: String
  dark: String
  dark_not: String
  dark_in: [String!]
  dark_not_in: [String!]
  dark_lt: String
  dark_lte: String
  dark_gt: String
  dark_gte: String
  dark_contains: String
  dark_not_contains: String
  dark_starts_with: String
  dark_not_starts_with: String
  dark_ends_with: String
  dark_not_ends_with: String
  darkest: String
  darkest_not: String
  darkest_in: [String!]
  darkest_not_in: [String!]
  darkest_lt: String
  darkest_lte: String
  darkest_gt: String
  darkest_gte: String
  darkest_contains: String
  darkest_not_contains: String
  darkest_starts_with: String
  darkest_not_starts_with: String
  darkest_ends_with: String
  darkest_not_ends_with: String
  muted: String
  muted_not: String
  muted_in: [String!]
  muted_not_in: [String!]
  muted_lt: String
  muted_lte: String
  muted_gt: String
  muted_gte: String
  muted_contains: String
  muted_not_contains: String
  muted_starts_with: String
  muted_not_starts_with: String
  muted_ends_with: String
  muted_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [ColourSettingsWhereInput!]
  OR: [ColourSettingsWhereInput!]
  NOT: [ColourSettingsWhereInput!]
}

input ColourSettingsWhereUniqueInput {
  id: ID
}

type Customer {
  id: ID!
  name: String!
  questionnaires(where: QuestionnaireWhereInput, orderBy: QuestionnaireOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Questionnaire!]
  settings: CustomerSettings
}

type CustomerConnection {
  pageInfo: PageInfo!
  edges: [CustomerEdge]!
  aggregate: AggregateCustomer!
}

input CustomerCreateInput {
  id: ID
  name: String!
  questionnaires: QuestionnaireCreateManyWithoutCustomerInput
  settings: CustomerSettingsCreateOneInput
}

input CustomerCreateOneWithoutQuestionnairesInput {
  create: CustomerCreateWithoutQuestionnairesInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateWithoutQuestionnairesInput {
  id: ID
  name: String!
  settings: CustomerSettingsCreateOneInput
}

type CustomerEdge {
  node: Customer!
  cursor: String!
}

enum CustomerOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type CustomerPreviousValues {
  id: ID!
  name: String!
}

type CustomerSettings {
  id: ID!
  logoUrl: String
  colourSettings: ColourSettings
  fontSettings: FontSettings
}

type CustomerSettingsConnection {
  pageInfo: PageInfo!
  edges: [CustomerSettingsEdge]!
  aggregate: AggregateCustomerSettings!
}

input CustomerSettingsCreateInput {
  id: ID
  logoUrl: String
  colourSettings: ColourSettingsCreateOneInput
  fontSettings: FontSettingsCreateOneInput
}

input CustomerSettingsCreateOneInput {
  create: CustomerSettingsCreateInput
  connect: CustomerSettingsWhereUniqueInput
}

type CustomerSettingsEdge {
  node: CustomerSettings!
  cursor: String!
}

enum CustomerSettingsOrderByInput {
  id_ASC
  id_DESC
  logoUrl_ASC
  logoUrl_DESC
}

type CustomerSettingsPreviousValues {
  id: ID!
  logoUrl: String
}

type CustomerSettingsSubscriptionPayload {
  mutation: MutationType!
  node: CustomerSettings
  updatedFields: [String!]
  previousValues: CustomerSettingsPreviousValues
}

input CustomerSettingsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CustomerSettingsWhereInput
  AND: [CustomerSettingsSubscriptionWhereInput!]
  OR: [CustomerSettingsSubscriptionWhereInput!]
  NOT: [CustomerSettingsSubscriptionWhereInput!]
}

input CustomerSettingsUpdateDataInput {
  logoUrl: String
  colourSettings: ColourSettingsUpdateOneInput
  fontSettings: FontSettingsUpdateOneInput
}

input CustomerSettingsUpdateInput {
  logoUrl: String
  colourSettings: ColourSettingsUpdateOneInput
  fontSettings: FontSettingsUpdateOneInput
}

input CustomerSettingsUpdateManyMutationInput {
  logoUrl: String
}

input CustomerSettingsUpdateOneInput {
  create: CustomerSettingsCreateInput
  update: CustomerSettingsUpdateDataInput
  upsert: CustomerSettingsUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CustomerSettingsWhereUniqueInput
}

input CustomerSettingsUpsertNestedInput {
  update: CustomerSettingsUpdateDataInput!
  create: CustomerSettingsCreateInput!
}

input CustomerSettingsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  logoUrl: String
  logoUrl_not: String
  logoUrl_in: [String!]
  logoUrl_not_in: [String!]
  logoUrl_lt: String
  logoUrl_lte: String
  logoUrl_gt: String
  logoUrl_gte: String
  logoUrl_contains: String
  logoUrl_not_contains: String
  logoUrl_starts_with: String
  logoUrl_not_starts_with: String
  logoUrl_ends_with: String
  logoUrl_not_ends_with: String
  colourSettings: ColourSettingsWhereInput
  fontSettings: FontSettingsWhereInput
  AND: [CustomerSettingsWhereInput!]
  OR: [CustomerSettingsWhereInput!]
  NOT: [CustomerSettingsWhereInput!]
}

input CustomerSettingsWhereUniqueInput {
  id: ID
}

type CustomerSubscriptionPayload {
  mutation: MutationType!
  node: Customer
  updatedFields: [String!]
  previousValues: CustomerPreviousValues
}

input CustomerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CustomerWhereInput
  AND: [CustomerSubscriptionWhereInput!]
  OR: [CustomerSubscriptionWhereInput!]
  NOT: [CustomerSubscriptionWhereInput!]
}

input CustomerUpdateInput {
  name: String
  questionnaires: QuestionnaireUpdateManyWithoutCustomerInput
  settings: CustomerSettingsUpdateOneInput
}

input CustomerUpdateManyMutationInput {
  name: String
}

input CustomerUpdateOneRequiredWithoutQuestionnairesInput {
  create: CustomerCreateWithoutQuestionnairesInput
  update: CustomerUpdateWithoutQuestionnairesDataInput
  upsert: CustomerUpsertWithoutQuestionnairesInput
  connect: CustomerWhereUniqueInput
}

input CustomerUpdateWithoutQuestionnairesDataInput {
  name: String
  settings: CustomerSettingsUpdateOneInput
}

input CustomerUpsertWithoutQuestionnairesInput {
  update: CustomerUpdateWithoutQuestionnairesDataInput!
  create: CustomerCreateWithoutQuestionnairesInput!
}

input CustomerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  questionnaires_every: QuestionnaireWhereInput
  questionnaires_some: QuestionnaireWhereInput
  questionnaires_none: QuestionnaireWhereInput
  settings: CustomerSettingsWhereInput
  AND: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
}

input CustomerWhereUniqueInput {
  id: ID
}

scalar DateTime

type Edge {
  id: ID!
  questionnaire: Questionnaire
  createdAt: DateTime!
  updatedAt: DateTime!
  conditions(where: QuestionConditionWhereInput, orderBy: QuestionConditionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [QuestionCondition!]
  parentNode: QuestionNode
  childNode: QuestionNode
}

type EdgeConnection {
  pageInfo: PageInfo!
  edges: [EdgeEdge]!
  aggregate: AggregateEdge!
}

input EdgeCreateInput {
  id: ID
  questionnaire: QuestionnaireCreateOneInput
  conditions: QuestionConditionCreateManyInput
  parentNode: QuestionNodeCreateOneInput
  childNode: QuestionNodeCreateOneInput
}

input EdgeCreateManyInput {
  create: [EdgeCreateInput!]
  connect: [EdgeWhereUniqueInput!]
}

input EdgeCreateOneInput {
  create: EdgeCreateInput
  connect: EdgeWhereUniqueInput
}

type EdgeEdge {
  node: Edge!
  cursor: String!
}

enum EdgeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EdgePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EdgeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [EdgeScalarWhereInput!]
  OR: [EdgeScalarWhereInput!]
  NOT: [EdgeScalarWhereInput!]
}

type EdgeSubscriptionPayload {
  mutation: MutationType!
  node: Edge
  updatedFields: [String!]
  previousValues: EdgePreviousValues
}

input EdgeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EdgeWhereInput
  AND: [EdgeSubscriptionWhereInput!]
  OR: [EdgeSubscriptionWhereInput!]
  NOT: [EdgeSubscriptionWhereInput!]
}

input EdgeUpdateDataInput {
  questionnaire: QuestionnaireUpdateOneInput
  conditions: QuestionConditionUpdateManyInput
  parentNode: QuestionNodeUpdateOneInput
  childNode: QuestionNodeUpdateOneInput
}

input EdgeUpdateInput {
  questionnaire: QuestionnaireUpdateOneInput
  conditions: QuestionConditionUpdateManyInput
  parentNode: QuestionNodeUpdateOneInput
  childNode: QuestionNodeUpdateOneInput
}

input EdgeUpdateManyInput {
  create: [EdgeCreateInput!]
  update: [EdgeUpdateWithWhereUniqueNestedInput!]
  upsert: [EdgeUpsertWithWhereUniqueNestedInput!]
  delete: [EdgeWhereUniqueInput!]
  connect: [EdgeWhereUniqueInput!]
  set: [EdgeWhereUniqueInput!]
  disconnect: [EdgeWhereUniqueInput!]
  deleteMany: [EdgeScalarWhereInput!]
}

input EdgeUpdateOneInput {
  create: EdgeCreateInput
  update: EdgeUpdateDataInput
  upsert: EdgeUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: EdgeWhereUniqueInput
}

input EdgeUpdateWithWhereUniqueNestedInput {
  where: EdgeWhereUniqueInput!
  data: EdgeUpdateDataInput!
}

input EdgeUpsertNestedInput {
  update: EdgeUpdateDataInput!
  create: EdgeCreateInput!
}

input EdgeUpsertWithWhereUniqueNestedInput {
  where: EdgeWhereUniqueInput!
  update: EdgeUpdateDataInput!
  create: EdgeCreateInput!
}

input EdgeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  questionnaire: QuestionnaireWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  conditions_every: QuestionConditionWhereInput
  conditions_some: QuestionConditionWhereInput
  conditions_none: QuestionConditionWhereInput
  parentNode: QuestionNodeWhereInput
  childNode: QuestionNodeWhereInput
  AND: [EdgeWhereInput!]
  OR: [EdgeWhereInput!]
  NOT: [EdgeWhereInput!]
}

input EdgeWhereUniqueInput {
  id: ID
}

type FontSettings {
  id: ID!
  settingTitle: String
  body: String
  fontTitle: String
  special: String
}

type FontSettingsConnection {
  pageInfo: PageInfo!
  edges: [FontSettingsEdge]!
  aggregate: AggregateFontSettings!
}

input FontSettingsCreateInput {
  id: ID
  settingTitle: String
  body: String
  fontTitle: String
  special: String
}

input FontSettingsCreateOneInput {
  create: FontSettingsCreateInput
  connect: FontSettingsWhereUniqueInput
}

type FontSettingsEdge {
  node: FontSettings!
  cursor: String!
}

enum FontSettingsOrderByInput {
  id_ASC
  id_DESC
  settingTitle_ASC
  settingTitle_DESC
  body_ASC
  body_DESC
  fontTitle_ASC
  fontTitle_DESC
  special_ASC
  special_DESC
}

type FontSettingsPreviousValues {
  id: ID!
  settingTitle: String
  body: String
  fontTitle: String
  special: String
}

type FontSettingsSubscriptionPayload {
  mutation: MutationType!
  node: FontSettings
  updatedFields: [String!]
  previousValues: FontSettingsPreviousValues
}

input FontSettingsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FontSettingsWhereInput
  AND: [FontSettingsSubscriptionWhereInput!]
  OR: [FontSettingsSubscriptionWhereInput!]
  NOT: [FontSettingsSubscriptionWhereInput!]
}

input FontSettingsUpdateDataInput {
  settingTitle: String
  body: String
  fontTitle: String
  special: String
}

input FontSettingsUpdateInput {
  settingTitle: String
  body: String
  fontTitle: String
  special: String
}

input FontSettingsUpdateManyMutationInput {
  settingTitle: String
  body: String
  fontTitle: String
  special: String
}

input FontSettingsUpdateOneInput {
  create: FontSettingsCreateInput
  update: FontSettingsUpdateDataInput
  upsert: FontSettingsUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: FontSettingsWhereUniqueInput
}

input FontSettingsUpsertNestedInput {
  update: FontSettingsUpdateDataInput!
  create: FontSettingsCreateInput!
}

input FontSettingsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  settingTitle: String
  settingTitle_not: String
  settingTitle_in: [String!]
  settingTitle_not_in: [String!]
  settingTitle_lt: String
  settingTitle_lte: String
  settingTitle_gt: String
  settingTitle_gte: String
  settingTitle_contains: String
  settingTitle_not_contains: String
  settingTitle_starts_with: String
  settingTitle_not_starts_with: String
  settingTitle_ends_with: String
  settingTitle_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  fontTitle: String
  fontTitle_not: String
  fontTitle_in: [String!]
  fontTitle_not_in: [String!]
  fontTitle_lt: String
  fontTitle_lte: String
  fontTitle_gt: String
  fontTitle_gte: String
  fontTitle_contains: String
  fontTitle_not_contains: String
  fontTitle_starts_with: String
  fontTitle_not_starts_with: String
  fontTitle_ends_with: String
  fontTitle_not_ends_with: String
  special: String
  special_not: String
  special_in: [String!]
  special_not_in: [String!]
  special_lt: String
  special_lte: String
  special_gt: String
  special_gte: String
  special_contains: String
  special_not_contains: String
  special_starts_with: String
  special_not_starts_with: String
  special_ends_with: String
  special_not_ends_with: String
  AND: [FontSettingsWhereInput!]
  OR: [FontSettingsWhereInput!]
  NOT: [FontSettingsWhereInput!]
}

input FontSettingsWhereUniqueInput {
  id: ID
}

type LeafNode {
  id: ID!
  nodeId: Int
  type: NodeType
  title: String!
}

type LeafNodeConnection {
  pageInfo: PageInfo!
  edges: [LeafNodeEdge]!
  aggregate: AggregateLeafNode!
}

input LeafNodeCreateInput {
  id: ID
  nodeId: Int
  type: NodeType
  title: String!
}

input LeafNodeCreateManyInput {
  create: [LeafNodeCreateInput!]
  connect: [LeafNodeWhereUniqueInput!]
}

input LeafNodeCreateOneInput {
  create: LeafNodeCreateInput
  connect: LeafNodeWhereUniqueInput
}

type LeafNodeEdge {
  node: LeafNode!
  cursor: String!
}

enum LeafNodeOrderByInput {
  id_ASC
  id_DESC
  nodeId_ASC
  nodeId_DESC
  type_ASC
  type_DESC
  title_ASC
  title_DESC
}

type LeafNodePreviousValues {
  id: ID!
  nodeId: Int
  type: NodeType
  title: String!
}

input LeafNodeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  nodeId: Int
  nodeId_not: Int
  nodeId_in: [Int!]
  nodeId_not_in: [Int!]
  nodeId_lt: Int
  nodeId_lte: Int
  nodeId_gt: Int
  nodeId_gte: Int
  type: NodeType
  type_not: NodeType
  type_in: [NodeType!]
  type_not_in: [NodeType!]
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [LeafNodeScalarWhereInput!]
  OR: [LeafNodeScalarWhereInput!]
  NOT: [LeafNodeScalarWhereInput!]
}

type LeafNodeSubscriptionPayload {
  mutation: MutationType!
  node: LeafNode
  updatedFields: [String!]
  previousValues: LeafNodePreviousValues
}

input LeafNodeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LeafNodeWhereInput
  AND: [LeafNodeSubscriptionWhereInput!]
  OR: [LeafNodeSubscriptionWhereInput!]
  NOT: [LeafNodeSubscriptionWhereInput!]
}

input LeafNodeUpdateDataInput {
  nodeId: Int
  type: NodeType
  title: String
}

input LeafNodeUpdateInput {
  nodeId: Int
  type: NodeType
  title: String
}

input LeafNodeUpdateManyDataInput {
  nodeId: Int
  type: NodeType
  title: String
}

input LeafNodeUpdateManyInput {
  create: [LeafNodeCreateInput!]
  update: [LeafNodeUpdateWithWhereUniqueNestedInput!]
  upsert: [LeafNodeUpsertWithWhereUniqueNestedInput!]
  delete: [LeafNodeWhereUniqueInput!]
  connect: [LeafNodeWhereUniqueInput!]
  set: [LeafNodeWhereUniqueInput!]
  disconnect: [LeafNodeWhereUniqueInput!]
  deleteMany: [LeafNodeScalarWhereInput!]
  updateMany: [LeafNodeUpdateManyWithWhereNestedInput!]
}

input LeafNodeUpdateManyMutationInput {
  nodeId: Int
  type: NodeType
  title: String
}

input LeafNodeUpdateManyWithWhereNestedInput {
  where: LeafNodeScalarWhereInput!
  data: LeafNodeUpdateManyDataInput!
}

input LeafNodeUpdateOneInput {
  create: LeafNodeCreateInput
  update: LeafNodeUpdateDataInput
  upsert: LeafNodeUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LeafNodeWhereUniqueInput
}

input LeafNodeUpdateWithWhereUniqueNestedInput {
  where: LeafNodeWhereUniqueInput!
  data: LeafNodeUpdateDataInput!
}

input LeafNodeUpsertNestedInput {
  update: LeafNodeUpdateDataInput!
  create: LeafNodeCreateInput!
}

input LeafNodeUpsertWithWhereUniqueNestedInput {
  where: LeafNodeWhereUniqueInput!
  update: LeafNodeUpdateDataInput!
  create: LeafNodeCreateInput!
}

input LeafNodeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  nodeId: Int
  nodeId_not: Int
  nodeId_in: [Int!]
  nodeId_not_in: [Int!]
  nodeId_lt: Int
  nodeId_lte: Int
  nodeId_gt: Int
  nodeId_gte: Int
  type: NodeType
  type_not: NodeType
  type_in: [NodeType!]
  type_not_in: [NodeType!]
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [LeafNodeWhereInput!]
  OR: [LeafNodeWhereInput!]
  NOT: [LeafNodeWhereInput!]
}

input LeafNodeWhereUniqueInput {
  id: ID
  nodeId: Int
}

scalar Long

type Mutation {
  createColourSettings(data: ColourSettingsCreateInput!): ColourSettings!
  updateColourSettings(data: ColourSettingsUpdateInput!, where: ColourSettingsWhereUniqueInput!): ColourSettings
  updateManyColourSettingses(data: ColourSettingsUpdateManyMutationInput!, where: ColourSettingsWhereInput): BatchPayload!
  upsertColourSettings(where: ColourSettingsWhereUniqueInput!, create: ColourSettingsCreateInput!, update: ColourSettingsUpdateInput!): ColourSettings!
  deleteColourSettings(where: ColourSettingsWhereUniqueInput!): ColourSettings
  deleteManyColourSettingses(where: ColourSettingsWhereInput): BatchPayload!
  createCustomer(data: CustomerCreateInput!): Customer!
  updateCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateManyCustomers(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): BatchPayload!
  upsertCustomer(where: CustomerWhereUniqueInput!, create: CustomerCreateInput!, update: CustomerUpdateInput!): Customer!
  deleteCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteManyCustomers(where: CustomerWhereInput): BatchPayload!
  createCustomerSettings(data: CustomerSettingsCreateInput!): CustomerSettings!
  updateCustomerSettings(data: CustomerSettingsUpdateInput!, where: CustomerSettingsWhereUniqueInput!): CustomerSettings
  updateManyCustomerSettingses(data: CustomerSettingsUpdateManyMutationInput!, where: CustomerSettingsWhereInput): BatchPayload!
  upsertCustomerSettings(where: CustomerSettingsWhereUniqueInput!, create: CustomerSettingsCreateInput!, update: CustomerSettingsUpdateInput!): CustomerSettings!
  deleteCustomerSettings(where: CustomerSettingsWhereUniqueInput!): CustomerSettings
  deleteManyCustomerSettingses(where: CustomerSettingsWhereInput): BatchPayload!
  createEdge(data: EdgeCreateInput!): Edge!
  updateEdge(data: EdgeUpdateInput!, where: EdgeWhereUniqueInput!): Edge
  upsertEdge(where: EdgeWhereUniqueInput!, create: EdgeCreateInput!, update: EdgeUpdateInput!): Edge!
  deleteEdge(where: EdgeWhereUniqueInput!): Edge
  deleteManyEdges(where: EdgeWhereInput): BatchPayload!
  createFontSettings(data: FontSettingsCreateInput!): FontSettings!
  updateFontSettings(data: FontSettingsUpdateInput!, where: FontSettingsWhereUniqueInput!): FontSettings
  updateManyFontSettingses(data: FontSettingsUpdateManyMutationInput!, where: FontSettingsWhereInput): BatchPayload!
  upsertFontSettings(where: FontSettingsWhereUniqueInput!, create: FontSettingsCreateInput!, update: FontSettingsUpdateInput!): FontSettings!
  deleteFontSettings(where: FontSettingsWhereUniqueInput!): FontSettings
  deleteManyFontSettingses(where: FontSettingsWhereInput): BatchPayload!
  createLeafNode(data: LeafNodeCreateInput!): LeafNode!
  updateLeafNode(data: LeafNodeUpdateInput!, where: LeafNodeWhereUniqueInput!): LeafNode
  updateManyLeafNodes(data: LeafNodeUpdateManyMutationInput!, where: LeafNodeWhereInput): BatchPayload!
  upsertLeafNode(where: LeafNodeWhereUniqueInput!, create: LeafNodeCreateInput!, update: LeafNodeUpdateInput!): LeafNode!
  deleteLeafNode(where: LeafNodeWhereUniqueInput!): LeafNode
  deleteManyLeafNodes(where: LeafNodeWhereInput): BatchPayload!
  createNodeEntry(data: NodeEntryCreateInput!): NodeEntry!
  updateNodeEntry(data: NodeEntryUpdateInput!, where: NodeEntryWhereUniqueInput!): NodeEntry
  updateManyNodeEntries(data: NodeEntryUpdateManyMutationInput!, where: NodeEntryWhereInput): BatchPayload!
  upsertNodeEntry(where: NodeEntryWhereUniqueInput!, create: NodeEntryCreateInput!, update: NodeEntryUpdateInput!): NodeEntry!
  deleteNodeEntry(where: NodeEntryWhereUniqueInput!): NodeEntry
  deleteManyNodeEntries(where: NodeEntryWhereInput): BatchPayload!
  createNodeEntryValue(data: NodeEntryValueCreateInput!): NodeEntryValue!
  updateNodeEntryValue(data: NodeEntryValueUpdateInput!, where: NodeEntryValueWhereUniqueInput!): NodeEntryValue
  updateManyNodeEntryValues(data: NodeEntryValueUpdateManyMutationInput!, where: NodeEntryValueWhereInput): BatchPayload!
  upsertNodeEntryValue(where: NodeEntryValueWhereUniqueInput!, create: NodeEntryValueCreateInput!, update: NodeEntryValueUpdateInput!): NodeEntryValue!
  deleteNodeEntryValue(where: NodeEntryValueWhereUniqueInput!): NodeEntryValue
  deleteManyNodeEntryValues(where: NodeEntryValueWhereInput): BatchPayload!
  createQuestionCondition(data: QuestionConditionCreateInput!): QuestionCondition!
  updateQuestionCondition(data: QuestionConditionUpdateInput!, where: QuestionConditionWhereUniqueInput!): QuestionCondition
  updateManyQuestionConditions(data: QuestionConditionUpdateManyMutationInput!, where: QuestionConditionWhereInput): BatchPayload!
  upsertQuestionCondition(where: QuestionConditionWhereUniqueInput!, create: QuestionConditionCreateInput!, update: QuestionConditionUpdateInput!): QuestionCondition!
  deleteQuestionCondition(where: QuestionConditionWhereUniqueInput!): QuestionCondition
  deleteManyQuestionConditions(where: QuestionConditionWhereInput): BatchPayload!
  createQuestionNode(data: QuestionNodeCreateInput!): QuestionNode!
  updateQuestionNode(data: QuestionNodeUpdateInput!, where: QuestionNodeWhereUniqueInput!): QuestionNode
  updateManyQuestionNodes(data: QuestionNodeUpdateManyMutationInput!, where: QuestionNodeWhereInput): BatchPayload!
  upsertQuestionNode(where: QuestionNodeWhereUniqueInput!, create: QuestionNodeCreateInput!, update: QuestionNodeUpdateInput!): QuestionNode!
  deleteQuestionNode(where: QuestionNodeWhereUniqueInput!): QuestionNode
  deleteManyQuestionNodes(where: QuestionNodeWhereInput): BatchPayload!
  createQuestionOption(data: QuestionOptionCreateInput!): QuestionOption!
  updateQuestionOption(data: QuestionOptionUpdateInput!, where: QuestionOptionWhereUniqueInput!): QuestionOption
  updateManyQuestionOptions(data: QuestionOptionUpdateManyMutationInput!, where: QuestionOptionWhereInput): BatchPayload!
  upsertQuestionOption(where: QuestionOptionWhereUniqueInput!, create: QuestionOptionCreateInput!, update: QuestionOptionUpdateInput!): QuestionOption!
  deleteQuestionOption(where: QuestionOptionWhereUniqueInput!): QuestionOption
  deleteManyQuestionOptions(where: QuestionOptionWhereInput): BatchPayload!
  createQuestionnaire(data: QuestionnaireCreateInput!): Questionnaire!
  updateQuestionnaire(data: QuestionnaireUpdateInput!, where: QuestionnaireWhereUniqueInput!): Questionnaire
  updateManyQuestionnaires(data: QuestionnaireUpdateManyMutationInput!, where: QuestionnaireWhereInput): BatchPayload!
  upsertQuestionnaire(where: QuestionnaireWhereUniqueInput!, create: QuestionnaireCreateInput!, update: QuestionnaireUpdateInput!): Questionnaire!
  deleteQuestionnaire(where: QuestionnaireWhereUniqueInput!): Questionnaire
  deleteManyQuestionnaires(where: QuestionnaireWhereInput): BatchPayload!
  createSession(data: SessionCreateInput!): Session!
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  upsertSession(where: SessionWhereUniqueInput!, create: SessionCreateInput!, update: SessionUpdateInput!): Session!
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteManySessions(where: SessionWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type NodeEntry {
  id: ID!
  session: Session!
  relatedNode: QuestionNode!
  edgeChild: Edge
  values(where: NodeEntryValueWhereInput, orderBy: NodeEntryValueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NodeEntryValue!]
  depth: Int
  creationDate: DateTime!
}

type NodeEntryConnection {
  pageInfo: PageInfo!
  edges: [NodeEntryEdge]!
  aggregate: AggregateNodeEntry!
}

input NodeEntryCreateInput {
  id: ID
  session: SessionCreateOneWithoutNodeEntriesInput!
  relatedNode: QuestionNodeCreateOneInput!
  edgeChild: EdgeCreateOneInput
  values: NodeEntryValueCreateManyInput
  depth: Int
}

input NodeEntryCreateManyWithoutSessionInput {
  create: [NodeEntryCreateWithoutSessionInput!]
  connect: [NodeEntryWhereUniqueInput!]
}

input NodeEntryCreateWithoutSessionInput {
  id: ID
  relatedNode: QuestionNodeCreateOneInput!
  edgeChild: EdgeCreateOneInput
  values: NodeEntryValueCreateManyInput
  depth: Int
}

type NodeEntryEdge {
  node: NodeEntry!
  cursor: String!
}

enum NodeEntryOrderByInput {
  id_ASC
  id_DESC
  depth_ASC
  depth_DESC
  creationDate_ASC
  creationDate_DESC
}

type NodeEntryPreviousValues {
  id: ID!
  depth: Int
  creationDate: DateTime!
}

input NodeEntryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  depth: Int
  depth_not: Int
  depth_in: [Int!]
  depth_not_in: [Int!]
  depth_lt: Int
  depth_lte: Int
  depth_gt: Int
  depth_gte: Int
  creationDate: DateTime
  creationDate_not: DateTime
  creationDate_in: [DateTime!]
  creationDate_not_in: [DateTime!]
  creationDate_lt: DateTime
  creationDate_lte: DateTime
  creationDate_gt: DateTime
  creationDate_gte: DateTime
  AND: [NodeEntryScalarWhereInput!]
  OR: [NodeEntryScalarWhereInput!]
  NOT: [NodeEntryScalarWhereInput!]
}

type NodeEntrySubscriptionPayload {
  mutation: MutationType!
  node: NodeEntry
  updatedFields: [String!]
  previousValues: NodeEntryPreviousValues
}

input NodeEntrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NodeEntryWhereInput
  AND: [NodeEntrySubscriptionWhereInput!]
  OR: [NodeEntrySubscriptionWhereInput!]
  NOT: [NodeEntrySubscriptionWhereInput!]
}

input NodeEntryUpdateInput {
  session: SessionUpdateOneRequiredWithoutNodeEntriesInput
  relatedNode: QuestionNodeUpdateOneRequiredInput
  edgeChild: EdgeUpdateOneInput
  values: NodeEntryValueUpdateManyInput
  depth: Int
}

input NodeEntryUpdateManyDataInput {
  depth: Int
}

input NodeEntryUpdateManyMutationInput {
  depth: Int
}

input NodeEntryUpdateManyWithoutSessionInput {
  create: [NodeEntryCreateWithoutSessionInput!]
  delete: [NodeEntryWhereUniqueInput!]
  connect: [NodeEntryWhereUniqueInput!]
  set: [NodeEntryWhereUniqueInput!]
  disconnect: [NodeEntryWhereUniqueInput!]
  update: [NodeEntryUpdateWithWhereUniqueWithoutSessionInput!]
  upsert: [NodeEntryUpsertWithWhereUniqueWithoutSessionInput!]
  deleteMany: [NodeEntryScalarWhereInput!]
  updateMany: [NodeEntryUpdateManyWithWhereNestedInput!]
}

input NodeEntryUpdateManyWithWhereNestedInput {
  where: NodeEntryScalarWhereInput!
  data: NodeEntryUpdateManyDataInput!
}

input NodeEntryUpdateWithoutSessionDataInput {
  relatedNode: QuestionNodeUpdateOneRequiredInput
  edgeChild: EdgeUpdateOneInput
  values: NodeEntryValueUpdateManyInput
  depth: Int
}

input NodeEntryUpdateWithWhereUniqueWithoutSessionInput {
  where: NodeEntryWhereUniqueInput!
  data: NodeEntryUpdateWithoutSessionDataInput!
}

input NodeEntryUpsertWithWhereUniqueWithoutSessionInput {
  where: NodeEntryWhereUniqueInput!
  update: NodeEntryUpdateWithoutSessionDataInput!
  create: NodeEntryCreateWithoutSessionInput!
}

type NodeEntryValue {
  id: ID!
  textValue: String
  numberValue: Int
  multiValues(where: NodeEntryValueWhereInput, orderBy: NodeEntryValueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NodeEntryValue!]
}

type NodeEntryValueConnection {
  pageInfo: PageInfo!
  edges: [NodeEntryValueEdge]!
  aggregate: AggregateNodeEntryValue!
}

input NodeEntryValueCreateInput {
  id: ID
  textValue: String
  numberValue: Int
  multiValues: NodeEntryValueCreateManyInput
}

input NodeEntryValueCreateManyInput {
  create: [NodeEntryValueCreateInput!]
  connect: [NodeEntryValueWhereUniqueInput!]
}

type NodeEntryValueEdge {
  node: NodeEntryValue!
  cursor: String!
}

enum NodeEntryValueOrderByInput {
  id_ASC
  id_DESC
  textValue_ASC
  textValue_DESC
  numberValue_ASC
  numberValue_DESC
}

type NodeEntryValuePreviousValues {
  id: ID!
  textValue: String
  numberValue: Int
}

input NodeEntryValueScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  textValue: String
  textValue_not: String
  textValue_in: [String!]
  textValue_not_in: [String!]
  textValue_lt: String
  textValue_lte: String
  textValue_gt: String
  textValue_gte: String
  textValue_contains: String
  textValue_not_contains: String
  textValue_starts_with: String
  textValue_not_starts_with: String
  textValue_ends_with: String
  textValue_not_ends_with: String
  numberValue: Int
  numberValue_not: Int
  numberValue_in: [Int!]
  numberValue_not_in: [Int!]
  numberValue_lt: Int
  numberValue_lte: Int
  numberValue_gt: Int
  numberValue_gte: Int
  AND: [NodeEntryValueScalarWhereInput!]
  OR: [NodeEntryValueScalarWhereInput!]
  NOT: [NodeEntryValueScalarWhereInput!]
}

type NodeEntryValueSubscriptionPayload {
  mutation: MutationType!
  node: NodeEntryValue
  updatedFields: [String!]
  previousValues: NodeEntryValuePreviousValues
}

input NodeEntryValueSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NodeEntryValueWhereInput
  AND: [NodeEntryValueSubscriptionWhereInput!]
  OR: [NodeEntryValueSubscriptionWhereInput!]
  NOT: [NodeEntryValueSubscriptionWhereInput!]
}

input NodeEntryValueUpdateDataInput {
  textValue: String
  numberValue: Int
  multiValues: NodeEntryValueUpdateManyInput
}

input NodeEntryValueUpdateInput {
  textValue: String
  numberValue: Int
  multiValues: NodeEntryValueUpdateManyInput
}

input NodeEntryValueUpdateManyDataInput {
  textValue: String
  numberValue: Int
}

input NodeEntryValueUpdateManyInput {
  create: [NodeEntryValueCreateInput!]
  update: [NodeEntryValueUpdateWithWhereUniqueNestedInput!]
  upsert: [NodeEntryValueUpsertWithWhereUniqueNestedInput!]
  delete: [NodeEntryValueWhereUniqueInput!]
  connect: [NodeEntryValueWhereUniqueInput!]
  set: [NodeEntryValueWhereUniqueInput!]
  disconnect: [NodeEntryValueWhereUniqueInput!]
  deleteMany: [NodeEntryValueScalarWhereInput!]
  updateMany: [NodeEntryValueUpdateManyWithWhereNestedInput!]
}

input NodeEntryValueUpdateManyMutationInput {
  textValue: String
  numberValue: Int
}

input NodeEntryValueUpdateManyWithWhereNestedInput {
  where: NodeEntryValueScalarWhereInput!
  data: NodeEntryValueUpdateManyDataInput!
}

input NodeEntryValueUpdateWithWhereUniqueNestedInput {
  where: NodeEntryValueWhereUniqueInput!
  data: NodeEntryValueUpdateDataInput!
}

input NodeEntryValueUpsertWithWhereUniqueNestedInput {
  where: NodeEntryValueWhereUniqueInput!
  update: NodeEntryValueUpdateDataInput!
  create: NodeEntryValueCreateInput!
}

input NodeEntryValueWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  textValue: String
  textValue_not: String
  textValue_in: [String!]
  textValue_not_in: [String!]
  textValue_lt: String
  textValue_lte: String
  textValue_gt: String
  textValue_gte: String
  textValue_contains: String
  textValue_not_contains: String
  textValue_starts_with: String
  textValue_not_starts_with: String
  textValue_ends_with: String
  textValue_not_ends_with: String
  numberValue: Int
  numberValue_not: Int
  numberValue_in: [Int!]
  numberValue_not_in: [Int!]
  numberValue_lt: Int
  numberValue_lte: Int
  numberValue_gt: Int
  numberValue_gte: Int
  multiValues_every: NodeEntryValueWhereInput
  multiValues_some: NodeEntryValueWhereInput
  multiValues_none: NodeEntryValueWhereInput
  AND: [NodeEntryValueWhereInput!]
  OR: [NodeEntryValueWhereInput!]
  NOT: [NodeEntryValueWhereInput!]
}

input NodeEntryValueWhereUniqueInput {
  id: ID
}

input NodeEntryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  session: SessionWhereInput
  relatedNode: QuestionNodeWhereInput
  edgeChild: EdgeWhereInput
  values_every: NodeEntryValueWhereInput
  values_some: NodeEntryValueWhereInput
  values_none: NodeEntryValueWhereInput
  depth: Int
  depth_not: Int
  depth_in: [Int!]
  depth_not_in: [Int!]
  depth_lt: Int
  depth_lte: Int
  depth_gt: Int
  depth_gte: Int
  creationDate: DateTime
  creationDate_not: DateTime
  creationDate_in: [DateTime!]
  creationDate_not_in: [DateTime!]
  creationDate_lt: DateTime
  creationDate_lte: DateTime
  creationDate_gt: DateTime
  creationDate_gte: DateTime
  AND: [NodeEntryWhereInput!]
  OR: [NodeEntryWhereInput!]
  NOT: [NodeEntryWhereInput!]
}

input NodeEntryWhereUniqueInput {
  id: ID
}

enum NodeType {
  SLIDER
  MULTI_CHOICE
  TEXTBOX
  SOCIAL_SHARE
  REGISTRATION
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  colourSettings(where: ColourSettingsWhereUniqueInput!): ColourSettings
  colourSettingses(where: ColourSettingsWhereInput, orderBy: ColourSettingsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ColourSettings]!
  colourSettingsesConnection(where: ColourSettingsWhereInput, orderBy: ColourSettingsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ColourSettingsConnection!
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer]!
  customersConnection(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerConnection!
  customerSettings(where: CustomerSettingsWhereUniqueInput!): CustomerSettings
  customerSettingses(where: CustomerSettingsWhereInput, orderBy: CustomerSettingsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CustomerSettings]!
  customerSettingsesConnection(where: CustomerSettingsWhereInput, orderBy: CustomerSettingsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerSettingsConnection!
  edge(where: EdgeWhereUniqueInput!): Edge
  edges(where: EdgeWhereInput, orderBy: EdgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Edge]!
  edgesConnection(where: EdgeWhereInput, orderBy: EdgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EdgeConnection!
  fontSettings(where: FontSettingsWhereUniqueInput!): FontSettings
  fontSettingses(where: FontSettingsWhereInput, orderBy: FontSettingsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FontSettings]!
  fontSettingsesConnection(where: FontSettingsWhereInput, orderBy: FontSettingsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FontSettingsConnection!
  leafNode(where: LeafNodeWhereUniqueInput!): LeafNode
  leafNodes(where: LeafNodeWhereInput, orderBy: LeafNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LeafNode]!
  leafNodesConnection(where: LeafNodeWhereInput, orderBy: LeafNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LeafNodeConnection!
  nodeEntry(where: NodeEntryWhereUniqueInput!): NodeEntry
  nodeEntries(where: NodeEntryWhereInput, orderBy: NodeEntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NodeEntry]!
  nodeEntriesConnection(where: NodeEntryWhereInput, orderBy: NodeEntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NodeEntryConnection!
  nodeEntryValue(where: NodeEntryValueWhereUniqueInput!): NodeEntryValue
  nodeEntryValues(where: NodeEntryValueWhereInput, orderBy: NodeEntryValueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NodeEntryValue]!
  nodeEntryValuesConnection(where: NodeEntryValueWhereInput, orderBy: NodeEntryValueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NodeEntryValueConnection!
  questionCondition(where: QuestionConditionWhereUniqueInput!): QuestionCondition
  questionConditions(where: QuestionConditionWhereInput, orderBy: QuestionConditionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [QuestionCondition]!
  questionConditionsConnection(where: QuestionConditionWhereInput, orderBy: QuestionConditionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuestionConditionConnection!
  questionNode(where: QuestionNodeWhereUniqueInput!): QuestionNode
  questionNodes(where: QuestionNodeWhereInput, orderBy: QuestionNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [QuestionNode]!
  questionNodesConnection(where: QuestionNodeWhereInput, orderBy: QuestionNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuestionNodeConnection!
  questionOption(where: QuestionOptionWhereUniqueInput!): QuestionOption
  questionOptions(where: QuestionOptionWhereInput, orderBy: QuestionOptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [QuestionOption]!
  questionOptionsConnection(where: QuestionOptionWhereInput, orderBy: QuestionOptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuestionOptionConnection!
  questionnaire(where: QuestionnaireWhereUniqueInput!): Questionnaire
  questionnaires(where: QuestionnaireWhereInput, orderBy: QuestionnaireOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Questionnaire]!
  questionnairesConnection(where: QuestionnaireWhereInput, orderBy: QuestionnaireOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuestionnaireConnection!
  session(where: SessionWhereUniqueInput!): Session
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session]!
  sessionsConnection(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SessionConnection!
  node(id: ID!): Node
}

type QuestionCondition {
  id: ID!
  conditionType: String!
  renderMin: Int
  renderMax: Int
  matchValue: String
}

type QuestionConditionConnection {
  pageInfo: PageInfo!
  edges: [QuestionConditionEdge]!
  aggregate: AggregateQuestionCondition!
}

input QuestionConditionCreateInput {
  id: ID
  conditionType: String!
  renderMin: Int
  renderMax: Int
  matchValue: String
}

input QuestionConditionCreateManyInput {
  create: [QuestionConditionCreateInput!]
  connect: [QuestionConditionWhereUniqueInput!]
}

type QuestionConditionEdge {
  node: QuestionCondition!
  cursor: String!
}

enum QuestionConditionOrderByInput {
  id_ASC
  id_DESC
  conditionType_ASC
  conditionType_DESC
  renderMin_ASC
  renderMin_DESC
  renderMax_ASC
  renderMax_DESC
  matchValue_ASC
  matchValue_DESC
}

type QuestionConditionPreviousValues {
  id: ID!
  conditionType: String!
  renderMin: Int
  renderMax: Int
  matchValue: String
}

input QuestionConditionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  conditionType: String
  conditionType_not: String
  conditionType_in: [String!]
  conditionType_not_in: [String!]
  conditionType_lt: String
  conditionType_lte: String
  conditionType_gt: String
  conditionType_gte: String
  conditionType_contains: String
  conditionType_not_contains: String
  conditionType_starts_with: String
  conditionType_not_starts_with: String
  conditionType_ends_with: String
  conditionType_not_ends_with: String
  renderMin: Int
  renderMin_not: Int
  renderMin_in: [Int!]
  renderMin_not_in: [Int!]
  renderMin_lt: Int
  renderMin_lte: Int
  renderMin_gt: Int
  renderMin_gte: Int
  renderMax: Int
  renderMax_not: Int
  renderMax_in: [Int!]
  renderMax_not_in: [Int!]
  renderMax_lt: Int
  renderMax_lte: Int
  renderMax_gt: Int
  renderMax_gte: Int
  matchValue: String
  matchValue_not: String
  matchValue_in: [String!]
  matchValue_not_in: [String!]
  matchValue_lt: String
  matchValue_lte: String
  matchValue_gt: String
  matchValue_gte: String
  matchValue_contains: String
  matchValue_not_contains: String
  matchValue_starts_with: String
  matchValue_not_starts_with: String
  matchValue_ends_with: String
  matchValue_not_ends_with: String
  AND: [QuestionConditionScalarWhereInput!]
  OR: [QuestionConditionScalarWhereInput!]
  NOT: [QuestionConditionScalarWhereInput!]
}

type QuestionConditionSubscriptionPayload {
  mutation: MutationType!
  node: QuestionCondition
  updatedFields: [String!]
  previousValues: QuestionConditionPreviousValues
}

input QuestionConditionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuestionConditionWhereInput
  AND: [QuestionConditionSubscriptionWhereInput!]
  OR: [QuestionConditionSubscriptionWhereInput!]
  NOT: [QuestionConditionSubscriptionWhereInput!]
}

input QuestionConditionUpdateDataInput {
  conditionType: String
  renderMin: Int
  renderMax: Int
  matchValue: String
}

input QuestionConditionUpdateInput {
  conditionType: String
  renderMin: Int
  renderMax: Int
  matchValue: String
}

input QuestionConditionUpdateManyDataInput {
  conditionType: String
  renderMin: Int
  renderMax: Int
  matchValue: String
}

input QuestionConditionUpdateManyInput {
  create: [QuestionConditionCreateInput!]
  update: [QuestionConditionUpdateWithWhereUniqueNestedInput!]
  upsert: [QuestionConditionUpsertWithWhereUniqueNestedInput!]
  delete: [QuestionConditionWhereUniqueInput!]
  connect: [QuestionConditionWhereUniqueInput!]
  set: [QuestionConditionWhereUniqueInput!]
  disconnect: [QuestionConditionWhereUniqueInput!]
  deleteMany: [QuestionConditionScalarWhereInput!]
  updateMany: [QuestionConditionUpdateManyWithWhereNestedInput!]
}

input QuestionConditionUpdateManyMutationInput {
  conditionType: String
  renderMin: Int
  renderMax: Int
  matchValue: String
}

input QuestionConditionUpdateManyWithWhereNestedInput {
  where: QuestionConditionScalarWhereInput!
  data: QuestionConditionUpdateManyDataInput!
}

input QuestionConditionUpdateWithWhereUniqueNestedInput {
  where: QuestionConditionWhereUniqueInput!
  data: QuestionConditionUpdateDataInput!
}

input QuestionConditionUpsertWithWhereUniqueNestedInput {
  where: QuestionConditionWhereUniqueInput!
  update: QuestionConditionUpdateDataInput!
  create: QuestionConditionCreateInput!
}

input QuestionConditionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  conditionType: String
  conditionType_not: String
  conditionType_in: [String!]
  conditionType_not_in: [String!]
  conditionType_lt: String
  conditionType_lte: String
  conditionType_gt: String
  conditionType_gte: String
  conditionType_contains: String
  conditionType_not_contains: String
  conditionType_starts_with: String
  conditionType_not_starts_with: String
  conditionType_ends_with: String
  conditionType_not_ends_with: String
  renderMin: Int
  renderMin_not: Int
  renderMin_in: [Int!]
  renderMin_not_in: [Int!]
  renderMin_lt: Int
  renderMin_lte: Int
  renderMin_gt: Int
  renderMin_gte: Int
  renderMax: Int
  renderMax_not: Int
  renderMax_in: [Int!]
  renderMax_not_in: [Int!]
  renderMax_lt: Int
  renderMax_lte: Int
  renderMax_gt: Int
  renderMax_gte: Int
  matchValue: String
  matchValue_not: String
  matchValue_in: [String!]
  matchValue_not_in: [String!]
  matchValue_lt: String
  matchValue_lte: String
  matchValue_gt: String
  matchValue_gte: String
  matchValue_contains: String
  matchValue_not_contains: String
  matchValue_starts_with: String
  matchValue_not_starts_with: String
  matchValue_ends_with: String
  matchValue_not_ends_with: String
  AND: [QuestionConditionWhereInput!]
  OR: [QuestionConditionWhereInput!]
  NOT: [QuestionConditionWhereInput!]
}

input QuestionConditionWhereUniqueInput {
  id: ID
}

type Questionnaire {
  id: ID!
  customer: Customer!
  title: String!
  description: String!
  publicTitle: String
  creationDate: DateTime!
  updatedAt: DateTime
  rootQuestion: QuestionNode
  questions(where: QuestionNodeWhereInput, orderBy: QuestionNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [QuestionNode!]
  leafs(where: LeafNodeWhereInput, orderBy: LeafNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LeafNode!]
}

type QuestionnaireConnection {
  pageInfo: PageInfo!
  edges: [QuestionnaireEdge]!
  aggregate: AggregateQuestionnaire!
}

input QuestionnaireCreateInput {
  id: ID
  customer: CustomerCreateOneWithoutQuestionnairesInput!
  title: String!
  description: String!
  publicTitle: String
  rootQuestion: QuestionNodeCreateOneInput
  questions: QuestionNodeCreateManyWithoutQuestionnaireInput
  leafs: LeafNodeCreateManyInput
}

input QuestionnaireCreateManyWithoutCustomerInput {
  create: [QuestionnaireCreateWithoutCustomerInput!]
  connect: [QuestionnaireWhereUniqueInput!]
}

input QuestionnaireCreateOneInput {
  create: QuestionnaireCreateInput
  connect: QuestionnaireWhereUniqueInput
}

input QuestionnaireCreateOneWithoutQuestionsInput {
  create: QuestionnaireCreateWithoutQuestionsInput
  connect: QuestionnaireWhereUniqueInput
}

input QuestionnaireCreateWithoutCustomerInput {
  id: ID
  title: String!
  description: String!
  publicTitle: String
  rootQuestion: QuestionNodeCreateOneInput
  questions: QuestionNodeCreateManyWithoutQuestionnaireInput
  leafs: LeafNodeCreateManyInput
}

input QuestionnaireCreateWithoutQuestionsInput {
  id: ID
  customer: CustomerCreateOneWithoutQuestionnairesInput!
  title: String!
  description: String!
  publicTitle: String
  rootQuestion: QuestionNodeCreateOneInput
  leafs: LeafNodeCreateManyInput
}

type QuestionnaireEdge {
  node: Questionnaire!
  cursor: String!
}

enum QuestionnaireOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  publicTitle_ASC
  publicTitle_DESC
  creationDate_ASC
  creationDate_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type QuestionnairePreviousValues {
  id: ID!
  title: String!
  description: String!
  publicTitle: String
  creationDate: DateTime!
  updatedAt: DateTime
}

input QuestionnaireScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  publicTitle: String
  publicTitle_not: String
  publicTitle_in: [String!]
  publicTitle_not_in: [String!]
  publicTitle_lt: String
  publicTitle_lte: String
  publicTitle_gt: String
  publicTitle_gte: String
  publicTitle_contains: String
  publicTitle_not_contains: String
  publicTitle_starts_with: String
  publicTitle_not_starts_with: String
  publicTitle_ends_with: String
  publicTitle_not_ends_with: String
  creationDate: DateTime
  creationDate_not: DateTime
  creationDate_in: [DateTime!]
  creationDate_not_in: [DateTime!]
  creationDate_lt: DateTime
  creationDate_lte: DateTime
  creationDate_gt: DateTime
  creationDate_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [QuestionnaireScalarWhereInput!]
  OR: [QuestionnaireScalarWhereInput!]
  NOT: [QuestionnaireScalarWhereInput!]
}

type QuestionnaireSubscriptionPayload {
  mutation: MutationType!
  node: Questionnaire
  updatedFields: [String!]
  previousValues: QuestionnairePreviousValues
}

input QuestionnaireSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuestionnaireWhereInput
  AND: [QuestionnaireSubscriptionWhereInput!]
  OR: [QuestionnaireSubscriptionWhereInput!]
  NOT: [QuestionnaireSubscriptionWhereInput!]
}

input QuestionnaireUpdateDataInput {
  customer: CustomerUpdateOneRequiredWithoutQuestionnairesInput
  title: String
  description: String
  publicTitle: String
  rootQuestion: QuestionNodeUpdateOneInput
  questions: QuestionNodeUpdateManyWithoutQuestionnaireInput
  leafs: LeafNodeUpdateManyInput
}

input QuestionnaireUpdateInput {
  customer: CustomerUpdateOneRequiredWithoutQuestionnairesInput
  title: String
  description: String
  publicTitle: String
  rootQuestion: QuestionNodeUpdateOneInput
  questions: QuestionNodeUpdateManyWithoutQuestionnaireInput
  leafs: LeafNodeUpdateManyInput
}

input QuestionnaireUpdateManyDataInput {
  title: String
  description: String
  publicTitle: String
}

input QuestionnaireUpdateManyMutationInput {
  title: String
  description: String
  publicTitle: String
}

input QuestionnaireUpdateManyWithoutCustomerInput {
  create: [QuestionnaireCreateWithoutCustomerInput!]
  delete: [QuestionnaireWhereUniqueInput!]
  connect: [QuestionnaireWhereUniqueInput!]
  set: [QuestionnaireWhereUniqueInput!]
  disconnect: [QuestionnaireWhereUniqueInput!]
  update: [QuestionnaireUpdateWithWhereUniqueWithoutCustomerInput!]
  upsert: [QuestionnaireUpsertWithWhereUniqueWithoutCustomerInput!]
  deleteMany: [QuestionnaireScalarWhereInput!]
  updateMany: [QuestionnaireUpdateManyWithWhereNestedInput!]
}

input QuestionnaireUpdateManyWithWhereNestedInput {
  where: QuestionnaireScalarWhereInput!
  data: QuestionnaireUpdateManyDataInput!
}

input QuestionnaireUpdateOneInput {
  create: QuestionnaireCreateInput
  update: QuestionnaireUpdateDataInput
  upsert: QuestionnaireUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: QuestionnaireWhereUniqueInput
}

input QuestionnaireUpdateOneWithoutQuestionsInput {
  create: QuestionnaireCreateWithoutQuestionsInput
  update: QuestionnaireUpdateWithoutQuestionsDataInput
  upsert: QuestionnaireUpsertWithoutQuestionsInput
  delete: Boolean
  disconnect: Boolean
  connect: QuestionnaireWhereUniqueInput
}

input QuestionnaireUpdateWithoutCustomerDataInput {
  title: String
  description: String
  publicTitle: String
  rootQuestion: QuestionNodeUpdateOneInput
  questions: QuestionNodeUpdateManyWithoutQuestionnaireInput
  leafs: LeafNodeUpdateManyInput
}

input QuestionnaireUpdateWithoutQuestionsDataInput {
  customer: CustomerUpdateOneRequiredWithoutQuestionnairesInput
  title: String
  description: String
  publicTitle: String
  rootQuestion: QuestionNodeUpdateOneInput
  leafs: LeafNodeUpdateManyInput
}

input QuestionnaireUpdateWithWhereUniqueWithoutCustomerInput {
  where: QuestionnaireWhereUniqueInput!
  data: QuestionnaireUpdateWithoutCustomerDataInput!
}

input QuestionnaireUpsertNestedInput {
  update: QuestionnaireUpdateDataInput!
  create: QuestionnaireCreateInput!
}

input QuestionnaireUpsertWithoutQuestionsInput {
  update: QuestionnaireUpdateWithoutQuestionsDataInput!
  create: QuestionnaireCreateWithoutQuestionsInput!
}

input QuestionnaireUpsertWithWhereUniqueWithoutCustomerInput {
  where: QuestionnaireWhereUniqueInput!
  update: QuestionnaireUpdateWithoutCustomerDataInput!
  create: QuestionnaireCreateWithoutCustomerInput!
}

input QuestionnaireWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  customer: CustomerWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  publicTitle: String
  publicTitle_not: String
  publicTitle_in: [String!]
  publicTitle_not_in: [String!]
  publicTitle_lt: String
  publicTitle_lte: String
  publicTitle_gt: String
  publicTitle_gte: String
  publicTitle_contains: String
  publicTitle_not_contains: String
  publicTitle_starts_with: String
  publicTitle_not_starts_with: String
  publicTitle_ends_with: String
  publicTitle_not_ends_with: String
  creationDate: DateTime
  creationDate_not: DateTime
  creationDate_in: [DateTime!]
  creationDate_not_in: [DateTime!]
  creationDate_lt: DateTime
  creationDate_lte: DateTime
  creationDate_gt: DateTime
  creationDate_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  rootQuestion: QuestionNodeWhereInput
  questions_every: QuestionNodeWhereInput
  questions_some: QuestionNodeWhereInput
  questions_none: QuestionNodeWhereInput
  leafs_every: LeafNodeWhereInput
  leafs_some: LeafNodeWhereInput
  leafs_none: LeafNodeWhereInput
  AND: [QuestionnaireWhereInput!]
  OR: [QuestionnaireWhereInput!]
  NOT: [QuestionnaireWhereInput!]
}

input QuestionnaireWhereUniqueInput {
  id: ID
}

type QuestionNode {
  id: ID!
  questionnaire: Questionnaire
  title: String!
  branchVal: String
  isRoot: Boolean!
  type: NodeType!
  overrideLeaf: LeafNode
  options(where: QuestionOptionWhereInput, orderBy: QuestionOptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [QuestionOption!]
  children(where: QuestionNodeWhereInput, orderBy: QuestionNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [QuestionNode!]
  edgeChildren(where: EdgeWhereInput, orderBy: EdgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Edge!]
}

type QuestionNodeConnection {
  pageInfo: PageInfo!
  edges: [QuestionNodeEdge]!
  aggregate: AggregateQuestionNode!
}

input QuestionNodeCreateInput {
  id: ID
  questionnaire: QuestionnaireCreateOneWithoutQuestionsInput
  title: String!
  branchVal: String
  isRoot: Boolean
  type: NodeType!
  overrideLeaf: LeafNodeCreateOneInput
  options: QuestionOptionCreateManyInput
  children: QuestionNodeCreateManyInput
  edgeChildren: EdgeCreateManyInput
}

input QuestionNodeCreateManyInput {
  create: [QuestionNodeCreateInput!]
  connect: [QuestionNodeWhereUniqueInput!]
}

input QuestionNodeCreateManyWithoutQuestionnaireInput {
  create: [QuestionNodeCreateWithoutQuestionnaireInput!]
  connect: [QuestionNodeWhereUniqueInput!]
}

input QuestionNodeCreateOneInput {
  create: QuestionNodeCreateInput
  connect: QuestionNodeWhereUniqueInput
}

input QuestionNodeCreateWithoutQuestionnaireInput {
  id: ID
  title: String!
  branchVal: String
  isRoot: Boolean
  type: NodeType!
  overrideLeaf: LeafNodeCreateOneInput
  options: QuestionOptionCreateManyInput
  children: QuestionNodeCreateManyInput
  edgeChildren: EdgeCreateManyInput
}

type QuestionNodeEdge {
  node: QuestionNode!
  cursor: String!
}

enum QuestionNodeOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  branchVal_ASC
  branchVal_DESC
  isRoot_ASC
  isRoot_DESC
  type_ASC
  type_DESC
}

type QuestionNodePreviousValues {
  id: ID!
  title: String!
  branchVal: String
  isRoot: Boolean!
  type: NodeType!
}

input QuestionNodeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  branchVal: String
  branchVal_not: String
  branchVal_in: [String!]
  branchVal_not_in: [String!]
  branchVal_lt: String
  branchVal_lte: String
  branchVal_gt: String
  branchVal_gte: String
  branchVal_contains: String
  branchVal_not_contains: String
  branchVal_starts_with: String
  branchVal_not_starts_with: String
  branchVal_ends_with: String
  branchVal_not_ends_with: String
  isRoot: Boolean
  isRoot_not: Boolean
  type: NodeType
  type_not: NodeType
  type_in: [NodeType!]
  type_not_in: [NodeType!]
  AND: [QuestionNodeScalarWhereInput!]
  OR: [QuestionNodeScalarWhereInput!]
  NOT: [QuestionNodeScalarWhereInput!]
}

type QuestionNodeSubscriptionPayload {
  mutation: MutationType!
  node: QuestionNode
  updatedFields: [String!]
  previousValues: QuestionNodePreviousValues
}

input QuestionNodeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuestionNodeWhereInput
  AND: [QuestionNodeSubscriptionWhereInput!]
  OR: [QuestionNodeSubscriptionWhereInput!]
  NOT: [QuestionNodeSubscriptionWhereInput!]
}

input QuestionNodeUpdateDataInput {
  questionnaire: QuestionnaireUpdateOneWithoutQuestionsInput
  title: String
  branchVal: String
  isRoot: Boolean
  type: NodeType
  overrideLeaf: LeafNodeUpdateOneInput
  options: QuestionOptionUpdateManyInput
  children: QuestionNodeUpdateManyInput
  edgeChildren: EdgeUpdateManyInput
}

input QuestionNodeUpdateInput {
  questionnaire: QuestionnaireUpdateOneWithoutQuestionsInput
  title: String
  branchVal: String
  isRoot: Boolean
  type: NodeType
  overrideLeaf: LeafNodeUpdateOneInput
  options: QuestionOptionUpdateManyInput
  children: QuestionNodeUpdateManyInput
  edgeChildren: EdgeUpdateManyInput
}

input QuestionNodeUpdateManyDataInput {
  title: String
  branchVal: String
  isRoot: Boolean
  type: NodeType
}

input QuestionNodeUpdateManyInput {
  create: [QuestionNodeCreateInput!]
  update: [QuestionNodeUpdateWithWhereUniqueNestedInput!]
  upsert: [QuestionNodeUpsertWithWhereUniqueNestedInput!]
  delete: [QuestionNodeWhereUniqueInput!]
  connect: [QuestionNodeWhereUniqueInput!]
  set: [QuestionNodeWhereUniqueInput!]
  disconnect: [QuestionNodeWhereUniqueInput!]
  deleteMany: [QuestionNodeScalarWhereInput!]
  updateMany: [QuestionNodeUpdateManyWithWhereNestedInput!]
}

input QuestionNodeUpdateManyMutationInput {
  title: String
  branchVal: String
  isRoot: Boolean
  type: NodeType
}

input QuestionNodeUpdateManyWithoutQuestionnaireInput {
  create: [QuestionNodeCreateWithoutQuestionnaireInput!]
  delete: [QuestionNodeWhereUniqueInput!]
  connect: [QuestionNodeWhereUniqueInput!]
  set: [QuestionNodeWhereUniqueInput!]
  disconnect: [QuestionNodeWhereUniqueInput!]
  update: [QuestionNodeUpdateWithWhereUniqueWithoutQuestionnaireInput!]
  upsert: [QuestionNodeUpsertWithWhereUniqueWithoutQuestionnaireInput!]
  deleteMany: [QuestionNodeScalarWhereInput!]
  updateMany: [QuestionNodeUpdateManyWithWhereNestedInput!]
}

input QuestionNodeUpdateManyWithWhereNestedInput {
  where: QuestionNodeScalarWhereInput!
  data: QuestionNodeUpdateManyDataInput!
}

input QuestionNodeUpdateOneInput {
  create: QuestionNodeCreateInput
  update: QuestionNodeUpdateDataInput
  upsert: QuestionNodeUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: QuestionNodeWhereUniqueInput
}

input QuestionNodeUpdateOneRequiredInput {
  create: QuestionNodeCreateInput
  update: QuestionNodeUpdateDataInput
  upsert: QuestionNodeUpsertNestedInput
  connect: QuestionNodeWhereUniqueInput
}

input QuestionNodeUpdateWithoutQuestionnaireDataInput {
  title: String
  branchVal: String
  isRoot: Boolean
  type: NodeType
  overrideLeaf: LeafNodeUpdateOneInput
  options: QuestionOptionUpdateManyInput
  children: QuestionNodeUpdateManyInput
  edgeChildren: EdgeUpdateManyInput
}

input QuestionNodeUpdateWithWhereUniqueNestedInput {
  where: QuestionNodeWhereUniqueInput!
  data: QuestionNodeUpdateDataInput!
}

input QuestionNodeUpdateWithWhereUniqueWithoutQuestionnaireInput {
  where: QuestionNodeWhereUniqueInput!
  data: QuestionNodeUpdateWithoutQuestionnaireDataInput!
}

input QuestionNodeUpsertNestedInput {
  update: QuestionNodeUpdateDataInput!
  create: QuestionNodeCreateInput!
}

input QuestionNodeUpsertWithWhereUniqueNestedInput {
  where: QuestionNodeWhereUniqueInput!
  update: QuestionNodeUpdateDataInput!
  create: QuestionNodeCreateInput!
}

input QuestionNodeUpsertWithWhereUniqueWithoutQuestionnaireInput {
  where: QuestionNodeWhereUniqueInput!
  update: QuestionNodeUpdateWithoutQuestionnaireDataInput!
  create: QuestionNodeCreateWithoutQuestionnaireInput!
}

input QuestionNodeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  questionnaire: QuestionnaireWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  branchVal: String
  branchVal_not: String
  branchVal_in: [String!]
  branchVal_not_in: [String!]
  branchVal_lt: String
  branchVal_lte: String
  branchVal_gt: String
  branchVal_gte: String
  branchVal_contains: String
  branchVal_not_contains: String
  branchVal_starts_with: String
  branchVal_not_starts_with: String
  branchVal_ends_with: String
  branchVal_not_ends_with: String
  isRoot: Boolean
  isRoot_not: Boolean
  type: NodeType
  type_not: NodeType
  type_in: [NodeType!]
  type_not_in: [NodeType!]
  overrideLeaf: LeafNodeWhereInput
  options_every: QuestionOptionWhereInput
  options_some: QuestionOptionWhereInput
  options_none: QuestionOptionWhereInput
  children_every: QuestionNodeWhereInput
  children_some: QuestionNodeWhereInput
  children_none: QuestionNodeWhereInput
  edgeChildren_every: EdgeWhereInput
  edgeChildren_some: EdgeWhereInput
  edgeChildren_none: EdgeWhereInput
  AND: [QuestionNodeWhereInput!]
  OR: [QuestionNodeWhereInput!]
  NOT: [QuestionNodeWhereInput!]
}

input QuestionNodeWhereUniqueInput {
  id: ID
}

type QuestionOption {
  id: ID!
  value: String!
  publicValue: String
}

type QuestionOptionConnection {
  pageInfo: PageInfo!
  edges: [QuestionOptionEdge]!
  aggregate: AggregateQuestionOption!
}

input QuestionOptionCreateInput {
  id: ID
  value: String!
  publicValue: String
}

input QuestionOptionCreateManyInput {
  create: [QuestionOptionCreateInput!]
  connect: [QuestionOptionWhereUniqueInput!]
}

type QuestionOptionEdge {
  node: QuestionOption!
  cursor: String!
}

enum QuestionOptionOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
  publicValue_ASC
  publicValue_DESC
}

type QuestionOptionPreviousValues {
  id: ID!
  value: String!
  publicValue: String
}

input QuestionOptionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  publicValue: String
  publicValue_not: String
  publicValue_in: [String!]
  publicValue_not_in: [String!]
  publicValue_lt: String
  publicValue_lte: String
  publicValue_gt: String
  publicValue_gte: String
  publicValue_contains: String
  publicValue_not_contains: String
  publicValue_starts_with: String
  publicValue_not_starts_with: String
  publicValue_ends_with: String
  publicValue_not_ends_with: String
  AND: [QuestionOptionScalarWhereInput!]
  OR: [QuestionOptionScalarWhereInput!]
  NOT: [QuestionOptionScalarWhereInput!]
}

type QuestionOptionSubscriptionPayload {
  mutation: MutationType!
  node: QuestionOption
  updatedFields: [String!]
  previousValues: QuestionOptionPreviousValues
}

input QuestionOptionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuestionOptionWhereInput
  AND: [QuestionOptionSubscriptionWhereInput!]
  OR: [QuestionOptionSubscriptionWhereInput!]
  NOT: [QuestionOptionSubscriptionWhereInput!]
}

input QuestionOptionUpdateDataInput {
  value: String
  publicValue: String
}

input QuestionOptionUpdateInput {
  value: String
  publicValue: String
}

input QuestionOptionUpdateManyDataInput {
  value: String
  publicValue: String
}

input QuestionOptionUpdateManyInput {
  create: [QuestionOptionCreateInput!]
  update: [QuestionOptionUpdateWithWhereUniqueNestedInput!]
  upsert: [QuestionOptionUpsertWithWhereUniqueNestedInput!]
  delete: [QuestionOptionWhereUniqueInput!]
  connect: [QuestionOptionWhereUniqueInput!]
  set: [QuestionOptionWhereUniqueInput!]
  disconnect: [QuestionOptionWhereUniqueInput!]
  deleteMany: [QuestionOptionScalarWhereInput!]
  updateMany: [QuestionOptionUpdateManyWithWhereNestedInput!]
}

input QuestionOptionUpdateManyMutationInput {
  value: String
  publicValue: String
}

input QuestionOptionUpdateManyWithWhereNestedInput {
  where: QuestionOptionScalarWhereInput!
  data: QuestionOptionUpdateManyDataInput!
}

input QuestionOptionUpdateWithWhereUniqueNestedInput {
  where: QuestionOptionWhereUniqueInput!
  data: QuestionOptionUpdateDataInput!
}

input QuestionOptionUpsertWithWhereUniqueNestedInput {
  where: QuestionOptionWhereUniqueInput!
  update: QuestionOptionUpdateDataInput!
  create: QuestionOptionCreateInput!
}

input QuestionOptionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  publicValue: String
  publicValue_not: String
  publicValue_in: [String!]
  publicValue_not_in: [String!]
  publicValue_lt: String
  publicValue_lte: String
  publicValue_gt: String
  publicValue_gte: String
  publicValue_contains: String
  publicValue_not_contains: String
  publicValue_starts_with: String
  publicValue_not_starts_with: String
  publicValue_ends_with: String
  publicValue_not_ends_with: String
  AND: [QuestionOptionWhereInput!]
  OR: [QuestionOptionWhereInput!]
  NOT: [QuestionOptionWhereInput!]
}

input QuestionOptionWhereUniqueInput {
  id: ID
}

type Session {
  id: ID!
  nodeEntries(where: NodeEntryWhereInput, orderBy: NodeEntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NodeEntry!]
  createdAt: DateTime!
}

type SessionConnection {
  pageInfo: PageInfo!
  edges: [SessionEdge]!
  aggregate: AggregateSession!
}

input SessionCreateInput {
  id: ID
  nodeEntries: NodeEntryCreateManyWithoutSessionInput
}

input SessionCreateOneWithoutNodeEntriesInput {
  create: SessionCreateWithoutNodeEntriesInput
  connect: SessionWhereUniqueInput
}

input SessionCreateWithoutNodeEntriesInput {
  id: ID
}

type SessionEdge {
  node: Session!
  cursor: String!
}

enum SessionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
}

type SessionPreviousValues {
  id: ID!
  createdAt: DateTime!
}

type SessionSubscriptionPayload {
  mutation: MutationType!
  node: Session
  updatedFields: [String!]
  previousValues: SessionPreviousValues
}

input SessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SessionWhereInput
  AND: [SessionSubscriptionWhereInput!]
  OR: [SessionSubscriptionWhereInput!]
  NOT: [SessionSubscriptionWhereInput!]
}

input SessionUpdateInput {
  nodeEntries: NodeEntryUpdateManyWithoutSessionInput
}

input SessionUpdateOneRequiredWithoutNodeEntriesInput {
  create: SessionCreateWithoutNodeEntriesInput
  connect: SessionWhereUniqueInput
}

input SessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  nodeEntries_every: NodeEntryWhereInput
  nodeEntries_some: NodeEntryWhereInput
  nodeEntries_none: NodeEntryWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
}

input SessionWhereUniqueInput {
  id: ID
}

type Subscription {
  colourSettings(where: ColourSettingsSubscriptionWhereInput): ColourSettingsSubscriptionPayload
  customer(where: CustomerSubscriptionWhereInput): CustomerSubscriptionPayload
  customerSettings(where: CustomerSettingsSubscriptionWhereInput): CustomerSettingsSubscriptionPayload
  edge(where: EdgeSubscriptionWhereInput): EdgeSubscriptionPayload
  fontSettings(where: FontSettingsSubscriptionWhereInput): FontSettingsSubscriptionPayload
  leafNode(where: LeafNodeSubscriptionWhereInput): LeafNodeSubscriptionPayload
  nodeEntry(where: NodeEntrySubscriptionWhereInput): NodeEntrySubscriptionPayload
  nodeEntryValue(where: NodeEntryValueSubscriptionWhereInput): NodeEntryValueSubscriptionPayload
  questionCondition(where: QuestionConditionSubscriptionWhereInput): QuestionConditionSubscriptionPayload
  questionNode(where: QuestionNodeSubscriptionWhereInput): QuestionNodeSubscriptionPayload
  questionOption(where: QuestionOptionSubscriptionWhereInput): QuestionOptionSubscriptionPayload
  questionnaire(where: QuestionnaireSubscriptionWhereInput): QuestionnaireSubscriptionPayload
  session(where: SessionSubscriptionWhereInput): SessionSubscriptionPayload
}
`