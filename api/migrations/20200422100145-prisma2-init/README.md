# Migration `20200422100145-prisma2-init`

This migration has been generated by Cold-A-Muse at 4/22/2020, 10:01:45 AM.
You can check out the [state of the schema](./schema.prisma) after the migration.

## Database Steps

```sql
CREATE TABLE "public"."Customer" (
    "id" text  NOT NULL ,
    "name" text  NOT NULL ,
    "settings" integer   ,
    PRIMARY KEY ("id")
) 

CREATE TABLE "public"."Dialogue" (
    "creationDate" timestamp(3)  NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "customer" text  NOT NULL ,
    "description" text  NOT NULL ,
    "id" text  NOT NULL ,
    "publicTitle" text   ,
    "title" text  NOT NULL ,
    "updatedAt" timestamp(3)   ,
    PRIMARY KEY ("id")
) 

CREATE TABLE "public"."QuestionNode" (
    "edgeId" text   ,
    "id" text  NOT NULL ,
    "isLeaf" boolean  NOT NULL DEFAULT false,
    "isRoot" boolean  NOT NULL DEFAULT false,
    "overrideLeaf" text   ,
    "questionDialogue" text   ,
    "title" text  NOT NULL ,
    "type" text  NOT NULL ,
    PRIMARY KEY ("id")
) 

CREATE TABLE "public"."Edge" (
    "childNode" text  NOT NULL ,
    "createdAt" timestamp(3)  NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "dialogue" text   ,
    "id" text  NOT NULL ,
    "parentNode" text  NOT NULL ,
    "questionNodeId" text   ,
    "updatedAt" timestamp(3)  NOT NULL ,
    PRIMARY KEY ("id")
) 

CREATE TABLE "public"."QuestionCondition" (
    "conditionType" text  NOT NULL ,
    "edge" text  NOT NULL ,
    "id" SERIAL,
    "matchValue" text   ,
    "renderMax" integer   ,
    "renderMin" integer   ,
    PRIMARY KEY ("id")
) 

CREATE TABLE "public"."QuestionOption" (
    "id" SERIAL,
    "publicValue" text   ,
    "question" text   ,
    "questionNodeId" text   ,
    "value" text  NOT NULL ,
    PRIMARY KEY ("id")
) 

ALTER TABLE "public"."Dialogue" ADD FOREIGN KEY ("customer")REFERENCES "public"."Customer"("id") ON DELETE CASCADE  ON UPDATE CASCADE

ALTER TABLE "public"."QuestionNode" ADD FOREIGN KEY ("overrideLeaf")REFERENCES "public"."QuestionNode"("id") ON DELETE SET NULL  ON UPDATE CASCADE

ALTER TABLE "public"."QuestionNode" ADD FOREIGN KEY ("questionDialogue")REFERENCES "public"."Dialogue"("id") ON DELETE SET NULL  ON UPDATE CASCADE

ALTER TABLE "public"."QuestionNode" ADD FOREIGN KEY ("edgeId")REFERENCES "public"."Edge"("id") ON DELETE SET NULL  ON UPDATE CASCADE

ALTER TABLE "public"."Edge" ADD FOREIGN KEY ("childNode")REFERENCES "public"."QuestionNode"("id") ON DELETE CASCADE  ON UPDATE CASCADE

ALTER TABLE "public"."Edge" ADD FOREIGN KEY ("parentNode")REFERENCES "public"."QuestionNode"("id") ON DELETE CASCADE  ON UPDATE CASCADE

ALTER TABLE "public"."Edge" ADD FOREIGN KEY ("dialogue")REFERENCES "public"."Dialogue"("id") ON DELETE SET NULL  ON UPDATE CASCADE

ALTER TABLE "public"."Edge" ADD FOREIGN KEY ("questionNodeId")REFERENCES "public"."QuestionNode"("id") ON DELETE SET NULL  ON UPDATE CASCADE

ALTER TABLE "public"."QuestionCondition" ADD FOREIGN KEY ("edge")REFERENCES "public"."Edge"("id") ON DELETE CASCADE  ON UPDATE CASCADE

ALTER TABLE "public"."QuestionOption" ADD FOREIGN KEY ("question")REFERENCES "public"."QuestionNode"("id") ON DELETE SET NULL  ON UPDATE CASCADE

ALTER TABLE "public"."QuestionOption" ADD FOREIGN KEY ("questionNodeId")REFERENCES "public"."QuestionNode"("id") ON DELETE SET NULL  ON UPDATE CASCADE
```

## Changes

```diff
diff --git schema.prisma schema.prisma
migration ..20200422100145-prisma2-init
--- datamodel.dml
+++ datamodel.dml
@@ -1,0 +1,82 @@
+datasource postgresql {
+  provider = "postgresql"
+  url      = env("DB_STRING")
+}
+
+generator client {
+  provider = "prisma-client-js"
+}
+
+model Customer {
+  id               String            @default(cuid()) @id
+  name             String
+  settingsId       Int?              @map("settings")
+  dialogues        Dialogue[]
+  // settings         CustomerSettings? @relation(fields: [settingsId], references: [id])
+}
+
+model Dialogue {
+  creationDate DateTime       @default(now())
+  updatedAt    DateTime?      @updatedAt
+  description  String
+  id           String         @default(cuid()) @id
+  customerId                             String        @map("customer")
+  customer                               Customer      @relation(fields: [customerId], references: [id])
+  publicTitle  String?
+  title        String
+  edges        Edge[]
+  questions    QuestionNode[]
+}
+model QuestionNode {
+  id                 String    @default(cuid()) @id
+  isLeaf             Boolean   @default(false)
+  isRoot             Boolean   @default(false)
+  title              String
+  type               String
+  options            QuestionOption[]
+  children                                Edge[]
+  overrideLeafId                          String?           @map("overrideLeaf")
+  overrideLeaf                            QuestionNode?     @relation("QNodeToOverrideLeaf", fields: [overrideLeafId], references: [id])
+  isOverrideLeafOf                        QuestionNode[]    @relation("QNodeToOverrideLeaf")         
+  questionDialogue   Dialogue? @relation(fields: [questionDialogueId], references: [id])
+  questionDialogueId String?   @map("questionDialogue")
+
+  isChildNodeOf                           Edge[]           @relation("Edge_childNodeToQuestionNode")
+  isParentNodeOf                          Edge[]           @relation("Edge_parentNodeToQuestionNode")
+  // NodeEntry                               NodeEntry[] //// yea geen idee waar deze voor is maar ik laat em staan
+}
+
+model Edge {
+  childNodeId                                String              @map("childNode")
+  createdAt                                  DateTime            @default(now())
+  updatedAt                                  DateTime            @updatedAt
+  id                                         String              @default(cuid()) @id
+  parentNodeId                               String              @map("parentNode")
+  dialogueId                                 String?             @map("dialogue")
+  conditions                                 QuestionCondition[]  @relation("EdgeQQonditions")
+  isEdgeOf                                   QuestionNode[]       @relation("EdgeChildrenRelation")
+  childNode                                  QuestionNode       @relation("Edge_childNodeToQuestionNode", fields: [childNodeId], references: [id])
+  parentNode                                 QuestionNode       @relation("Edge_parentNodeToQuestionNode", fields: [parentNodeId], references: [id])
+  
+  // FIXME: dialogue ID wordt niet gevuld volgens mij
+  dialogue                                   Dialogue?           @relation(fields: [dialogueId], references: [id])
+  // NodeEntry                                  NodeEntry[] //// yea geen idee waar deze voor is maar ik laat em staan
+}
+
+model QuestionCondition {
+  conditionType String
+  id            Int  @default(autoincrement()) @id
+  matchValue    String?
+  renderMax     Int?
+  renderMin     Int?
+  edgeId        String @map("edge")
+  edge          Edge    @relation("EdgeQQonditions", fields: [edgeId], references: [id])
+}
+
+model QuestionOption {
+  id           Int         @default(autoincrement()) @id
+  publicValue  String?
+  value        String
+  questionId   String?         @map("question")
+  question     QuestionNode?   @relation("QuestionNodeOptions", fields: [questionId], references: [id])
+}
```


